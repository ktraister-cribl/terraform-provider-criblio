// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk"
	"github.com/criblio/terraform-provider-criblio/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &PackSourceResource{}
var _ resource.ResourceWithImportState = &PackSourceResource{}

func NewPackSourceResource() resource.Resource {
	return &PackSourceResource{}
}

// PackSourceResource defines the resource implementation.
type PackSourceResource struct {
	// Provider configured SDK client.
	client *sdk.CriblIo
}

// PackSourceResourceModel describes the resource data model.
type PackSourceResourceModel struct {
	GroupID                   types.String                       `tfsdk:"group_id"`
	ID                        types.String                       `queryParam:"style=form,explode=true,name=id" tfsdk:"id"`
	InputAppscope             *tfTypes.InputAppscope             `queryParam:"inline" tfsdk:"input_appscope" tfPlanOnly:"true"`
	InputAzureBlob            *tfTypes.InputAzureBlob            `queryParam:"inline" tfsdk:"input_azure_blob" tfPlanOnly:"true"`
	InputCollection           *tfTypes.InputCollection           `queryParam:"inline" tfsdk:"input_collection" tfPlanOnly:"true"`
	InputConfluentCloud       *tfTypes.InputConfluentCloud       `queryParam:"inline" tfsdk:"input_confluent_cloud" tfPlanOnly:"true"`
	InputCribl                *tfTypes.InputCribl                `queryParam:"inline" tfsdk:"input_cribl" tfPlanOnly:"true"`
	InputCriblHTTP            *tfTypes.InputCriblHTTP            `queryParam:"inline" tfsdk:"input_cribl_http" tfPlanOnly:"true"`
	InputCriblLakeHTTP        *tfTypes.InputCriblLakeHTTP        `queryParam:"inline" tfsdk:"input_cribl_lake_http" tfPlanOnly:"true"`
	InputCriblmetrics         *tfTypes.InputCriblmetrics         `queryParam:"inline" tfsdk:"input_criblmetrics" tfPlanOnly:"true"`
	InputCriblTCP             *tfTypes.InputCriblTCP             `queryParam:"inline" tfsdk:"input_cribl_tcp" tfPlanOnly:"true"`
	InputCrowdstrike          *tfTypes.InputCrowdstrike          `queryParam:"inline" tfsdk:"input_crowdstrike" tfPlanOnly:"true"`
	InputDatadogAgent         *tfTypes.InputDatadogAgent         `queryParam:"inline" tfsdk:"input_datadog_agent" tfPlanOnly:"true"`
	InputDatagen              *tfTypes.InputDatagen              `queryParam:"inline" tfsdk:"input_datagen" tfPlanOnly:"true"`
	InputEdgePrometheus       *tfTypes.InputEdgePrometheus       `queryParam:"inline" tfsdk:"input_edge_prometheus" tfPlanOnly:"true"`
	InputElastic              *tfTypes.InputElastic              `queryParam:"inline" tfsdk:"input_elastic" tfPlanOnly:"true"`
	InputEventhub             *tfTypes.InputEventhub             `queryParam:"inline" tfsdk:"input_eventhub" tfPlanOnly:"true"`
	InputExec                 *tfTypes.InputExec                 `queryParam:"inline" tfsdk:"input_exec" tfPlanOnly:"true"`
	InputFile                 *tfTypes.InputFile                 `queryParam:"inline" tfsdk:"input_file" tfPlanOnly:"true"`
	InputFirehose             *tfTypes.InputFirehose             `queryParam:"inline" tfsdk:"input_firehose" tfPlanOnly:"true"`
	InputGooglePubsub         *tfTypes.InputGooglePubsub         `queryParam:"inline" tfsdk:"input_google_pubsub" tfPlanOnly:"true"`
	InputGrafana              *tfTypes.InputGrafana              `queryParam:"inline" tfsdk:"input_grafana" tfPlanOnly:"true"`
	InputHTTP                 *tfTypes.InputHTTP                 `queryParam:"inline" tfsdk:"input_http" tfPlanOnly:"true"`
	InputHTTPRaw              *tfTypes.InputHTTPRaw              `queryParam:"inline" tfsdk:"input_http_raw" tfPlanOnly:"true"`
	InputJournalFiles         *tfTypes.InputJournalFiles         `queryParam:"inline" tfsdk:"input_journal_files" tfPlanOnly:"true"`
	InputKafka                *tfTypes.InputKafka                `queryParam:"inline" tfsdk:"input_kafka" tfPlanOnly:"true"`
	InputKinesis              *tfTypes.InputKinesis              `queryParam:"inline" tfsdk:"input_kinesis" tfPlanOnly:"true"`
	InputKubeEvents           *tfTypes.InputKubeEvents           `queryParam:"inline" tfsdk:"input_kube_events" tfPlanOnly:"true"`
	InputKubeLogs             *tfTypes.InputKubeLogs             `queryParam:"inline" tfsdk:"input_kube_logs" tfPlanOnly:"true"`
	InputKubeMetrics          *tfTypes.InputKubeMetrics          `queryParam:"inline" tfsdk:"input_kube_metrics" tfPlanOnly:"true"`
	InputLoki                 *tfTypes.InputLoki                 `queryParam:"inline" tfsdk:"input_loki" tfPlanOnly:"true"`
	InputMetrics              *tfTypes.InputMetrics              `queryParam:"inline" tfsdk:"input_metrics" tfPlanOnly:"true"`
	InputModelDrivenTelemetry *tfTypes.InputModelDrivenTelemetry `queryParam:"inline" tfsdk:"input_model_driven_telemetry" tfPlanOnly:"true"`
	InputMsk                  *tfTypes.InputMsk                  `queryParam:"inline" tfsdk:"input_msk" tfPlanOnly:"true"`
	InputNetflow              *tfTypes.InputNetflow              `queryParam:"inline" tfsdk:"input_netflow" tfPlanOnly:"true"`
	InputOffice365Mgmt        *tfTypes.InputOffice365Mgmt        `queryParam:"inline" tfsdk:"input_office365_mgmt" tfPlanOnly:"true"`
	InputOffice365MsgTrace    *tfTypes.InputOffice365MsgTrace    `queryParam:"inline" tfsdk:"input_office365_msg_trace" tfPlanOnly:"true"`
	InputOffice365Service     *tfTypes.InputOffice365Service     `queryParam:"inline" tfsdk:"input_office365_service" tfPlanOnly:"true"`
	InputOpenTelemetry        *tfTypes.InputOpenTelemetry        `queryParam:"inline" tfsdk:"input_open_telemetry" tfPlanOnly:"true"`
	InputPrometheus           *tfTypes.InputPrometheus           `queryParam:"inline" tfsdk:"input_prometheus" tfPlanOnly:"true"`
	InputPrometheusRw         *tfTypes.InputPrometheusRw         `queryParam:"inline" tfsdk:"input_prometheus_rw" tfPlanOnly:"true"`
	InputRawUDP               *tfTypes.InputRawUDP               `queryParam:"inline" tfsdk:"input_raw_udp" tfPlanOnly:"true"`
	InputS3                   *tfTypes.InputS3                   `queryParam:"inline" tfsdk:"input_s3" tfPlanOnly:"true"`
	InputS3Inventory          *tfTypes.InputS3Inventory          `queryParam:"inline" tfsdk:"input_s3_inventory" tfPlanOnly:"true"`
	InputSecurityLake         *tfTypes.InputSecurityLake         `queryParam:"inline" tfsdk:"input_security_lake" tfPlanOnly:"true"`
	InputSnmp                 *tfTypes.InputSnmp                 `queryParam:"inline" tfsdk:"input_snmp" tfPlanOnly:"true"`
	InputSplunk               *tfTypes.InputSplunk               `queryParam:"inline" tfsdk:"input_splunk" tfPlanOnly:"true"`
	InputSplunkHec            *tfTypes.InputSplunkHec            `queryParam:"inline" tfsdk:"input_splunk_hec" tfPlanOnly:"true"`
	InputSplunkSearch         *tfTypes.InputSplunkSearch         `queryParam:"inline" tfsdk:"input_splunk_search" tfPlanOnly:"true"`
	InputSqs                  *tfTypes.InputSqs                  `queryParam:"inline" tfsdk:"input_sqs" tfPlanOnly:"true"`
	InputSyslog               *tfTypes.InputSyslog               `queryParam:"inline" tfsdk:"input_syslog" tfPlanOnly:"true"`
	InputSystemMetrics        *tfTypes.InputSystemMetrics        `queryParam:"inline" tfsdk:"input_system_metrics" tfPlanOnly:"true"`
	InputSystemState          *tfTypes.InputSystemState          `queryParam:"inline" tfsdk:"input_system_state" tfPlanOnly:"true"`
	InputTCP                  *tfTypes.InputTCP                  `queryParam:"inline" tfsdk:"input_tcp" tfPlanOnly:"true"`
	InputTcpjson              *tfTypes.InputTcpjson              `queryParam:"inline" tfsdk:"input_tcpjson" tfPlanOnly:"true"`
	InputWef                  *tfTypes.InputWef                  `queryParam:"inline" tfsdk:"input_wef" tfPlanOnly:"true"`
	InputWindowsMetrics       *tfTypes.InputWindowsMetrics       `queryParam:"inline" tfsdk:"input_windows_metrics" tfPlanOnly:"true"`
	InputWinEventLogs         *tfTypes.InputWinEventLogs         `queryParam:"inline" tfsdk:"input_win_event_logs" tfPlanOnly:"true"`
	InputWiz                  *tfTypes.InputWiz                  `queryParam:"inline" tfsdk:"input_wiz" tfPlanOnly:"true"`
	InputZscalerHec           *tfTypes.InputZscalerHec           `queryParam:"inline" tfsdk:"input_zscaler_hec" tfPlanOnly:"true"`
	Items                     []tfTypes.Routes1                  `tfsdk:"items"`
	Pack                      types.String                       `tfsdk:"pack"`
}

func (r *PackSourceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_pack_source"
}

func (r *PackSourceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "PackSource Resource",
		Attributes: map[string]schema.Attribute{
			"group_id": schema.StringAttribute{
				Required:    true,
				Description: `group Id`,
			},
			"id": schema.StringAttribute{
				Required:    true,
				Description: `Unique ID to create pack source`,
			},
			"input_appscope": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_token": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(``),
						Description: `Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false`,
					},
					"enable_unix_path": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"filter": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"allow": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"arg": schema.StringAttribute{
											Optional:    true,
											Description: `Specify a string to substring-match against process command-line.`,
										},
										"config": schema.StringAttribute{
											Required:    true,
											Description: `Choose a config to apply to processes that match the process name and/or argument.`,
										},
										"procname": schema.StringAttribute{
											Required:    true,
											Description: `Specify the name of a process or family of processes.`,
										},
									},
								},
								Description: `Specify processes that AppScope should be loaded into, and the config to use.`,
							},
							"transport_url": schema.StringAttribute{
								Optional:    true,
								Description: `To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.`,
							},
						},
					},
					"host": schema.StringAttribute{
						Optional:    true,
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses).`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"ip_whitelist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching IP addresses that are allowed to establish a connection. Default: "/.*/"`,
					},
					"max_active_cxn": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"persistence": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`gzip`),
								Description: `Default: "gzip"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"dest_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/appscope`),
								Description: `Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope. Default: "$CRIBL_HOME/state/appscope"`,
							},
							"enable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Spool events and metrics on disk for Cribl Edge and Search. Default: false`,
							},
							"max_data_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1GB`),
								Description: `Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_data_time": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`24h`),
								Description: `Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
								},
							},
							"time_window": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`10m`),
								Description: `Time span for each file bucket. Default: "10m"`,
							},
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Optional:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_ending_max_wait": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30`,
					},
					"socket_idle_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0`,
					},
					"socket_max_lifespan": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "appscope"`,
						Validators: []validator.String{
							stringvalidator.OneOf("appscope"),
						},
					},
					"unix_socket_path": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`$CRIBL_HOME/state/appscope.sock`),
						Description: `Path to the UNIX domain socket to listen on. Default: "$CRIBL_HOME/state/appscope.sock"`,
					},
					"unix_socket_perms": schema.StringAttribute{
						Optional:    true,
						Description: `Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_azure_blob": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Default: "manual"; must be one of ["manual", "secret", "clientSecret", "clientCert"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
								"clientSecret",
								"clientCert",
							),
						},
					},
					"azure_cloud": schema.StringAttribute{
						Optional:    true,
						Description: `The Azure cloud to use. Defaults to Azure Public Cloud.`,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"certificate": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"certificate_name": schema.StringAttribute{
								Required:    true,
								Description: `The certificate you registered as credentials for your app in the Azure portal`,
							},
						},
					},
					"client_id": schema.StringAttribute{
						Optional:    true,
						Description: `The service principal's client ID`,
					},
					"client_text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"connection_string": schema.StringAttribute{
						Optional:    true,
						Description: `Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"endpoint_suffix": schema.StringAttribute{
						Optional:    true,
						Description: `Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"file_filter": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching file names to download and process. Defaults to: .*. Default: "/.*/"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_messages": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 32),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"num_receivers": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"parquet_chunk_download_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 3600),
						},
					},
					"parquet_chunk_size_mb": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `Maximum file size for each Parquet chunk. Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"queue_name": schema.StringAttribute{
						Required:    true,
						Description: `The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: ` + "`" + `myQueue-${C.vars.myVar}` + "`" + ``,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"service_period_secs": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `The duration (in seconds) which pollers should be validated and restarted if exited. Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10),
						},
					},
					"skip_on_error": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"storage_account_name": schema.StringAttribute{
						Optional:    true,
						Description: `The name of your Azure storage account`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tenant_id": schema.StringAttribute{
						Optional:    true,
						Description: `The service principal's tenant ID`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "azure_blob"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"azure_blob",
							),
						},
					},
					"visibility_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request. Default: 600`,
						Validators: []validator.Float64{
							float64validator.AtMost(604800),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_collection": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"output": schema.StringAttribute{
						Optional:    true,
						Description: `Destination to send results to`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process results`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"preprocess": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `Arguments to be added to the custom command`,
							},
							"command": schema.StringAttribute{
								Optional:    true,
								Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"throttle_rate_per_sec": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0`),
						Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`collection`),
						Description: `Default: "collection"; must be "collection"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"collection",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_confluent_cloud": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"authentication_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_interval": schema.Float64Attribute{
						Optional:    true,
						Description: `How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_threshold": schema.Float64Attribute{
						Optional:    true,
						Description: `How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000),
						},
					},
					"backoff_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(2),
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2`,
						Validators: []validator.Float64{
							float64validator.Between(2, 20),
						},
					},
					"brokers": schema.ListAttribute{
						Required:    true,
						ElementType: types.StringType,
						Description: `List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"connection_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"from_beginning": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true`,
					},
					"group_id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`Cribl`),
						Description: `The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"`,
					},
					"heartbeat_interval": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(3000),
						MarkdownDescription: `Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.` + "\n" +
							`      Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.` + "\n" +
							`Default: 3000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"initial_backoff": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(300, 600000),
						},
					},
					"kafka_schema_registry": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"auth": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"credentials_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a secret that references your credentials`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Credentials to use when authenticating with the schema registry using basic HTTP authentication`,
							},
							"connection_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30000),
								Description: `Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000`,
								Validators: []validator.Float64{
									float64validator.Between(1000, 60000),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_retries": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `Maximum number of times to try fetching schemas from the Schema Registry. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtMost(100),
								},
							},
							"request_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30000),
								Description: `Maximum time to wait for the Schema Registry to respond to a request. Default: 30000`,
								Validators: []validator.Float64{
									float64validator.Between(1000, 60000),
								},
							},
							"schema_registry_url": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`http://localhost:8081`),
								Description: `URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"`,
							},
							"tls": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.`,
									},
									"cert_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"certificate_name": schema.StringAttribute{
										Optional:    true,
										Description: `The name of the predefined certificate`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
									"max_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Optional:    true,
										Description: `Passphrase to use to decrypt private key`,
									},
									"priv_key_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.`,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										MarkdownDescription: `Reject certificates that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
											`                    trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
											`Default: true`,
									},
									"servername": schema.StringAttribute{
										Optional:    true,
										Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.`,
									},
								},
							},
						},
					},
					"max_back_off": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30000),
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(30000, 180000),
						},
					},
					"max_bytes": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10485760),
						Description: `Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760`,
						Validators: []validator.Float64{
							float64validator.Between(1, 1000000000),
						},
					},
					"max_bytes_per_partition": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1048576),
						Description: `Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000000),
						},
					},
					"max_retries": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"max_socket_errors": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `Maximum number of network errors before the consumer re-creates a socket. Default: 0`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"reauthentication_threshold": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 1800000),
						},
					},
					"rebalance_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(60000),
						MarkdownDescription: `Maximum allowed time for each worker to join the group after a rebalance begins.` + "\n" +
							`      If the timeout is exceeded, the coordinator broker will remove the worker from the group.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.` + "\n" +
							`Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(60000),
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"sasl": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"mechanism": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`plain`),
								Description: `Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"plain",
										"scram-sha-256",
										"scram-sha-512",
										"kerberos",
									),
								},
							},
						},
						Description: `Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"session_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(30000),
						MarkdownDescription: `Timeout used to detect client failures when using Kafka's group-management facilities.` + "\n" +
							`      If the client sends no heartbeats to the broker before the timeout expires, ` + "\n" +
							`      the broker will remove the client from the group and initiate a rebalance.` + "\n" +
							`      Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.` + "\n" +
							`Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								MarkdownDescription: `Reject certificates that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true`,
							},
							"servername": schema.StringAttribute{
								Optional:    true,
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.`,
							},
						},
					},
					"topics": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "confluent_cloud"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"confluent_cloud",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_cribl": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"filter": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "cribl"`,
						Validators: []validator.String{
							stringvalidator.OneOf("cribl"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_cribl_http": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"auth_tokens": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "cribl_http"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"cribl_http",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_cribl_lake_http": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"auth_tokens": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "cribl_lake_http"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"cribl_lake_http",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_criblmetrics": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"full_fidelity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Include granular metrics. Disabling this will drop the following metrics events: ` + "`" + `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)` + "`" + `, ` + "`" + `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)` + "`" + `, ` + "`" + `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)` + "`" + `, ` + "`" + `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)` + "`" + `. Default: true`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"prefix": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`cribl.logstream.`),
						Description: `A prefix that is applied to the metrics provided by Cribl Stream. Default: "cribl.logstream."`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "criblmetrics"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"criblmetrics",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_cribl_tcp": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_load_balancing": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Load balance traffic across all Worker Processes. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_active_cxn": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_ending_max_wait": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30`,
					},
					"socket_idle_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0`,
					},
					"socket_max_lifespan": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "cribl_tcp"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"cribl_tcp",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_crowdstrike": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"aws_account_id": schema.StringAttribute{
						Optional:    true,
						Description: `SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.`,
					},
					"aws_api_key": schema.StringAttribute{
						Optional: true,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored secret that references your access key and secret key`,
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"checkpointing": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume processing files after an interruption. Default: false`,
							},
							"retries": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(100),
								},
							},
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Use Assume Role credentials to access Amazon S3. Default: true`,
					},
					"enable_sqs_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials when accessing Amazon SQS. Default: false`,
					},
					"encoding": schema.StringAttribute{
						Optional:    true,
						Description: `Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"file_filter": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching file names to download and process. Defaults to: .*. Default: "/.*/"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_messages": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"num_receivers": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"poll_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10`,
						Validators: []validator.Float64{
							float64validator.Between(1, 20),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"preprocess": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `Arguments to be added to the custom command`,
							},
							"command": schema.StringAttribute{
								Optional:    true,
								Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
						},
					},
					"processed_tag_key": schema.StringAttribute{
						Optional:    true,
						Description: `The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"processed_tag_value": schema.StringAttribute{
						Optional:    true,
						Description: `The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"queue_name": schema.StringAttribute{
						Required:    true,
						Description: `The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `.`,
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"skip_on_error": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(1, 43200),
						},
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tag_after_processing": schema.StringAttribute{
						Optional:    true,
						Description: `must be one of ["false", "true"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"false",
								"true",
							),
						},
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "crowdstrike"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"crowdstrike",
							),
						},
					},
					"visibility_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(21600),
						Description: `After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 21600`,
						Validators: []validator.Float64{
							float64validator.AtMost(43200),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_datadog_agent": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"extract_metrics": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default). Default: false`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"proxy_mode": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid. Default: false`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates). Default: true`,
							},
						},
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "datadog_agent"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"datadog_agent",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_datagen": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"samples": schema.ListNestedAttribute{
						Required: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"events_per_sec": schema.Float64Attribute{
									Computed:    true,
									Optional:    true,
									Default:     float64default.StaticFloat64(10),
									Description: `Maximum number of events to generate per second per Worker Node. Defaults to 10. Default: 10`,
									Validators: []validator.Float64{
										float64validator.AtLeast(1),
									},
								},
								"sample": schema.StringAttribute{
									Required: true,
								},
							},
						},
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "datagen"`,
						Validators: []validator.String{
							stringvalidator.OneOf("datagen"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_edge_prometheus": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "kubernetes"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
								"kubernetes",
							),
						},
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"dimension_list": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Other dimensions to include in events`,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"discovery_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`static`),
						Description: `Target discovery mechanism. Use static to manually enter a list of targets. Default: "static"; must be one of ["static", "dns", "ec2", "k8s-node", "k8s-pods"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"static",
								"dns",
								"ec2",
								"k8s-node",
								"k8s-pods",
							),
						},
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials to access EC2. Default: false`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(15),
						Description: `How often in seconds to scrape targets for metrics. Default: 15`,
						Validators: []validator.Float64{
							float64validator.AtLeast(2),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"name_list": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `List of DNS names to resolve`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"password": schema.StringAttribute{
						Optional:    true,
						Description: `Password for Prometheus Basic authentication`,
					},
					"persistence": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`gzip`),
								Description: `Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"enable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Spool events on disk for Cribl Edge and Search. Default is disabled. Default: false`,
							},
							"max_data_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1GB`),
								Description: `Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+(\.\d+)?\s*(?:[kmgKMG](b|B))?$`), "must match pattern "+regexp.MustCompile(`^\d+(\.\d+)?\s*(?:[kmgKMG](b|B))?$`).String()),
								},
							},
							"max_data_time": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`24h`),
								Description: `Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
								},
							},
							"time_window": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`10m`),
								Description: `Time period for grouping spooled events. Default is 10m. Default: "10m"`,
							},
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pod_filter": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `Optional description of this rule's purpose`,
								},
								"filter": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression applied to pods objects. Return 'true' to include it.`,
								},
							},
						},
						MarkdownDescription: `Add rules to decide which pods to discover for metrics.` + "\n" +
							`  Pods are searched if no rules are given or of all the rules'` + "\n" +
							`  expressions evaluate to true.`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"record_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`SRV`),
						Description: `DNS Record type to resolve. Default: "SRV"; must be one of ["SRV", "A", "AAAA"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SRV",
								"A",
								"AAAA",
							),
						},
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `Region where the EC2 is located`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"scrape_path": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/metrics`),
						Description: `Path to use when collecting metrics from discovered targets. Default: "/metrics"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/.*`), "must match pattern "+regexp.MustCompile(`^/.*`).String()),
						},
					},
					"scrape_path_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`metadata.annotations['prometheus.io/path'] || '/metrics'`),
						Description: `Path to use when collecting metrics from discovered targets. Default: "metadata.annotations['prometheus.io/path'] || '/metrics'"`,
					},
					"scrape_port": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(9090),
						Description: `The port number in the metrics URL for discovered targets. Default: 9090`,
						Validators: []validator.Float64{
							float64validator.Between(1, 65535),
						},
					},
					"scrape_port_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`metadata.annotations['prometheus.io/port'] || 9090`),
						Description: `The port number in the metrics URL for discovered targets. Default: "metadata.annotations['prometheus.io/port'] || 9090"`,
					},
					"scrape_protocol": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`http`),
						Description: `Protocol to use when collecting metrics. Default: "http"; must be one of ["http", "https"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"http",
								"https",
							),
						},
					},
					"scrape_protocol_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`metadata.annotations['prometheus.io/scheme'] || 'http'`),
						Description: `Protocol to use when collecting metrics. Default: "metadata.annotations['prometheus.io/scheme'] || 'http'"`,
					},
					"search_filter": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list`,
								},
								"values": schema.ListAttribute{
									Computed:    true,
									Optional:    true,
									Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
									ElementType: types.StringType,
									Description: `Search Filter Values, if empty only "running" EC2 instances will be returned`,
								},
							},
						},
						Description: `EC2 Instance Search Filter`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing EC2 requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"targets": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:    true,
									Description: `Name of host from which to pull metrics.`,
								},
								"path": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Default:     stringdefault.StaticString(`/metrics`),
									Description: `Path to use when collecting metrics from discovered targets. Default: "/metrics"`,
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile(`^/.*`), "must match pattern "+regexp.MustCompile(`^/.*`).String()),
									},
								},
								"port": schema.Float64Attribute{
									Computed:    true,
									Optional:    true,
									Default:     float64default.StaticFloat64(9090),
									Description: `The port number in the metrics URL for discovered targets. Default: 9090`,
									Validators: []validator.Float64{
										float64validator.Between(1, 65535),
									},
								},
								"protocol": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Default:     stringdefault.StaticString(`http`),
									Description: `Protocol to use when collecting metrics. Default: "http"; must be one of ["http", "https"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"http",
											"https",
										),
									},
								},
							},
						},
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5000),
						Description: `Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable. Default: 5000`,
						Validators: []validator.Float64{
							float64validator.AtMost(60000),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "edge_prometheus"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"edge_prometheus",
							),
						},
					},
					"use_public_ip": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Use public IP address for discovered targets. Set to false if the private IP address should be used. Default: true`,
					},
					"username": schema.StringAttribute{
						Optional:    true,
						Description: `Username for Prometheus Basic authentication`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_elastic": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"api_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`8.3.2`),
						Description: `The API version to use for communicating with the server. Default: "8.3.2"; must be one of ["6.8.4", "8.3.2", "custom"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"6.8.4",
								"8.3.2",
								"custom",
							),
						},
					},
					"auth_tokens": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Bearer tokens to include in the authorization header`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`none`),
						Description: `Default: "none"; must be one of ["none", "basic", "credentialsSecret", "authTokens"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"authTokens",
							),
						},
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials`,
					},
					"custom_api_version": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default: stringdefault.StaticString(`{` + "\n" +
							`    "name": "AzU84iL",` + "\n" +
							`    "cluster_name": "cribl",` + "\n" +
							`    "cluster_uuid": "Js6_Z2VKS3KbfRSxPmPbaw",` + "\n" +
							`    "version": {` + "\n" +
							`        "number": "8.3.2",` + "\n" +
							`        "build_type": "tar",` + "\n" +
							`        "build_hash": "bca0c8d",` + "\n" +
							`        "build_date": "2019-10-16T06:19:49.319352Z",` + "\n" +
							`        "build_snapshot": false,` + "\n" +
							`        "lucene_version": "9.7.2",` + "\n" +
							`        "minimum_wire_compatibility_version": "7.17.0",` + "\n" +
							`        "minimum_index_compatibility_version": "7.0.0"` + "\n" +
							`    },` + "\n" +
							`    "tagline": "You Know, for Search"` + "\n" +
							`}`),
						Description: `Custom version information to respond to requests. Default: "{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}"`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"elastic_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/`),
						Description: `Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success. Default: "/"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
						},
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"extra_http_headers": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional: true,
								},
								"value": schema.StringAttribute{
									Required: true,
								},
							},
						},
						Description: `Headers to add to all events`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"proxy_mode": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"auth_type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Enter credentials directly, or select a stored secret. Default: "none"; must be one of ["none", "manual", "secret"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"manual",
										"secret",
									),
								},
							},
							"enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details. Default: false`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Reject certificates that cannot be verified against a valid CA (such as self-signed certificates). Default: false`,
							},
							"remove_headers": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `List of headers to remove from the request to proxy`,
							},
							"timeout_sec": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(60),
								Description: `Amount of time, in seconds, to wait for a proxy request to complete before canceling it. Default: 60`,
								Validators: []validator.Float64{
									float64validator.Between(1, 9007199254740991),
								},
							},
							"url": schema.StringAttribute{
								Optional:    true,
								Description: `URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200`,
							},
						},
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "elastic"`,
						Validators: []validator.String{
							stringvalidator.OneOf("elastic"),
						},
					},
					"username": schema.StringAttribute{
						Optional: true,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_eventhub": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"authentication_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_interval": schema.Float64Attribute{
						Optional:    true,
						Description: `How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_threshold": schema.Float64Attribute{
						Optional:    true,
						Description: `How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000),
						},
					},
					"backoff_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(2),
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2`,
						Validators: []validator.Float64{
							float64validator.Between(2, 20),
						},
					},
					"brokers": schema.ListAttribute{
						Required:    true,
						ElementType: types.StringType,
						Description: `List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"connection_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"from_beginning": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Start reading from earliest available data; relevant only during initial subscription. Default: true`,
					},
					"group_id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`Cribl`),
						Description: `The consumer group this instance belongs to. Default is 'Cribl'. Default: "Cribl"`,
					},
					"heartbeat_interval": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(3000),
						MarkdownDescription: `Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.` + "\n" +
							`      Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.` + "\n" +
							`      See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).` + "\n" +
							`Default: 3000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"initial_backoff": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(300, 600000),
						},
					},
					"max_back_off": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30000),
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(30000, 180000),
						},
					},
					"max_bytes": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10485760),
						Description: `Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760`,
						Validators: []validator.Float64{
							float64validator.Between(1, 1000000000),
						},
					},
					"max_bytes_per_partition": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1048576),
						Description: `Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000000),
						},
					},
					"max_retries": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"max_socket_errors": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `Maximum number of network errors before the consumer re-creates a socket. Default: 0`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"minimize_duplicates": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Minimize duplicate events by starting only one consumer for each topic partition. Default: false`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"reauthentication_threshold": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 1800000),
						},
					},
					"rebalance_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(60000),
						MarkdownDescription: `Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.` + "\n" +
							`      If the timeout is exceeded, the coordinator broker will remove the worker from the group.` + "\n" +
							`      See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).` + "\n" +
							`Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(60000),
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"sasl": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"mechanism": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`plain`),
								Description: `Default: "plain"; must be one of ["plain", "oauthbearer"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"plain",
										"oauthbearer",
									),
								},
							},
						},
						Description: `Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"session_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(30000),
						MarkdownDescription: `Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.` + "\n" +
							`      If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.` + "\n" +
							`      Value must be lower than rebalanceTimeout.` + "\n" +
							`      See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).` + "\n" +
							`Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(6000, 300000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's). Default: true`,
							},
						},
					},
					"topics": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "eventhub"`,
						Validators: []validator.String{
							stringvalidator.OneOf("eventhub"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_exec": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"command": schema.StringAttribute{
						Required:    true,
						Description: `Command to execute; supports Bourne shell (or CMD on Windows) syntax`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"cron_schedule": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`* * * * *`),
						Description: `Cron schedule to execute the command on. Default: "* * * * *"`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(60),
						Description: `Interval between command executions in seconds. Default: 60`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"retries": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `Maximum number of retry attempts in the event that the command fails. Default: 10`,
					},
					"schedule_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`interval`),
						Description: `Select a schedule type; either an interval (in seconds) or a cron-style schedule. Default: "interval"; must be one of ["interval", "cronSchedule"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"interval",
								"cronSchedule",
							),
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "exec"`,
						Validators: []validator.String{
							stringvalidator.OneOf("exec"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_file": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"check_file_mod_time": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Skip files with modification times earlier than the maximum age duration. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"delete_files": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Delete files after they have been collected. Default: false`,
					},
					"depth": schema.Float64Attribute{
						Optional:    true,
						Description: `Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"filenames": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `The full path of discovered files are matched against this wildcard list`,
					},
					"force_text": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Forces files containing binary data to be streamed as text. Default: false`,
					},
					"hash_len": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Length of file header bytes to use in hash for unique file identification. Default: 256`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"idle_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Time, in seconds, before an idle file is closed. Default: 300`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"include_unidentifiable_binary": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Stream binary files as Base64-encoded chunks. Default: false`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `Time, in seconds, between scanning for files. Default: 10`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"max_age_dur": schema.StringAttribute{
						Optional:    true,
						Description: `The maximum age of files to monitor. Format examples: 60s, 4h, 3d, 1w. Age is relative to file modification time. Leave empty to apply no age filters.`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"mode": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `Choose how to discover files to monitor. Default: "auto"; must be one of ["auto", "manual"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
							),
						},
					},
					"path": schema.StringAttribute{
						Optional:    true,
						Description: `Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"suppress_missing_path_errors": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"tail_only": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head. Default: false`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "file"`,
						Validators: []validator.String{
							stringvalidator.OneOf("file"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_firehose": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"auth_tokens": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "firehose"`,
						Validators: []validator.String{
							stringvalidator.OneOf("firehose"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_google_pubsub": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"concurrency": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5. Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"create_subscription": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Create subscription if it does not exist. Default: true`,
					},
					"create_topic": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Create topic if it does not exist. Default: false`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"google_auth_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_backlog": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events. Default: 1000`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"ordered_delivery": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Receive events in the order they were added to the queue. The process sending events must have ordering enabled. Default: false`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(60000),
						Description: `Pull request timeout, in milliseconds. Default: 60000`,
						Validators: []validator.Float64{
							float64validator.AtLeast(10000),
						},
					},
					"secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"service_account_credentials": schema.StringAttribute{
						Optional:    true,
						Description: `Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"subscription_name": schema.StringAttribute{
						Required:    true,
						Description: `ID of the subscription to use when receiving events`,
					},
					"topic_name": schema.StringAttribute{
						Required:    true,
						Description: `ID of the topic to receive events from`,
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "google_pubsub"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"google_pubsub",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_grafana": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"input_grafana_grafana1": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"activity_log_sample_rate": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(100),
								Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"capture_headers": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Add request headers to events, in the __headers field. Default: false`,
							},
							"connections": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"output": schema.StringAttribute{
											Required: true,
										},
										"pipeline": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
							},
							"description": schema.StringAttribute{
								Optional: true,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"enable_health_check": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
							},
							"enable_proxy_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
							},
							"environment": schema.StringAttribute{
								Optional:    true,
								Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
							},
							"host": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0.0.0.0`),
								Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
							},
							"id": schema.StringAttribute{
								Optional:    true,
								Description: `Unique ID for this input`,
							},
							"ip_allowlist_regex": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/.*/`),
								Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
							},
							"ip_denylist_regex": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/^$/`),
								Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
							},
							"keep_alive_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes. Default: 5`,
								Validators: []validator.Float64{
									float64validator.Between(1, 600),
								},
							},
							"loki_api": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/loki/api/v1/push`),
								Description: `Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured. Default: "/loki/api/v1/push"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
								},
							},
							"loki_auth": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"auth_header_expr": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
										Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
									},
									"auth_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Loki logs authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"credentialsSecret",
												"token",
												"textSecret",
												"oauth",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a secret that references your credentials`,
									},
									"login_url": schema.StringAttribute{
										Optional:    true,
										Description: `URL for OAuth`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
										},
									},
									"oauth_headers": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header value`,
												},
											},
										},
										Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"oauth_params": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter value`,
												},
											},
										},
										Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"password": schema.StringAttribute{
										Optional: true,
									},
									"secret": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter value to pass in request body`,
									},
									"secret_param_name": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter name to pass in request body`,
									},
									"text_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a stored text secret`,
									},
									"token": schema.StringAttribute{
										Optional:    true,
										Description: `Bearer token to include in the authorization header`,
									},
									"token_attribute_name": schema.StringAttribute{
										Optional:    true,
										Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
									},
									"token_timeout_secs": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(3600),
										Description: `How often the OAuth token should be refreshed. Default: 3600`,
										Validators: []validator.Float64{
											float64validator.Between(1, 300000),
										},
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"max_active_req": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(256),
								Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
							},
							"max_requests_per_socket": schema.Int64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     int64default.StaticInt64(0),
								Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process data from this Source before sending it through the Routes`,
							},
							"port": schema.Float64Attribute{
								Required:    true,
								Description: `Port to listen on`,
								Validators: []validator.Float64{
									float64validator.AtMost(65535),
								},
							},
							"pq": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"commit_frequency": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(42),
										Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"compress": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"gzip",
											),
										},
									},
									"max_buffer_size": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1000),
										Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
										Validators: []validator.Float64{
											float64validator.AtLeast(42),
										},
									},
									"max_file_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1 MB`),
										Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"max_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`5GB`),
										Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`always`),
										Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"smart",
												"always",
											),
										},
									},
									"path": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
										Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
									},
								},
							},
							"pq_enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
							},
							"prometheus_api": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/api/prom/push`),
								Description: `Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<your‑upstream‑URL>:<your‑port>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured. Default: "/api/prom/push"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
								},
							},
							"prometheus_auth": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"auth_header_expr": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
										Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
									},
									"auth_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"credentialsSecret",
												"token",
												"textSecret",
												"oauth",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a secret that references your credentials`,
									},
									"login_url": schema.StringAttribute{
										Optional:    true,
										Description: `URL for OAuth`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
										},
									},
									"oauth_headers": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header value`,
												},
											},
										},
										Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"oauth_params": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter value`,
												},
											},
										},
										Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"password": schema.StringAttribute{
										Optional: true,
									},
									"secret": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter value to pass in request body`,
									},
									"secret_param_name": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter name to pass in request body`,
									},
									"text_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a stored text secret`,
									},
									"token": schema.StringAttribute{
										Optional:    true,
										Description: `Bearer token to include in the authorization header`,
									},
									"token_attribute_name": schema.StringAttribute{
										Optional:    true,
										Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
									},
									"token_timeout_secs": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(3600),
										Description: `How often the OAuth token should be refreshed. Default: 3600`,
										Validators: []validator.Float64{
											float64validator.Between(1, 300000),
										},
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"request_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
							},
							"socket_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
							},
							"streamtags": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								ElementType: types.StringType,
								Description: `Tags for filtering and grouping in @{product}`,
							},
							"tls": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"cert_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"certificate_name": schema.StringAttribute{
										Optional:    true,
										Description: `The name of the predefined certificate`,
									},
									"common_name_regex": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
									"max_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Optional:    true,
										Description: `Passphrase to use to decrypt private key`,
									},
									"priv_key_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
									},
									"reject_unauthorized": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"request_cert": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(false),
										Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
									},
								},
							},
							"type": schema.StringAttribute{
								Optional:    true,
								Description: `must be "grafana"`,
								Validators: []validator.String{
									stringvalidator.OneOf("grafana"),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("input_grafana_grafana2"),
							}...),
						},
					},
					"input_grafana_grafana2": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"activity_log_sample_rate": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(100),
								Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"capture_headers": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Add request headers to events, in the __headers field. Default: false`,
							},
							"connections": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"output": schema.StringAttribute{
											Required: true,
										},
										"pipeline": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
							},
							"description": schema.StringAttribute{
								Optional: true,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"enable_health_check": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
							},
							"enable_proxy_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
							},
							"environment": schema.StringAttribute{
								Optional:    true,
								Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
							},
							"host": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0.0.0.0`),
								Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
							},
							"id": schema.StringAttribute{
								Optional:    true,
								Description: `Unique ID for this input`,
							},
							"ip_allowlist_regex": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/.*/`),
								Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
							},
							"ip_denylist_regex": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/^$/`),
								Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
							},
							"keep_alive_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes. Default: 5`,
								Validators: []validator.Float64{
									float64validator.Between(1, 600),
								},
							},
							"loki_api": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/loki/api/v1/push`),
								Description: `Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured. Default: "/loki/api/v1/push"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
								},
							},
							"loki_auth": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"auth_header_expr": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
										Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
									},
									"auth_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Loki logs authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"credentialsSecret",
												"token",
												"textSecret",
												"oauth",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a secret that references your credentials`,
									},
									"login_url": schema.StringAttribute{
										Optional:    true,
										Description: `URL for OAuth`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
										},
									},
									"oauth_headers": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header value`,
												},
											},
										},
										Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"oauth_params": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter value`,
												},
											},
										},
										Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"password": schema.StringAttribute{
										Optional: true,
									},
									"secret": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter value to pass in request body`,
									},
									"secret_param_name": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter name to pass in request body`,
									},
									"text_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a stored text secret`,
									},
									"token": schema.StringAttribute{
										Optional:    true,
										Description: `Bearer token to include in the authorization header`,
									},
									"token_attribute_name": schema.StringAttribute{
										Optional:    true,
										Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
									},
									"token_timeout_secs": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(3600),
										Description: `How often the OAuth token should be refreshed. Default: 3600`,
										Validators: []validator.Float64{
											float64validator.Between(1, 300000),
										},
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"max_active_req": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(256),
								Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
							},
							"max_requests_per_socket": schema.Int64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     int64default.StaticInt64(0),
								Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process data from this Source before sending it through the Routes`,
							},
							"port": schema.Float64Attribute{
								Required:    true,
								Description: `Port to listen on`,
								Validators: []validator.Float64{
									float64validator.AtMost(65535),
								},
							},
							"pq": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"commit_frequency": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(42),
										Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"compress": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"gzip",
											),
										},
									},
									"max_buffer_size": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1000),
										Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
										Validators: []validator.Float64{
											float64validator.AtLeast(42),
										},
									},
									"max_file_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1 MB`),
										Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"max_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`5GB`),
										Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`always`),
										Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"smart",
												"always",
											),
										},
									},
									"path": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
										Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
									},
								},
							},
							"pq_enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
							},
							"prometheus_api": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/api/prom/push`),
								Description: `Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<your‑upstream‑URL>:<your‑port>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured. Default: "/api/prom/push"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
								},
							},
							"prometheus_auth": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"auth_header_expr": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
										Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
									},
									"auth_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"credentialsSecret",
												"token",
												"textSecret",
												"oauth",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a secret that references your credentials`,
									},
									"login_url": schema.StringAttribute{
										Optional:    true,
										Description: `URL for OAuth`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
										},
									},
									"oauth_headers": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth header value`,
												},
											},
										},
										Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"oauth_params": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter name`,
												},
												"value": schema.StringAttribute{
													Required:    true,
													Description: `OAuth parameter value`,
												},
											},
										},
										Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
									},
									"password": schema.StringAttribute{
										Optional: true,
									},
									"secret": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter value to pass in request body`,
									},
									"secret_param_name": schema.StringAttribute{
										Optional:    true,
										Description: `Secret parameter name to pass in request body`,
									},
									"text_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a stored text secret`,
									},
									"token": schema.StringAttribute{
										Optional:    true,
										Description: `Bearer token to include in the authorization header`,
									},
									"token_attribute_name": schema.StringAttribute{
										Optional:    true,
										Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
									},
									"token_timeout_secs": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(3600),
										Description: `How often the OAuth token should be refreshed. Default: 3600`,
										Validators: []validator.Float64{
											float64validator.Between(1, 300000),
										},
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"request_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
							},
							"socket_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
							},
							"streamtags": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								ElementType: types.StringType,
								Description: `Tags for filtering and grouping in @{product}`,
							},
							"tls": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"cert_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"certificate_name": schema.StringAttribute{
										Optional:    true,
										Description: `The name of the predefined certificate`,
									},
									"common_name_regex": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
									"max_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Optional:    true,
										Description: `Passphrase to use to decrypt private key`,
									},
									"priv_key_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
									},
									"reject_unauthorized": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"request_cert": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(false),
										Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
									},
								},
							},
							"type": schema.StringAttribute{
								Optional:    true,
								Description: `must be "grafana"`,
								Validators: []validator.String{
									stringvalidator.OneOf("grafana"),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("input_grafana_grafana1"),
							}...),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_http": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"auth_tokens": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"auth_tokens_ext": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional: true,
								},
								"metadata": schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Required: true,
											},
											"value": schema.StringAttribute{
												Required:    true,
												Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
											},
										},
									},
									Description: `Fields to add to events referencing this token`,
								},
								"token": schema.StringAttribute{
									Required:    true,
									Description: `Shared secret to be provided by any client (Authorization: <token>)`,
								},
							},
						},
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"cribl_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/cribl`),
						Description: `Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable. Default: "/cribl"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/|^$`), "must match pattern "+regexp.MustCompile(`^/|^$`).String()),
						},
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"elastic_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/elastic`),
						Description: `Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable. Default: "/elastic"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/|^$`), "must match pattern "+regexp.MustCompile(`^/|^$`).String()),
						},
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"splunk_hec_acks": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"splunk_hec_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/services/collector`),
						Description: `Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable. Default: "/services/collector"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/|^$`), "must match pattern "+regexp.MustCompile(`^/|^$`).String()),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "http"`,
						Validators: []validator.String{
							stringvalidator.OneOf("http"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_http_raw": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"allowed_methods": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.`,
					},
					"allowed_paths": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.`,
					},
					"auth_tokens": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"auth_tokens_ext": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional: true,
								},
								"metadata": schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Required: true,
											},
											"value": schema.StringAttribute{
												Required:    true,
												Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
											},
										},
									},
									Description: `Fields to add to events referencing this token`,
								},
								"token": schema.StringAttribute{
									Required:    true,
									Description: `Shared secret to be provided by any client (Authorization: <token>)`,
								},
							},
						},
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "http_raw"`,
						Validators: []validator.String{
							stringvalidator.OneOf("http_raw"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_journal_files": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"current_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Skip log messages that are not part of the current boot session. Default: false`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `Time, in seconds, between scanning for journals. Default: 10`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"journals": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `The full path of discovered journals are matched against this wildcard list.`,
					},
					"max_age_dur": schema.StringAttribute{
						Optional:    true,
						Description: `The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"path": schema.StringAttribute{
						Required:    true,
						Description: `Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"rules": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `Optional description of this rule's purpose`,
								},
								"filter": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression applied to Journal objects. Return 'true' to include it.`,
								},
							},
						},
						Description: `Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "journal_files"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"journal_files",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_kafka": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"authentication_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_interval": schema.Float64Attribute{
						Optional:    true,
						Description: `How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_threshold": schema.Float64Attribute{
						Optional:    true,
						Description: `How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000),
						},
					},
					"backoff_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(2),
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2`,
						Validators: []validator.Float64{
							float64validator.Between(2, 20),
						},
					},
					"brokers": schema.ListAttribute{
						Required:    true,
						ElementType: types.StringType,
						Description: `Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"connection_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"from_beginning": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true`,
					},
					"group_id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`Cribl`),
						Description: `The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"`,
					},
					"heartbeat_interval": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(3000),
						MarkdownDescription: `Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.` + "\n" +
							`      Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.` + "\n" +
							`Default: 3000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"initial_backoff": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(300, 600000),
						},
					},
					"kafka_schema_registry": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"auth": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"credentials_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a secret that references your credentials`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Credentials to use when authenticating with the schema registry using basic HTTP authentication`,
							},
							"connection_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30000),
								Description: `Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000`,
								Validators: []validator.Float64{
									float64validator.Between(1000, 60000),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_retries": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `Maximum number of times to try fetching schemas from the Schema Registry. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtMost(100),
								},
							},
							"request_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30000),
								Description: `Maximum time to wait for the Schema Registry to respond to a request. Default: 30000`,
								Validators: []validator.Float64{
									float64validator.Between(1000, 60000),
								},
							},
							"schema_registry_url": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`http://localhost:8081`),
								Description: `URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"`,
							},
							"tls": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.`,
									},
									"cert_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"certificate_name": schema.StringAttribute{
										Optional:    true,
										Description: `The name of the predefined certificate`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
									"max_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Optional:    true,
										Description: `Passphrase to use to decrypt private key`,
									},
									"priv_key_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.`,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										MarkdownDescription: `Reject certificates that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
											`                    trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
											`Default: true`,
									},
									"servername": schema.StringAttribute{
										Optional:    true,
										Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.`,
									},
								},
							},
						},
					},
					"max_back_off": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30000),
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(30000, 180000),
						},
					},
					"max_bytes": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10485760),
						Description: `Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760`,
						Validators: []validator.Float64{
							float64validator.Between(1, 1000000000),
						},
					},
					"max_bytes_per_partition": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1048576),
						Description: `Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000000),
						},
					},
					"max_retries": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"max_socket_errors": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `Maximum number of network errors before the consumer re-creates a socket. Default: 0`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"reauthentication_threshold": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 1800000),
						},
					},
					"rebalance_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(60000),
						MarkdownDescription: `Maximum allowed time for each worker to join the group after a rebalance begins.` + "\n" +
							`      If the timeout is exceeded, the coordinator broker will remove the worker from the group.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.` + "\n" +
							`Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(60000),
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"sasl": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"mechanism": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`plain`),
								Description: `Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"plain",
										"scram-sha-256",
										"scram-sha-512",
										"kerberos",
									),
								},
							},
						},
						Description: `Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"session_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(30000),
						MarkdownDescription: `Timeout used to detect client failures when using Kafka's group-management facilities.` + "\n" +
							`      If the client sends no heartbeats to the broker before the timeout expires, ` + "\n" +
							`      the broker will remove the client from the group and initiate a rebalance.` + "\n" +
							`      Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.` + "\n" +
							`Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								MarkdownDescription: `Reject certificates that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true`,
							},
							"servername": schema.StringAttribute{
								Optional:    true,
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.`,
							},
						},
					},
					"topics": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "kafka"`,
						Validators: []validator.String{
							stringvalidator.OneOf("kafka"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_kinesis": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"avoid_duplicates": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart. Default: false`,
					},
					"aws_api_key": schema.StringAttribute{
						Optional: true,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored secret that references your access key and secret key`,
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials to access Kinesis stream. Default: false`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"get_records_limit": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5000),
						Description: `Maximum number of records per getRecords call. Default: 5000`,
						Validators: []validator.Float64{
							float64validator.Between(5000, 10000),
						},
					},
					"get_records_limit_total": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(20000),
						Description: `Maximum number of records, across all shards, to pull down at once per Worker Process. Default: 20000`,
						Validators: []validator.Float64{
							float64validator.AtLeast(20000),
						},
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"load_balancing_algorithm": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`ConsistentHashing`),
						Description: `The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes. Default: "ConsistentHashing"; must be one of ["ConsistentHashing", "RoundRobin"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ConsistentHashing",
								"RoundRobin",
							),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"payload_format": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`cribl`),
						Description: `Format of data inside the Kinesis Stream records. Gzip compression is automatically detected. Default: "cribl"; must be one of ["cribl", "ndjson", "cloudwatch", "line"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"cribl",
								"ndjson",
								"cloudwatch",
								"line",
							),
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"region": schema.StringAttribute{
						Required:    true,
						Description: `Region where the Kinesis stream is located`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"service_interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `Time interval in minutes between consecutive service calls. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 5),
						},
					},
					"shard_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`true`),
						Description: `A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed. Default: "true"`,
					},
					"shard_iterator_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`TRIM_HORIZON`),
						Description: `Location at which to start reading a shard for the first time. Default: "TRIM_HORIZON"; must be one of ["TRIM_HORIZON", "LATEST"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"TRIM_HORIZON",
								"LATEST",
							),
						},
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing Kinesis stream requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"stream_name": schema.StringAttribute{
						Required:    true,
						Description: `Kinesis Data Stream to read data from`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "kinesis"`,
						Validators: []validator.String{
							stringvalidator.OneOf("kinesis"),
						},
					},
					"verify_kpl_check_sums": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Verify Kinesis Producer Library (KPL) event checksums. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_kube_events": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"rules": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `Optional description of this rule's purpose`,
								},
								"filter": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression applied to Kubernetes objects. Return 'true' to include it.`,
								},
							},
						},
						Description: `Filtering on event fields`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "kube_events"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"kube_events",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_kube_logs": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_load_balancing": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Load balance traffic across all Worker Processes. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(15),
						Description: `Time, in seconds, between checks for new containers. Default is 15 secs. Default: 15`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"persistence": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`gzip`),
								Description: `Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"enable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Spool events on disk for Cribl Edge and Search. Default is disabled. Default: false`,
							},
							"max_data_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1GB`),
								Description: `Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+(\.\d+)?\s*(?:[kmgKMG](b|B))?$`), "must match pattern "+regexp.MustCompile(`^\d+(\.\d+)?\s*(?:[kmgKMG](b|B))?$`).String()),
								},
							},
							"max_data_time": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`24h`),
								Description: `Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
								},
							},
							"time_window": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`10m`),
								Description: `Time period for grouping spooled events. Default is 10m. Default: "10m"`,
							},
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"rules": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `Optional description of this rule's purpose`,
								},
								"filter": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression applied to Pod objects. Return 'true' to include it.`,
								},
							},
						},
						Description: `Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"timestamps": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted. Default: false`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "kube_logs"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"kube_logs",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_kube_metrics": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(15),
						Description: `Time, in seconds, between consecutive metrics collections. Default is 15 secs. Default: 15`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"persistence": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`gzip`),
								Description: `Default: "gzip"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"dest_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/kube_metrics`),
								Description: `Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>. Default: "$CRIBL_HOME/state/kube_metrics"`,
							},
							"enable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Spool metrics on disk for Cribl Search. Default: false`,
							},
							"max_data_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1GB`),
								Description: `Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_data_time": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`24h`),
								Description: `Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
								},
							},
							"time_window": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`10m`),
								Description: `Time span for each file bucket. Default: "10m"`,
							},
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"rules": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `Optional description of this rule's purpose`,
								},
								"filter": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression applied to Kubernetes objects. Return 'true' to include it.`,
								},
							},
						},
						Description: `Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "kube_metrics"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"kube_metrics",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_loki": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"auth_header_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`none`),
						Description: `Loki logs authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"login_url": schema.StringAttribute{
						Optional:    true,
						Description: `URL for OAuth`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"loki_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/loki/api/v1/push`),
						Description: `Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Default: "/loki/api/v1/push"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header value`,
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter value`,
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"secret": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter value to pass in request body`,
					},
					"secret_param_name": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter name to pass in request body`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"token": schema.StringAttribute{
						Optional:    true,
						Description: `Bearer token to include in the authorization header`,
					},
					"token_attribute_name": schema.StringAttribute{
						Optional:    true,
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
					},
					"token_timeout_secs": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `How often the OAuth token should be refreshed. Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 300000),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "loki"`,
						Validators: []validator.String{
							stringvalidator.OneOf("loki"),
						},
					},
					"username": schema.StringAttribute{
						Optional: true,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_metrics": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_whitelist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching IP addresses that are allowed to send data. Default: "/.*/"`,
					},
					"max_buffer_size": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tcp_port": schema.Float64Attribute{
						Optional:    true,
						Description: `Enter TCP port number to listen on. Not required if listening on UDP.`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "metrics"`,
						Validators: []validator.String{
							stringvalidator.OneOf("metrics"),
						},
					},
					"udp_port": schema.Float64Attribute{
						Optional:    true,
						Description: `Enter UDP port number to listen on. Not required if listening on TCP.`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"udp_socket_rx_buf_size": schema.Float64Attribute{
						Optional:    true,
						Description: `Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.`,
						Validators: []validator.Float64{
							float64validator.Between(256, 4294967295),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_model_driven_telemetry": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_active_cxn": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(57000),
						Description: `Port to listen on. Default: 57000`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"shutdown_timeout_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5000),
						Description: `Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000. Default: 5000`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "model_driven_telemetry"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"model_driven_telemetry",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_msk": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"authentication_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for Kafka to respond to an authentication request. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_interval": schema.Float64Attribute{
						Optional:    true,
						Description: `How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"auto_commit_threshold": schema.Float64Attribute{
						Optional:    true,
						Description: `How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000),
						},
					},
					"aws_api_key": schema.StringAttribute{
						Optional: true,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored secret that references your access key and secret key`,
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"backoff_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(2),
						Description: `Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2`,
						Validators: []validator.Float64{
							float64validator.Between(2, 20),
						},
					},
					"brokers": schema.ListAttribute{
						Required:    true,
						ElementType: types.StringType,
						Description: `Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"connection_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Maximum time to wait for a connection to complete successfully. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials to access MSK. Default: false`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"from_beginning": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true`,
					},
					"group_id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`Cribl`),
						Description: `The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"`,
					},
					"heartbeat_interval": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(3000),
						MarkdownDescription: `Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.` + "\n" +
							`      Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.` + "\n" +
							`Default: 3000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"initial_backoff": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(300, 600000),
						},
					},
					"kafka_schema_registry": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"auth": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"credentials_secret": schema.StringAttribute{
										Optional:    true,
										Description: `Select or create a secret that references your credentials`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Credentials to use when authenticating with the schema registry using basic HTTP authentication`,
							},
							"connection_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30000),
								Description: `Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000`,
								Validators: []validator.Float64{
									float64validator.Between(1000, 60000),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_retries": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `Maximum number of times to try fetching schemas from the Schema Registry. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtMost(100),
								},
							},
							"request_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30000),
								Description: `Maximum time to wait for the Schema Registry to respond to a request. Default: 30000`,
								Validators: []validator.Float64{
									float64validator.Between(1000, 60000),
								},
							},
							"schema_registry_url": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`http://localhost:8081`),
								Description: `URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"`,
							},
							"tls": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.`,
									},
									"cert_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"certificate_name": schema.StringAttribute{
										Optional:    true,
										Description: `The name of the predefined certificate`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
									"max_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Optional:    true,
										Description: `Passphrase to use to decrypt private key`,
									},
									"priv_key_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.`,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										MarkdownDescription: `Reject certificates that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
											`                    trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
											`Default: true`,
									},
									"servername": schema.StringAttribute{
										Optional:    true,
										Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.`,
									},
								},
							},
						},
					},
					"max_back_off": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30000),
						Description: `The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(30000, 180000),
						},
					},
					"max_bytes": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10485760),
						Description: `Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760`,
						Validators: []validator.Float64{
							float64validator.Between(1, 1000000000),
						},
					},
					"max_bytes_per_partition": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1048576),
						Description: `Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10000000),
						},
					},
					"max_retries": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"max_socket_errors": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `Maximum number of network errors before the consumer re-creates a socket. Default: 0`,
						Validators: []validator.Float64{
							float64validator.AtMost(100),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"reauthentication_threshold": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 1800000),
						},
					},
					"rebalance_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(60000),
						MarkdownDescription: `Maximum allowed time for each worker to join the group after a rebalance begins.` + "\n" +
							`      If the timeout is exceeded, the coordinator broker will remove the worker from the group.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.` + "\n" +
							`Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"region": schema.StringAttribute{
						Required:    true,
						Description: `Region where the MSK cluster is located`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(60000),
						Description: `Maximum time to wait for Kafka to respond to a request. Default: 60000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"session_timeout": schema.Float64Attribute{
						Computed: true,
						Optional: true,
						Default:  float64default.StaticFloat64(30000),
						MarkdownDescription: `Timeout used to detect client failures when using Kafka's group-management facilities.` + "\n" +
							`      If the client sends no heartbeats to the broker before the timeout expires, ` + "\n" +
							`      the broker will remove the client from the group and initiate a rebalance.` + "\n" +
							`      Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.` + "\n" +
							`      See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.` + "\n" +
							`Default: 30000`,
						Validators: []validator.Float64{
							float64validator.Between(1000, 3600000),
						},
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing MSK cluster requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								MarkdownDescription: `Reject certificates that are not authorized by a CA in the CA certificate path, or by another ` + "\n" +
									`                    trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.` + "\n" +
									`Default: true`,
							},
							"servername": schema.StringAttribute{
								Optional:    true,
								Description: `Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.`,
							},
						},
					},
					"topics": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "msk"`,
						Validators: []validator.String{
							stringvalidator.OneOf("msk"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_netflow": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_pass_through": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"ipfix_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Accept messages in IPFIX format. Default: false`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(2055),
						Description: `Port to listen on. Default: 2055`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"template_cache_minutes": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage. Default: 30`,
						Validators: []validator.Float64{
							float64validator.Between(1, 3600),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "netflow"`,
						Validators: []validator.String{
							stringvalidator.OneOf("netflow"),
						},
					},
					"udp_socket_rx_buf_size": schema.Float64Attribute{
						Optional:    true,
						Description: `Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.`,
						Validators: []validator.Float64{
							float64validator.Between(256, 4294967295),
						},
					},
					"v5_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Accept messages in Netflow V5 format. Default: true`,
					},
					"v9_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Accept messages in Netflow V9 format. Default: true`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_office365_mgmt": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"app_id": schema.StringAttribute{
						Required:    true,
						Description: `Office 365 Azure Application ID`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"client_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Office 365 Azure client secret`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"content_config": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"content_type": schema.StringAttribute{
									Optional:    true,
									Description: `Office 365 Management Activity API Content Type`,
								},
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `If interval type is minutes the value entered must evenly divisible by 60 or save will fail`,
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"interval": schema.Float64Attribute{
									Optional: true,
									Validators: []validator.Float64{
										float64validator.Between(1, 60),
									},
								},
								"log_level": schema.StringAttribute{
									Optional:    true,
									Description: `Collector runtime Log Level. must be one of ["error", "warn", "info", "debug"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"error",
											"warn",
											"info",
											"debug",
										),
									},
								},
							},
						},
						Description: `Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false`,
					},
					"ingestion_lag": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval. Default: 0`,
						Validators: []validator.Float64{
							float64validator.AtMost(7200),
						},
					},
					"job_timeout": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0`),
						Description: `Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`^\d+[sm]?$`).String()),
						},
					},
					"keep_alive_time": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How often workers should check in with the scheduler to keep job subscription alive. Default: 30`,
						Validators: []validator.Float64{
							float64validator.AtLeast(10),
						},
					},
					"max_missed_keep_alives": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3),
						Description: `The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3`,
						Validators: []validator.Float64{
							float64validator.AtLeast(2),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"plan_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`enterprise_gcc`),
						Description: `Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"enterprise_gcc",
								"gcc",
								"gcc_high",
								"dod",
							),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"publisher_identifier": schema.StringAttribute{
						Optional:    true,
						Description: `Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)`,
					},
					"retry_rules": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"codes": schema.ListAttribute{
								Optional:    true,
								ElementType: types.Float64Type,
								Description: `List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.`,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"enable_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true`,
							},
							"interval": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtMost(20000),
								},
							},
							"limit": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The maximum number of times to retry a failed HTTP request. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(20),
								},
							},
							"multiplier": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(2),
								Description: `Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2`,
								Validators: []validator.Float64{
									float64validator.Between(1, 20),
								},
							},
							"retry_connect_reset": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Retry request when a connection reset (ECONNRESET) error occurs. Default: false`,
							},
							"retry_connect_timeout": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`backoff`),
								Description: `The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"backoff",
										"static",
									),
								},
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tenant_id": schema.StringAttribute{
						Required:    true,
						Description: `Office 365 Azure Tenant ID`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `HTTP request inactivity timeout, use 0 to disable. Default: 300`,
						Validators: []validator.Float64{
							float64validator.AtMost(2400),
						},
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smh]$`), "must match pattern "+regexp.MustCompile(`\d+[smh]$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "office365_mgmt"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"office365_mgmt",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_office365_msg_trace": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`oauth`),
						Description: `Select authentication method. Default: "oauth"; must be one of ["manual", "secret", "oauth", "oauthSecret", "oauthCert"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
								"oauth",
								"oauthSecret",
								"oauthCert",
							),
						},
					},
					"cert_options": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cert_path": schema.StringAttribute{
								Required:    true,
								Description: `Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate.`,
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt the private key.`,
							},
							"priv_key_path": schema.StringAttribute{
								Required:    true,
								Description: `Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.`,
							},
						},
					},
					"client_id": schema.StringAttribute{
						Optional:    true,
						Description: `client_id to pass in the OAuth request parameter.`,
					},
					"client_secret": schema.StringAttribute{
						Optional:    true,
						Description: `client_secret to pass in the OAuth request parameter.`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials.`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disable_time_filter": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Disables time filtering of events when a date range is specified. Default: true`,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"end_date": schema.StringAttribute{
						Optional:    true,
						Description: `Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(60),
						Description: `How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail. Default: 60`,
						Validators: []validator.Float64{
							float64validator.Between(1, 60),
						},
					},
					"job_timeout": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0`),
						Description: `Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`^\d+[sm]?$`).String()),
						},
					},
					"keep_alive_time": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How often workers should check in with the scheduler to keep job subscription alive. Default: 30`,
						Validators: []validator.Float64{
							float64validator.AtLeast(10),
						},
					},
					"log_level": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`info`),
						Description: `Log Level (verbosity) for collection runtime behavior. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"warn",
								"info",
								"debug",
								"silly",
							),
						},
					},
					"max_missed_keep_alives": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3),
						Description: `The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3`,
						Validators: []validator.Float64{
							float64validator.AtLeast(2),
						},
					},
					"max_task_reschedule": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `Maximum number of times a task can be rescheduled. Default: 1`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"password": schema.StringAttribute{
						Optional:    true,
						Description: `Password to run Message Trace API call.`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"plan_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`enterprise_gcc`),
						Description: `Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"enterprise_gcc",
								"gcc",
								"gcc_high",
								"dod",
							),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"reschedule_dropped_tasks": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
					},
					"resource": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`https://outlook.office365.com`),
						Description: `Resource to pass in the OAuth request parameter. Default: "https://outlook.office365.com"`,
					},
					"retry_rules": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"codes": schema.ListAttribute{
								Optional:    true,
								ElementType: types.Float64Type,
								Description: `List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.`,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"enable_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true`,
							},
							"interval": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtMost(20000),
								},
							},
							"limit": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The maximum number of times to retry a failed HTTP request. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(20),
								},
							},
							"multiplier": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(2),
								Description: `Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2`,
								Validators: []validator.Float64{
									float64validator.Between(1, 20),
								},
							},
							"retry_connect_reset": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Retry request when a connection reset (ECONNRESET) error occurs. Default: false`,
							},
							"retry_connect_timeout": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`backoff`),
								Description: `The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"backoff",
										"static",
									),
								},
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"start_date": schema.StringAttribute{
						Optional:    true,
						Description: `Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tenant_id": schema.StringAttribute{
						Optional:    true,
						Description: `Directory ID (tenant identifier) in Azure Active Directory.`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your client_secret to pass in the OAuth request parameter.`,
					},
					"timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely. Default: 300`,
						Validators: []validator.Float64{
							float64validator.AtMost(2400),
						},
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smh]$`), "must match pattern "+regexp.MustCompile(`\d+[smh]$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "office365_msg_trace"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"office365_msg_trace",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace`),
						Description: `URL to use when retrieving report data. Default: "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"`,
					},
					"username": schema.StringAttribute{
						Optional:    true,
						Description: `Username to run Message Trace API call.`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_office365_service": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"app_id": schema.StringAttribute{
						Required:    true,
						Description: `Office 365 Azure Application ID`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"client_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Office 365 Azure client secret`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"content_config": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"content_type": schema.StringAttribute{
									Optional:    true,
									Description: `Office 365 Services API Content Type`,
								},
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `If interval type is minutes the value entered must evenly divisible by 60 or save will fail`,
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"interval": schema.Float64Attribute{
									Optional: true,
									Validators: []validator.Float64{
										float64validator.AtMost(60),
									},
								},
								"log_level": schema.StringAttribute{
									Optional:    true,
									Description: `Collector runtime Log Level. must be one of ["error", "warn", "info", "debug"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"error",
											"warn",
											"info",
											"debug",
										),
									},
								},
							},
						},
						Description: `Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false`,
					},
					"job_timeout": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0`),
						Description: `Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`^\d+[sm]?$`).String()),
						},
					},
					"keep_alive_time": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How often workers should check in with the scheduler to keep job subscription alive. Default: 30`,
						Validators: []validator.Float64{
							float64validator.AtLeast(10),
						},
					},
					"max_missed_keep_alives": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3),
						Description: `The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3`,
						Validators: []validator.Float64{
							float64validator.AtLeast(2),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"plan_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`enterprise_gcc`),
						Description: `Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"enterprise_gcc",
								"gcc",
								"gcc_high",
								"dod",
							),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"retry_rules": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"codes": schema.ListAttribute{
								Optional:    true,
								ElementType: types.Float64Type,
								Description: `List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.`,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"enable_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true`,
							},
							"interval": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtMost(20000),
								},
							},
							"limit": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The maximum number of times to retry a failed HTTP request. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(20),
								},
							},
							"multiplier": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(2),
								Description: `Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2`,
								Validators: []validator.Float64{
									float64validator.Between(1, 20),
								},
							},
							"retry_connect_reset": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Retry request when a connection reset (ECONNRESET) error occurs. Default: false`,
							},
							"retry_connect_timeout": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`backoff`),
								Description: `The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"backoff",
										"static",
									),
								},
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tenant_id": schema.StringAttribute{
						Required:    true,
						Description: `Office 365 Azure Tenant ID`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `HTTP request inactivity timeout, use 0 to disable. Default: 300`,
						Validators: []validator.Float64{
							float64validator.AtMost(2400),
						},
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smh]$`), "must match pattern "+regexp.MustCompile(`\d+[smh]$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "office365_service"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"office365_service",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_open_telemetry": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.StringAttribute{
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"auth_header_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`none`),
						Description: `OpenTelemetry authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"capture_headers": schema.StringAttribute{
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.StringAttribute{
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"extract_logs": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to extract each incoming log record to a separate event. Default: false`,
					},
					"extract_metrics": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point. Default: false`,
					},
					"extract_spans": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to extract each incoming span to a separate event. Default: false`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(15),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.). Default: 15`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"login_url": schema.StringAttribute{
						Optional:    true,
						Description: `URL for OAuth`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_active_cxn": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000`,
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header value`,
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter value`,
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"otlp_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.10.0`),
						Description: `The version of OTLP Protobuf definitions to use when interpreting received data. Default: "0.10.0"; must be one of ["0.10.0", "1.3.1"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"0.10.0",
								"1.3.1",
							),
						},
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(4317),
						Description: `Port to listen on. Default: 4317`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"protocol": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`grpc`),
						Description: `Select whether to leverage gRPC or HTTP for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"grpc",
								"http",
							),
						},
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"secret": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter value to pass in request body`,
					},
					"secret_param_name": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter name to pass in request body`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"token": schema.StringAttribute{
						Optional:    true,
						Description: `Bearer token to include in the authorization header`,
					},
					"token_attribute_name": schema.StringAttribute{
						Optional:    true,
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
					},
					"token_timeout_secs": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `How often the OAuth token should be refreshed. Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 300000),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "open_telemetry"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"open_telemetry",
							),
						},
					},
					"username": schema.StringAttribute{
						Optional: true,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_prometheus": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"dimension_list": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Other dimensions to include in events`,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"discovery_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`static`),
						Description: `Target discovery mechanism. Use static to manually enter a list of targets. Default: "static"; must be one of ["static", "dns", "ec2"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"static",
								"dns",
								"ec2",
							),
						},
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials to access EC2. Default: false`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(15),
						Description: `How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail. Default: 15`,
						Validators: []validator.Float64{
							float64validator.Between(1, 60),
						},
					},
					"job_timeout": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0`),
						Description: `Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`^\d+[sm]?$`).String()),
						},
					},
					"keep_alive_time": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How often workers should check in with the scheduler to keep job subscription alive. Default: 30`,
						Validators: []validator.Float64{
							float64validator.AtLeast(10),
						},
					},
					"log_level": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`info`),
						Description: `Collector runtime Log Level. Default: "info"; must be one of ["error", "warn", "info", "debug"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"warn",
								"info",
								"debug",
							),
						},
					},
					"max_missed_keep_alives": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3),
						Description: `The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3`,
						Validators: []validator.Float64{
							float64validator.AtLeast(2),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"name_list": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `List of DNS names to resolve`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"password": schema.StringAttribute{
						Optional:    true,
						Description: `Password for Prometheus Basic authentication`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"record_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`SRV`),
						Description: `DNS Record type to resolve. Default: "SRV"; must be one of ["SRV", "A", "AAAA"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SRV",
								"A",
								"AAAA",
							),
						},
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `Region where the EC2 is located`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"scrape_path": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/metrics`),
						Description: `Path to use when collecting metrics from discovered targets. Default: "/metrics"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/.*`), "must match pattern "+regexp.MustCompile(`^/.*`).String()),
						},
					},
					"scrape_port": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(9090),
						Description: `The port number in the metrics URL for discovered targets. Default: 9090`,
						Validators: []validator.Float64{
							float64validator.Between(1, 65535),
						},
					},
					"scrape_protocol": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`http`),
						Description: `Protocol to use when collecting metrics. Default: "http"; must be one of ["http", "https"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"http",
								"https",
							),
						},
					},
					"search_filter": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list`,
								},
								"values": schema.ListAttribute{
									Computed:    true,
									Optional:    true,
									Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
									ElementType: types.StringType,
									Description: `Search Filter Values, if empty only "running" EC2 instances will be returned`,
								},
							},
						},
						Description: `EC2 Instance Search Filter`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing EC2 requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"target_list": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smh]$`), "must match pattern "+regexp.MustCompile(`\d+[smh]$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "prometheus"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"prometheus",
							),
						},
					},
					"use_public_ip": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Use public IP address for discovered targets. Set to false if the private IP address should be used. Default: true`,
					},
					"username": schema.StringAttribute{
						Optional:    true,
						Description: `Username for Prometheus Basic authentication`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_prometheus_rw": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"auth_header_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`none`),
						Description: `Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"login_url": schema.StringAttribute{
						Optional:    true,
						Description: `URL for OAuth`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header value`,
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter value`,
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"prometheus_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/write`),
						Description: `Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<your‑upstream‑URL>:<your‑port>/write. Default: "/write"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
						},
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"secret": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter value to pass in request body`,
					},
					"secret_param_name": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter name to pass in request body`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"token": schema.StringAttribute{
						Optional:    true,
						Description: `Bearer token to include in the authorization header`,
					},
					"token_attribute_name": schema.StringAttribute{
						Optional:    true,
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
					},
					"token_timeout_secs": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `How often the OAuth token should be refreshed. Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 300000),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "prometheus_rw"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"prometheus_rw",
							),
						},
					},
					"username": schema.StringAttribute{
						Optional: true,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_raw_udp": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ingest_raw_bytes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram. Default: false`,
					},
					"ip_whitelist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching IP addresses that are allowed to send data. Default: "/.*/"`,
					},
					"max_buffer_size": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of events to buffer when downstream is blocking. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"single_msg_udp_packets": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines. Default: false`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "raw_udp"`,
						Validators: []validator.String{
							stringvalidator.OneOf("raw_udp"),
						},
					},
					"udp_socket_rx_buf_size": schema.Float64Attribute{
						Optional:    true,
						Description: `Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.`,
						Validators: []validator.Float64{
							float64validator.Between(256, 4294967295),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_s3": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"aws_account_id": schema.StringAttribute{
						Optional:    true,
						Description: `SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.`,
					},
					"aws_api_key": schema.StringAttribute{
						Optional: true,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored secret that references your access key and secret key`,
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"checkpointing": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume processing files after an interruption. Default: false`,
							},
							"retries": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(100),
								},
							},
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Use Assume Role credentials to access Amazon S3. Default: true`,
					},
					"enable_sqs_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials when accessing Amazon SQS. Default: false`,
					},
					"encoding": schema.StringAttribute{
						Optional:    true,
						Description: `Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"file_filter": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching file names to download and process. Defaults to: .*. Default: "/.*/"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_messages": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"num_receivers": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"parquet_chunk_download_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 3600),
						},
					},
					"parquet_chunk_size_mb": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `Maximum file size for each Parquet chunk. Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"poll_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10`,
						Validators: []validator.Float64{
							float64validator.Between(1, 20),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"preprocess": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `Arguments to be added to the custom command`,
							},
							"command": schema.StringAttribute{
								Optional:    true,
								Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
						},
					},
					"processed_tag_key": schema.StringAttribute{
						Optional:    true,
						Description: `The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"processed_tag_value": schema.StringAttribute{
						Optional:    true,
						Description: `The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"queue_name": schema.StringAttribute{
						Required:    true,
						Description: `The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `.`,
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"skip_on_error": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(1, 43200),
						},
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tag_after_processing": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions. Default: false`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "s3"`,
						Validators: []validator.String{
							stringvalidator.OneOf("s3"),
						},
					},
					"visibility_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600`,
						Validators: []validator.Float64{
							float64validator.AtMost(43200),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_s3_inventory": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"aws_account_id": schema.StringAttribute{
						Optional:    true,
						Description: `SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.`,
					},
					"aws_api_key": schema.StringAttribute{
						Optional: true,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored secret that references your access key and secret key`,
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"checkpointing": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume processing files after an interruption. Default: false`,
							},
							"retries": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(100),
								},
							},
						},
					},
					"checksum_suffix": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`checksum`),
						Description: `Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum". Default: "checksum"`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Use Assume Role credentials to access Amazon S3. Default: true`,
					},
					"enable_sqs_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials when accessing Amazon SQS. Default: false`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"file_filter": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching file names to download and process. Defaults to: .*. Default: "/.*/"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_manifest_size_kb": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(4096),
						Description: `Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096. Default: 4096`,
						Validators: []validator.Int64{
							int64validator.AtLeast(1),
						},
					},
					"max_messages": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"num_receivers": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"parquet_chunk_download_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 3600),
						},
					},
					"parquet_chunk_size_mb": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `Maximum file size for each Parquet chunk. Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"poll_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10`,
						Validators: []validator.Float64{
							float64validator.Between(1, 20),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"preprocess": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `Arguments to be added to the custom command`,
							},
							"command": schema.StringAttribute{
								Optional:    true,
								Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
						},
					},
					"processed_tag_key": schema.StringAttribute{
						Optional:    true,
						Description: `The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"processed_tag_value": schema.StringAttribute{
						Optional:    true,
						Description: `The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"queue_name": schema.StringAttribute{
						Required:    true,
						Description: `The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `.`,
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"skip_on_error": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(1, 43200),
						},
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tag_after_processing": schema.StringAttribute{
						Optional:    true,
						Description: `must be one of ["false", "true"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"false",
								"true",
							),
						},
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "s3_inventory"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"s3_inventory",
							),
						},
					},
					"validate_inventory_files": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false. Default: false`,
					},
					"visibility_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600`,
						Validators: []validator.Float64{
							float64validator.AtMost(43200),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_security_lake": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"aws_account_id": schema.StringAttribute{
						Optional:    true,
						Description: `SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.`,
					},
					"aws_api_key": schema.StringAttribute{
						Optional: true,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored secret that references your access key and secret key`,
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"checkpointing": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume processing files after an interruption. Default: false`,
							},
							"retries": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(100),
								},
							},
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Use Assume Role credentials to access Amazon S3. Default: true`,
					},
					"enable_sqs_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials when accessing Amazon SQS. Default: false`,
					},
					"encoding": schema.StringAttribute{
						Optional:    true,
						Description: `Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"file_filter": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching file names to download and process. Defaults to: .*. Default: "/.*/"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_messages": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"num_receivers": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1),
						Description: `How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"parquet_chunk_download_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 3600),
						},
					},
					"parquet_chunk_size_mb": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `Maximum file size for each Parquet chunk. Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"poll_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10`,
						Validators: []validator.Float64{
							float64validator.Between(1, 20),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"preprocess": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `Arguments to be added to the custom command`,
							},
							"command": schema.StringAttribute{
								Optional:    true,
								Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
						},
					},
					"processed_tag_key": schema.StringAttribute{
						Optional:    true,
						Description: `The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"processed_tag_value": schema.StringAttribute{
						Optional:    true,
						Description: `The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.`,
					},
					"queue_name": schema.StringAttribute{
						Required:    true,
						Description: `The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `.`,
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"skip_on_error": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300`,
						Validators: []validator.Float64{
							float64validator.Between(1, 43200),
						},
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tag_after_processing": schema.StringAttribute{
						Optional:    true,
						Description: `must be one of ["false", "true"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"false",
								"true",
							),
						},
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "security_lake"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"security_lake",
							),
						},
					},
					"visibility_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600`,
						Validators: []validator.Float64{
							float64validator.AtMost(43200),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_snmp": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"best_effort_parsing": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_whitelist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching IP addresses that are allowed to send data. Default: "/.*/"`,
					},
					"max_buffer_size": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of events to buffer when downstream is blocking. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(162),
						Description: `UDP port to receive SNMP traps on. Defaults to 162. Default: 162`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"snmp_v3_auth": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"allow_unmatched_trap": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps. Default: false`,
							},
							"v3_auth_enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"v3_users": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"auth_key": schema.StringAttribute{
											Optional:    true,
											Description: `Parsed as JSON.`,
											Validators: []validator.String{
												validators.IsValidJSON(),
											},
										},
										"auth_protocol": schema.StringAttribute{
											Computed:    true,
											Optional:    true,
											Default:     stringdefault.StaticString(`none`),
											Description: `Default: "none"; must be one of ["none", "md5", "sha", "sha224", "sha256", "sha384", "sha512"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"none",
													"md5",
													"sha",
													"sha224",
													"sha256",
													"sha384",
													"sha512",
												),
											},
										},
										"name": schema.StringAttribute{
											Required: true,
											Validators: []validator.String{
												stringvalidator.UTF8LengthAtLeast(1),
											},
										},
										"priv_protocol": schema.StringAttribute{
											Computed:    true,
											Optional:    true,
											Default:     stringdefault.StaticString(`none`),
											Description: `Default: "none"; Parsed as JSON.`,
											Validators: []validator.String{
												validators.IsValidJSON(),
											},
										},
									},
								},
								Description: `User credentials for receiving v3 traps`,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
						},
						Description: `Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "snmp"`,
						Validators: []validator.String{
							stringvalidator.OneOf("snmp"),
						},
					},
					"udp_socket_rx_buf_size": schema.Float64Attribute{
						Optional:    true,
						Description: `Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.`,
						Validators: []validator.Float64{
							float64validator.Between(256, 4294967295),
						},
					},
					"varbinds_with_types": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, parses varbinds as an array of objects that include OID, value, and type. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_splunk": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_tokens": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional: true,
								},
								"token": schema.StringAttribute{
									Required:    true,
									Description: `Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.`,
								},
							},
						},
						Description: `Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.`,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"compress": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`disabled`),
						Description: `Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections. Default: "disabled"; must be one of ["disabled", "auto", "always"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"disabled",
								"auto",
								"always",
							),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"drop_control_fields": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Drop Splunk control fields such as ` + "`" + `crcSalt` + "`" + ` and ` + "`" + `_savedPort` + "`" + `. If disabled, control fields are stored in the internal field ` + "`" + `__ctrlFields` + "`" + `. Default: true`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"extract_metrics": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract and process Splunk-generated metrics as Cribl metrics. Default: false`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_whitelist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching IP addresses that are allowed to establish a connection. Default: "/.*/"`,
					},
					"max_active_cxn": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000`,
					},
					"max_s2_sversion": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v3`),
						Description: `The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v3", "v4"),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_ending_max_wait": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30`,
					},
					"socket_idle_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0`,
					},
					"socket_max_lifespan": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "splunk"`,
						Validators: []validator.String{
							stringvalidator.OneOf("splunk"),
						},
					},
					"use_fwd_timezone": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Default: true`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_splunk_hec": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"access_control_allow_headers": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.`,
					},
					"access_control_allow_origin": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.`,
					},
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"allowed_indexes": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.`,
					},
					"auth_tokens": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"allowed_indexes_at_token": schema.ListAttribute{
									Optional:    true,
									ElementType: types.StringType,
									Description: `Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.`,
								},
								"auth_type": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Default:     stringdefault.StaticString(`manual`),
									Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"manual",
											"secret",
										),
									},
								},
								"description": schema.StringAttribute{
									Optional:    true,
									Description: `Optional token description`,
								},
								"enabled": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(true),
									Description: `Default: true`,
								},
								"metadata": schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Required: true,
											},
											"value": schema.StringAttribute{
												Required:    true,
												Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
											},
										},
									},
									Description: `Fields to add to events referencing this token`,
								},
								"token": schema.StringAttribute{
									Required:    true,
									Description: `Parsed as JSON.`,
									Validators: []validator.String{
										validators.IsValidJSON(),
									},
								},
								"token_secret": schema.StringAttribute{
									Optional:    true,
									Description: `Parsed as JSON.`,
									Validators: []validator.String{
										validators.IsValidJSON(),
									},
								},
							},
						},
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"drop_control_fields": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Drop Splunk control fields such as ` + "`" + `crcSalt` + "`" + ` and ` + "`" + `_savedPort` + "`" + `. If disabled, control fields are stored in the internal field ` + "`" + `__ctrlFields` + "`" + `. Default: true`,
					},
					"emit_token_metrics": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics. Default: false`,
					},
					"enable_health_check": schema.StringAttribute{
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"extract_metrics": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract and process Splunk-generated metrics as Cribl metrics. Default: false`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"splunk_hec_acks": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable Splunk HEC acknowledgements. Default: false`,
					},
					"splunk_hec_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/services/collector`),
						Description: `Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints. Default: "/services/collector"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
						},
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "splunk_hec"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"splunk_hec",
							),
						},
					},
					"use_fwd_timezone": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Default: true`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_splunk_search": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_header_expr": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`` + "`" + `Bearer ${token}` + "`" + ``),
						Description: `JavaScript expression to compute the Authorization header value to pass in requests. The value ` + "`" + `${token}` + "`" + ` is used to reference the token obtained from authentication, e.g.: ` + "`" + `Bearer ${token}` + "`" + `. Default: "` + "`" + `Bearer ${token}` + "`" + `"`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`basic`),
						Description: `Splunk Search authentication type. Default: "basic"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"basic",
								"credentialsSecret",
								"token",
								"textSecret",
								"oauth",
							),
						},
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"credentials_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a secret that references your credentials`,
					},
					"cron_schedule": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`*/15 * * * *`),
						Description: `A cron schedule on which to run this job. Default: "*/15 * * * *"`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"earliest": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`-16m@m`),
						Description: `The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'. Default: "-16m@m"`,
					},
					"encoding": schema.StringAttribute{
						Optional:    true,
						Description: `Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.`,
					},
					"endpoint": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/services/search/v2/jobs/export`),
						Description: `REST API used to create a search. Default: "/services/search/v2/jobs/export"`,
					},
					"endpoint_headers": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., ` + "`" + `${earliest}` + "`" + `). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.`,
								},
							},
						},
						Description: `Optional request headers to send to the endpoint`,
					},
					"endpoint_params": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., ` + "`" + `${earliest}` + "`" + `). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.`,
								},
							},
						},
						Description: `Optional request parameters to send to the endpoint`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false`,
					},
					"job_timeout": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0`),
						Description: `Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`^\d+[sm]?$`).String()),
						},
					},
					"keep_alive_time": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How often workers should check in with the scheduler to keep job subscription alive. Default: 30`,
						Validators: []validator.Float64{
							float64validator.AtLeast(10),
						},
					},
					"latest": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`-1m@m`),
						Description: `The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'. Default: "-1m@m"`,
					},
					"log_level": schema.StringAttribute{
						Optional:    true,
						Description: `Collector runtime log level (verbosity). must be one of ["error", "warn", "info", "debug"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"error",
								"warn",
								"info",
								"debug",
							),
						},
					},
					"login_url": schema.StringAttribute{
						Optional:    true,
						Description: `URL for OAuth`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.*`), "must match pattern "+regexp.MustCompile(`^https?://.*`).String()),
						},
					},
					"max_missed_keep_alives": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3),
						Description: `The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3`,
						Validators: []validator.Float64{
							float64validator.AtLeast(2),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"oauth_headers": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth header value`,
								},
							},
						},
						Description: `Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"oauth_params": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter name`,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `OAuth parameter value`,
								},
							},
						},
						Description: `Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.`,
					},
					"output_mode": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`json`),
						Description: `Format of the returned output. Default: "json"; must be one of ["csv", "json"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"csv",
								"json",
							),
						},
					},
					"password": schema.StringAttribute{
						Optional: true,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Reject certificates that cannot be verified against a valid CA (such as self-signed certificates). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `HTTP request inactivity timeout. Use 0 for no timeout. Default: 0`,
						Validators: []validator.Float64{
							float64validator.AtMost(2400),
						},
					},
					"retry_rules": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"codes": schema.ListAttribute{
								Optional:    true,
								ElementType: types.Float64Type,
								Description: `List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.`,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"enable_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true`,
							},
							"interval": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtMost(20000),
								},
							},
							"limit": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The maximum number of times to retry a failed HTTP request. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(20),
								},
							},
							"multiplier": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(2),
								Description: `Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2`,
								Validators: []validator.Float64{
									float64validator.Between(1, 20),
								},
							},
							"retry_connect_reset": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Retry request when a connection reset (ECONNRESET) error occurs. Default: false`,
							},
							"retry_connect_timeout": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`backoff`),
								Description: `The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"backoff",
										"static",
									),
								},
							},
						},
					},
					"search": schema.StringAttribute{
						Required:    true,
						Description: `Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'`,
					},
					"search_head": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`https://localhost:8089`),
						Description: `Search head base URL. Can be an expression. Default is https://localhost:8089. Default: "https://localhost:8089"`,
					},
					"secret": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter value to pass in request body`,
					},
					"secret_param_name": schema.StringAttribute{
						Optional:    true,
						Description: `Secret parameter name to pass in request body`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"token": schema.StringAttribute{
						Optional:    true,
						Description: `Bearer token to include in the authorization header`,
					},
					"token_attribute_name": schema.StringAttribute{
						Optional:    true,
						Description: `Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').`,
					},
					"token_timeout_secs": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `How often the OAuth token should be refreshed. Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(1, 300000),
						},
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smh]$`), "must match pattern "+regexp.MustCompile(`\d+[smh]$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "splunk_search"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"splunk_search",
							),
						},
					},
					"use_round_robin_dns": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. Default: false`,
					},
					"username": schema.StringAttribute{
						Optional: true,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_sqs": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `Amazon Resource Name (ARN) of the role to assume`,
						Validators: []validator.String{
							stringvalidator.UTF8LengthAtLeast(20),
							stringvalidator.RegexMatches(regexp.MustCompile(`^arn:`), "must match pattern "+regexp.MustCompile(`^arn:`).String()),
						},
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID to use when assuming role`,
					},
					"aws_account_id": schema.StringAttribute{
						Optional:    true,
						Description: `SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.`,
					},
					"aws_api_key": schema.StringAttribute{
						Optional: true,
					},
					"aws_authentication_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`auto`),
						Description: `AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored secret that references your access key and secret key`,
					},
					"aws_secret_key": schema.StringAttribute{
						Optional: true,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"create_queue": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Create queue if it does not exist. Default: false`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"duration_seconds": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3600),
						Description: `Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600`,
						Validators: []validator.Float64{
							float64validator.Between(900, 43200),
						},
					},
					"enable_assume_role": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use Assume Role credentials to access SQS. Default: false`,
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"max_messages": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 10`,
						Validators: []validator.Float64{
							float64validator.Between(1, 10),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"num_receivers": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3),
						Description: `How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 3`,
						Validators: []validator.Float64{
							float64validator.Between(1, 100),
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"poll_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10`,
						Validators: []validator.Float64{
							float64validator.Between(1, 20),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"queue_name": schema.StringAttribute{
						Required:    true,
						Description: `The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: ` + "`" + `https://host:port/myQueue-${C.vars.myVar}` + "`" + `.`,
					},
					"queue_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`standard`),
						Description: `The queue type used (or created). Default: "standard"; must be one of ["standard", "fifo"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"standard",
								"fifo",
							),
						},
					},
					"region": schema.StringAttribute{
						Optional:    true,
						Description: `AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.`,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true`,
					},
					"reuse_connections": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Reuse connections between requests, which can improve performance. Default: true`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"signature_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`v4`),
						Description: `Signature version to use for signing SQS requests. Default: "v4"; must be one of ["v2", "v4"]`,
						Validators: []validator.String{
							stringvalidator.OneOf("v2", "v4"),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "sqs"`,
						Validators: []validator.String{
							stringvalidator.OneOf("sqs"),
						},
					},
					"visibility_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(600),
						Description: `After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600`,
						Validators: []validator.Float64{
							float64validator.AtMost(43200),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_syslog": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"input_syslog_syslog1": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"allow_non_standard_app_name": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages. Default: false`,
							},
							"connections": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"output": schema.StringAttribute{
											Required: true,
										},
										"pipeline": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
							},
							"description": schema.StringAttribute{
								Optional: true,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"enable_enhanced_proxy_header_parsing": schema.BoolAttribute{
								Optional:    true,
								Description: `When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.`,
							},
							"enable_load_balancing": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Load balance traffic across all Worker Processes. Default: false`,
							},
							"enable_proxy_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false`,
							},
							"environment": schema.StringAttribute{
								Optional:    true,
								Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
							},
							"host": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0.0.0.0`),
								Description: `Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"`,
							},
							"id": schema.StringAttribute{
								Optional:    true,
								Description: `Unique ID for this input`,
							},
							"infer_framing": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Enable if we should infer the syslog framing of the incoming messages. Default: true`,
							},
							"ip_whitelist_regex": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/.*/`),
								Description: `Regex matching IP addresses that are allowed to send data. Default: "/.*/"`,
							},
							"keep_fields_list": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								ElementType: types.StringType,
								Description: `Wildcard list of fields to keep from source data; * = ALL (default)`,
							},
							"max_active_cxn": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited. Default: 1000`,
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"octet_counting": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable if incoming messages use octet counting per RFC 6587. Default: false`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process data from this Source before sending it through the Routes`,
							},
							"pq": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"commit_frequency": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(42),
										Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"compress": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"gzip",
											),
										},
									},
									"max_buffer_size": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1000),
										Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
										Validators: []validator.Float64{
											float64validator.AtLeast(42),
										},
									},
									"max_file_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1 MB`),
										Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"max_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`5GB`),
										Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`always`),
										Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"smart",
												"always",
											),
										},
									},
									"path": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
										Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
									},
								},
							},
							"pq_enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
							},
							"single_msg_udp_packets": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Treat UDP packet data received as full syslog message. Default: false`,
							},
							"socket_ending_max_wait": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30),
								Description: `How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30`,
							},
							"socket_idle_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0`,
							},
							"socket_max_lifespan": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0`,
							},
							"streamtags": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								ElementType: types.StringType,
								Description: `Tags for filtering and grouping in @{product}`,
							},
							"strictly_infer_octet_counting": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Enable if we should infer octet counting only if the messages comply with RFC 5424. Default: true`,
							},
							"tcp_port": schema.Float64Attribute{
								Optional:    true,
								Description: `Enter TCP port number to listen on. Not required if listening on UDP.`,
								Validators: []validator.Float64{
									float64validator.AtMost(65535),
								},
							},
							"timestamp_timezone": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`local`),
								Description: `Timezone to assign to timestamps without timezone info. Default: "local"`,
							},
							"tls": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"cert_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"certificate_name": schema.StringAttribute{
										Optional:    true,
										Description: `The name of the predefined certificate`,
									},
									"common_name_regex": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
									"max_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Optional:    true,
										Description: `Passphrase to use to decrypt private key`,
									},
									"priv_key_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
									},
									"reject_unauthorized": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"request_cert": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(false),
										Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "syslog"`,
								Validators: []validator.String{
									stringvalidator.OneOf("syslog"),
								},
							},
							"udp_port": schema.Float64Attribute{
								Required:    true,
								Description: `Enter UDP port number to listen on. Not required if listening on TCP.`,
								Validators: []validator.Float64{
									float64validator.AtMost(65535),
								},
							},
							"udp_socket_rx_buf_size": schema.Float64Attribute{
								Optional:    true,
								Description: `Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.`,
								Validators: []validator.Float64{
									float64validator.Between(256, 4294967295),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("input_syslog_syslog2"),
							}...),
						},
					},
					"input_syslog_syslog2": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"allow_non_standard_app_name": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages. Default: false`,
							},
							"connections": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"output": schema.StringAttribute{
											Required: true,
										},
										"pipeline": schema.StringAttribute{
											Optional: true,
										},
									},
								},
								Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
							},
							"description": schema.StringAttribute{
								Optional: true,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Default: false`,
							},
							"enable_enhanced_proxy_header_parsing": schema.BoolAttribute{
								Optional:    true,
								Description: `When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.`,
							},
							"enable_load_balancing": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Load balance traffic across all Worker Processes. Default: false`,
							},
							"enable_proxy_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false`,
							},
							"environment": schema.StringAttribute{
								Optional:    true,
								Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
							},
							"host": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0.0.0.0`),
								Description: `Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"`,
							},
							"id": schema.StringAttribute{
								Optional:    true,
								Description: `Unique ID for this input`,
							},
							"infer_framing": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Enable if we should infer the syslog framing of the incoming messages. Default: true`,
							},
							"ip_whitelist_regex": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/.*/`),
								Description: `Regex matching IP addresses that are allowed to send data. Default: "/.*/"`,
							},
							"keep_fields_list": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								ElementType: types.StringType,
								Description: `Wildcard list of fields to keep from source data; * = ALL (default)`,
							},
							"max_active_cxn": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited. Default: 1000`,
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"octet_counting": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable if incoming messages use octet counting per RFC 6587. Default: false`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process data from this Source before sending it through the Routes`,
							},
							"pq": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"commit_frequency": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(42),
										Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"compress": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`none`),
										Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"gzip",
											),
										},
									},
									"max_buffer_size": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1000),
										Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
										Validators: []validator.Float64{
											float64validator.AtLeast(42),
										},
									},
									"max_file_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1 MB`),
										Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"max_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`5GB`),
										Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`always`),
										Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"smart",
												"always",
											),
										},
									},
									"path": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
										Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
									},
								},
							},
							"pq_enabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
							},
							"single_msg_udp_packets": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Treat UDP packet data received as full syslog message. Default: false`,
							},
							"socket_ending_max_wait": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(30),
								Description: `How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30`,
							},
							"socket_idle_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0`,
							},
							"socket_max_lifespan": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(0),
								Description: `The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0`,
							},
							"streamtags": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								ElementType: types.StringType,
								Description: `Tags for filtering and grouping in @{product}`,
							},
							"strictly_infer_octet_counting": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Enable if we should infer octet counting only if the messages comply with RFC 5424. Default: true`,
							},
							"tcp_port": schema.Float64Attribute{
								Required:    true,
								Description: `Enter TCP port number to listen on. Not required if listening on UDP.`,
								Validators: []validator.Float64{
									float64validator.AtMost(65535),
								},
							},
							"timestamp_timezone": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`local`),
								Description: `Timezone to assign to timestamps without timezone info. Default: "local"`,
							},
							"tls": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"ca_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"cert_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
									},
									"certificate_name": schema.StringAttribute{
										Optional:    true,
										Description: `The name of the predefined certificate`,
									},
									"common_name_regex": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
									"max_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"min_version": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"TLSv1",
												"TLSv1.1",
												"TLSv1.2",
												"TLSv1.3",
											),
										},
									},
									"passphrase": schema.StringAttribute{
										Optional:    true,
										Description: `Passphrase to use to decrypt private key`,
									},
									"priv_key_path": schema.StringAttribute{
										Optional:    true,
										Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
									},
									"reject_unauthorized": schema.StringAttribute{
										Optional:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"request_cert": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(false),
										Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "syslog"`,
								Validators: []validator.String{
									stringvalidator.OneOf("syslog"),
								},
							},
							"udp_port": schema.Float64Attribute{
								Optional:    true,
								Description: `Enter UDP port number to listen on. Not required if listening on TCP.`,
								Validators: []validator.Float64{
									float64validator.AtMost(65535),
								},
							},
							"udp_socket_rx_buf_size": schema.Float64Attribute{
								Optional:    true,
								Description: `Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.`,
								Validators: []validator.Float64{
									float64validator.Between(256, 4294967295),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("input_syslog_syslog1"),
							}...),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_system_metrics": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"container": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"all_containers": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Include stopped and paused containers. Default: false`,
							},
							"detail": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Generate full container metrics. Default: false`,
							},
							"docker_socket": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `Full paths for Docker's UNIX-domain socket`,
							},
							"docker_timeout": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `Timeout, in seconds, for the Docker API. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"filters": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"expr": schema.StringAttribute{
											Required: true,
										},
									},
								},
								Description: `Containers matching any of these will be included. All are included if no filters are added.`,
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`basic`),
								Description: `Select the level of detail for container metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"basic",
										"all",
										"custom",
										"disabled",
									),
								},
							},
							"per_device": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Generate separate metrics for each device. Default: false`,
							},
						},
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"custom": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"cpu": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for all CPU states. Default: false`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of detail for CPU metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
											"per_cpu": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for each CPU. Default: false`,
											},
											"time": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate raw, monotonic CPU time counters. Default: false`,
											},
										},
									},
									"disk": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate full disk metrics. Default: false`,
											},
											"devices": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
												Description: `Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.`,
											},
											"fstypes": schema.ListAttribute{
												Computed:    true,
												Optional:    true,
												Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
												ElementType: types.StringType,
												Description: `Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty.`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of detail for disk metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
											"mountpoints": schema.ListAttribute{
												Computed:    true,
												Optional:    true,
												Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
												ElementType: types.StringType,
												Description: `Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.`,
											},
											"per_device": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate separate metrics for each device. Default: false`,
											},
										},
									},
									"memory": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for all memory states. Default: false`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of detail for memory metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
										},
									},
									"network": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate full network metrics. Default: false`,
											},
											"devices": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
												Description: `Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty.`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of detail for network metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
											"per_interface": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate separate metrics for each interface. Default: false`,
											},
										},
									},
									"system": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of detail for system metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
											"processes": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for the numbers of processes in various states. Default: false`,
											},
										},
									},
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`basic`),
								Description: `Select level of detail for host metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"basic",
										"all",
										"custom",
										"disabled",
									),
								},
							},
						},
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `Time, in seconds, between consecutive metric collections. Default is 10 seconds. Default: 10`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"persistence": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`gzip`),
								Description: `Default: "gzip"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"dest_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/system_metrics`),
								Description: `Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics. Default: "$CRIBL_HOME/state/system_metrics"`,
							},
							"enable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Spool metrics to disk for Cribl Edge and Search. Default: false`,
							},
							"max_data_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1GB`),
								Description: `Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_data_time": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`24h`),
								Description: `Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
								},
							},
							"time_window": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`10m`),
								Description: `Time span for each file bucket. Default: "10m"`,
							},
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"process": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"sets": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"filter": schema.StringAttribute{
											Required: true,
										},
										"include_children": schema.BoolAttribute{
											Computed:    true,
											Optional:    true,
											Default:     booldefault.StaticBool(false),
											Description: `Default: false`,
										},
										"name": schema.StringAttribute{
											Required: true,
										},
									},
								},
								Description: `Configure sets to collect process metrics`,
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "system_metrics"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"system_metrics",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_system_state": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collectors": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"disk": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events for physical disks, partitions, and file systems`,
							},
							"dns": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events for DNS resolvers and search entries`,
							},
							"firewall": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events for Firewall rules entries`,
							},
							"hostsfile": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events based on entries collected from the hosts file`,
							},
							"interfaces": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events for each of the host’s network interfaces`,
							},
							"login_users": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events from list of logged-in users`,
							},
							"metadata": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events based on the host system’s current state`,
							},
							"ports": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events from list of listening ports`,
							},
							"routes": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events based on entries collected from the host’s network routes`,
							},
							"services": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events from the list of services`,
							},
							"user": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"enable": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
								Description: `Creates events for local users and groups`,
							},
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disable_native_module": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab). Default: false`,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes). Default: 300`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"persistence": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"dest_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/system_state`),
								Description: `Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state. Default: "$CRIBL_HOME/state/system_state"`,
							},
							"enable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Spool metrics to disk for Cribl Edge and Search. Default: false`,
							},
							"max_data_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1GB`),
								Description: `Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_data_time": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`24h`),
								Description: `Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
								},
							},
							"time_window": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`10m`),
								Description: `Time span for each file bucket. Default: "10m"`,
							},
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "system_state"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"system_state",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_tcp": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"breaker_rulesets": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_whitelist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching IP addresses that are allowed to establish a connection. Default: "/.*/"`,
					},
					"max_active_cxn": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"preprocess": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `Arguments to be added to the custom command`,
							},
							"command": schema.StringAttribute{
								Optional:    true,
								Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_ending_max_wait": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30`,
					},
					"socket_idle_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0`,
					},
					"socket_max_lifespan": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0`,
					},
					"stale_channel_flush_ms": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10000),
						Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
						Validators: []validator.Float64{
							float64validator.Between(10, 43200000),
						},
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "tcp"`,
						Validators: []validator.String{
							stringvalidator.OneOf("tcp"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_tcpjson": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_token": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(``),
						Description: `Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_load_balancing": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Load balance traffic across all Worker Processes. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_whitelist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Regex matching IP addresses that are allowed to establish a connection. Default: "/.*/"`,
					},
					"max_active_cxn": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(1000),
						Description: `Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_ending_max_wait": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30`,
					},
					"socket_idle_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0`,
					},
					"socket_max_lifespan": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "tcpjson"`,
						Validators: []validator.String{
							stringvalidator.OneOf("tcpjson"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_wef": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"allow_machine_id_mismatch": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Allow events to be ingested even if their MachineID does not match the client certificate CN. Default: false`,
					},
					"auth_method": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`clientCert`),
						Description: `How to authenticate incoming client connections. Default: "clientCert"; must be one of ["clientCert", "kerberos"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"clientCert",
								"kerberos",
							),
						},
					},
					"ca_fingerprint": schema.StringAttribute{
						Optional:    true,
						Description: `SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"enable_health_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false`,
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Preserve the client’s original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(90),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 90`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"keytab": schema.StringAttribute{
						Optional:    true,
						Description: `Path to the keytab file containing the service principal credentials. @{product} will use ` + "`" + `/etc/krb5.keytab` + "`" + ` if not provided.`,
					},
					"log_fingerprint_mismatch": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder. Default: false`,
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5986),
						Description: `Port to listen on. Default: 5986`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"principal": schema.StringAttribute{
						Optional:    true,
						Description: `Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"subscriptions": schema.ListNestedAttribute{
						Required: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"batch_timeout": schema.Float64Attribute{
									Computed:    true,
									Optional:    true,
									Default:     float64default.StaticFloat64(60),
									Description: `Interval (in seconds) over which the endpoint should collect events before sending them to Stream. Default: 60`,
								},
								"compress": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(true),
									Description: `Receive compressed events from the source. Default: true`,
								},
								"content_format": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Default:     stringdefault.StaticString(`Raw`),
									Description: `Content format in which the endpoint should deliver events. Default: "Raw"; must be one of ["Raw", "RenderedText"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"Raw",
											"RenderedText",
										),
									},
								},
								"heartbeat_interval": schema.Float64Attribute{
									Computed:    true,
									Optional:    true,
									Default:     float64default.StaticFloat64(60),
									Description: `Maximum time (in seconds) between endpoint checkins before considering it unavailable. Default: 60`,
									Validators: []validator.Float64{
										float64validator.AtLeast(1),
									},
								},
								"id": schema.StringAttribute{
									Required: true,
								},
								"locale": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Default:     stringdefault.StaticString(`en-US`),
									Description: `The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US". Default: "en-US"`,
								},
								"metadata": schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Required: true,
											},
											"value": schema.StringAttribute{
												Required:    true,
												Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
											},
										},
									},
									Description: `Fields to add to events ingested under this subscription`,
								},
								"query_selector": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Default:     stringdefault.StaticString(`simple`),
									Description: `Default: "simple"; must be one of ["simple", "xml"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"simple",
											"xml",
										),
									},
								},
								"read_existing_events": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(false),
									Description: `Newly subscribed endpoints will send previously existing events. Disable to receive new events only. Default: false`,
								},
								"send_bookmarks": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(true),
									Description: `Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details. Default: true`,
								},
								"subscription_name": schema.StringAttribute{
									Required: true,
								},
								"targets": schema.ListAttribute{
									Optional:    true,
									ElementType: types.StringType,
									Description: `The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com`,
								},
								"version": schema.StringAttribute{
									Optional:    true,
									Description: `Version UUID for this subscription. If any subscription parameters are modified, this value will change.`,
								},
							},
						},
						Description: `Subscriptions to events on forwarding endpoints`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Required:    true,
								Description: `Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.`,
							},
							"cert_path": schema.StringAttribute{
								Required:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `Name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`/.*/`),
								Description: `Regex matching allowable common names in peer certificates' subject attribute. Default: "/.*/"`,
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable TLS. Default: false`,
							},
							"keytab": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"ocsp_check": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Enable OCSP check of certificate. Default: false`,
							},
							"ocsp_check_fail_close": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors. Default: false`,
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"principal": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"priv_key_path": schema.StringAttribute{
								Required:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Required for WEF certificate authentication. Default: true`,
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Required for WEF certificate authentication. Default: true`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "wef"`,
						Validators: []validator.String{
							stringvalidator.OneOf("wef"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_windows_metrics": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disable_native_module": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab). Default: false`,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"host": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"custom": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"cpu": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for all CPU states. Default: false`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of details for CPU metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
											"per_cpu": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for each CPU. Default: false`,
											},
											"time": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate raw, monotonic CPU time counters. Default: false`,
											},
										},
									},
									"disk": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of details for disk metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
											"per_volume": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate separate metrics for each volume. Default: false`,
											},
											"volumes": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
												Description: `Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.`,
											},
										},
									},
									"memory": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for all memory states. Default: false`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of details for memory metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
										},
									},
									"network": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate full network metrics. Default: false`,
											},
											"devices": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
												Description: `Network interfaces to include/exclude. All interfaces are included if this list is empty.`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of details for network metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
											"per_interface": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate separate metrics for each interface. Default: false`,
											},
										},
									},
									"system": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"detail": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Generate metrics for all system information. Default: false`,
											},
											"mode": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`basic`),
												Description: `Select the level of details for system metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"basic",
														"all",
														"custom",
														"disabled",
													),
												},
											},
										},
									},
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`basic`),
								Description: `Select level of detail for host metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"basic",
										"all",
										"custom",
										"disabled",
									),
								},
							},
						},
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `Time, in seconds, between consecutive metric collections. Default is 10 seconds. Default: 10`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"persistence": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`gzip`),
								Description: `Default: "gzip"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"dest_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/windows_metrics`),
								Description: `Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics. Default: "$CRIBL_HOME/state/windows_metrics"`,
							},
							"enable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Spool metrics to disk for Cribl Edge and Search. Default: false`,
							},
							"max_data_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1GB`),
								Description: `Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_data_time": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`24h`),
								Description: `Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smhd]$`), "must match pattern "+regexp.MustCompile(`\d+[smhd]$`).String()),
								},
							},
							"time_window": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`10m`),
								Description: `Time span for each file bucket. Default: "10m"`,
							},
						},
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"process": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"sets": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"filter": schema.StringAttribute{
											Required: true,
										},
										"include_children": schema.BoolAttribute{
											Computed:    true,
											Optional:    true,
											Default:     booldefault.StaticBool(false),
											Description: `Default: false`,
										},
										"name": schema.StringAttribute{
											Required: true,
										},
									},
								},
								Description: `Configure sets to collect process metrics`,
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "windows_metrics"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"windows_metrics",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_win_event_logs": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"batch_size": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(500),
						Description: `The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools). Default: 500`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disable_native_module": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings). Default: false`,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"event_format": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`json`),
						Description: `Format of individual events. Default: "json"; must be one of ["json", "xml"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"json",
								"xml",
							),
						},
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"interval": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(10),
						Description: `Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools). Default: 10`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"log_names": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.`,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
					"max_event_bytes": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(51200),
						Description: `The maximum number of bytes in an event before it is flushed to the pipelines. Default: 51200`,
						Validators: []validator.Float64{
							float64validator.Between(1, 134217728),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"read_mode": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`oldest`),
						Description: `Read all stored and future event logs, or only future events. Default: "oldest"; must be one of ["oldest", "newest"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"oldest",
								"newest",
							),
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "win_event_logs"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"win_event_logs",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_wiz": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_audience_override": schema.StringAttribute{
						Optional:    true,
						Description: `The audience to use when requesting an OAuth token for a custom auth URL. When not specified, ` + "`" + `wiz-api` + "`" + ` will be used.`,
					},
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`manual`),
						Description: `Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"manual",
								"secret",
							),
						},
					},
					"auth_url": schema.StringAttribute{
						Required:    true,
						Description: `The authentication URL to generate an OAuth token`,
					},
					"client_id": schema.StringAttribute{
						Required:    true,
						Description: `The client ID of the Wiz application`,
					},
					"client_secret": schema.StringAttribute{
						Optional:    true,
						Description: `The client secret of the Wiz application`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"content_config": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"content_description": schema.StringAttribute{
									Optional: true,
								},
								"content_type": schema.StringAttribute{
									Required:    true,
									Description: `The name of the Wiz query`,
								},
								"enabled": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(false),
									Description: `Default: false`,
								},
							},
						},
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"endpoint": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`https://api.<region>.app.wiz.io/graphql`),
						Description: `The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql. Default: "https://api.<region>.app.wiz.io/graphql"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https:\/\/`), "must match pattern "+regexp.MustCompile(`^https:\/\/`).String()),
						},
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false`,
					},
					"keep_alive_time": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(30),
						Description: `How often workers should check in with the scheduler to keep job subscription alive. Default: 30`,
						Validators: []validator.Float64{
							float64validator.AtLeast(10),
						},
					},
					"max_missed_keep_alives": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(3),
						Description: `The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3`,
						Validators: []validator.Float64{
							float64validator.AtLeast(2),
						},
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to events from this input`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(300),
						Description: `HTTP request inactivity timeout. Use 0 to disable. Default: 300`,
						Validators: []validator.Float64{
							float64validator.AtMost(2400),
						},
					},
					"retry_rules": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"codes": schema.ListAttribute{
								Optional:    true,
								ElementType: types.Float64Type,
								Description: `List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.`,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"enable_header": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true`,
							},
							"interval": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtMost(20000),
								},
							},
							"limit": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(5),
								Description: `The maximum number of times to retry a failed HTTP request. Default: 5`,
								Validators: []validator.Float64{
									float64validator.AtMost(20),
								},
							},
							"multiplier": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(2),
								Description: `Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2`,
								Validators: []validator.Float64{
									float64validator.Between(1, 20),
								},
							},
							"retry_connect_reset": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Retry request when a connection reset (ECONNRESET) error occurs. Default: false`,
							},
							"retry_connect_timeout": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false`,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`backoff`),
								Description: `The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"backoff",
										"static",
									),
								},
							},
						},
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"text_secret": schema.StringAttribute{
						Optional:    true,
						Description: `Select or create a stored text secret`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`\d+[smh]$`), "must match pattern "+regexp.MustCompile(`\d+[smh]$`).String()),
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "wiz"`,
						Validators: []validator.String{
							stringvalidator.OneOf("wiz"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_zscaler_hec"),
					}...),
				},
			},
			"input_zscaler_hec": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"access_control_allow_headers": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.`,
					},
					"access_control_allow_origin": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.`,
					},
					"activity_log_sample_rate": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(100),
						Description: `How often request activity is logged at the ` + "`" + `info` + "`" + ` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100`,
						Validators: []validator.Float64{
							float64validator.AtLeast(1),
						},
					},
					"allowed_indexes": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.`,
					},
					"auth_tokens": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"allowed_indexes_at_token": schema.ListAttribute{
									Optional:    true,
									ElementType: types.StringType,
									Description: `Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.`,
								},
								"auth_type": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Default:     stringdefault.StaticString(`manual`),
									Description: `Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"manual",
											"secret",
										),
									},
								},
								"description": schema.StringAttribute{
									Optional: true,
								},
								"enabled": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(true),
									Description: `Default: true`,
								},
								"metadata": schema.ListNestedAttribute{
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Required: true,
											},
											"value": schema.StringAttribute{
												Required:    true,
												Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
											},
										},
									},
									Description: `Fields to add to events referencing this token`,
								},
								"token": schema.StringAttribute{
									Required:    true,
									Description: `Parsed as JSON.`,
									Validators: []validator.String{
										validators.IsValidJSON(),
									},
								},
								"token_secret": schema.StringAttribute{
									Optional:    true,
									Description: `Parsed as JSON.`,
									Validators: []validator.String{
										validators.IsValidJSON(),
									},
								},
							},
						},
						Description: `Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.`,
					},
					"capture_headers": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Add request headers to events, in the __headers field. Default: false`,
					},
					"connections": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"output": schema.StringAttribute{
									Required: true,
								},
								"pipeline": schema.StringAttribute{
									Optional: true,
								},
							},
						},
						Description: `Direct connections to Destinations, and optionally via a Pipeline or a Pack`,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"emit_token_metrics": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics. Default: false`,
					},
					"enable_health_check": schema.StringAttribute{
						Optional:    true,
						Description: `Parsed as JSON.`,
						Validators: []validator.String{
							validators.IsValidJSON(),
						},
					},
					"enable_proxy_header": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false`,
					},
					"environment": schema.StringAttribute{
						Optional:    true,
						Description: `Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.`,
					},
					"hec_acks": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Whether to enable Zscaler HEC acknowledgements. Default: false`,
					},
					"hec_api": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/services/collector`),
						Description: `Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint. Default: "/services/collector"`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^/`), "must match pattern "+regexp.MustCompile(`^/`).String()),
						},
					},
					"host": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`0.0.0.0`),
						Description: `Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"`,
					},
					"id": schema.StringAttribute{
						Optional:    true,
						Description: `Unique ID for this input`,
					},
					"ip_allowlist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/.*/`),
						Description: `Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.*/"`,
					},
					"ip_denylist_regex": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`/^$/`),
						Description: `Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"`,
					},
					"keep_alive_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(5),
						Description: `After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5`,
						Validators: []validator.Float64{
							float64validator.Between(1, 600),
						},
					},
					"max_active_req": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(256),
						Description: `Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256`,
					},
					"max_requests_per_socket": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     int64default.StaticInt64(0),
						Description: `Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0`,
					},
					"metadata": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Required: true,
								},
								"value": schema.StringAttribute{
									Required:    true,
									Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
								},
							},
						},
						Description: `Fields to add to every event. May be overridden by fields added at the token or request level.`,
					},
					"pipeline": schema.StringAttribute{
						Optional:    true,
						Description: `Pipeline to process data from this Source before sending it through the Routes`,
					},
					"port": schema.Float64Attribute{
						Required:    true,
						Description: `Port to listen on`,
						Validators: []validator.Float64{
							float64validator.AtMost(65535),
						},
					},
					"pq": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit_frequency": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(42),
								Description: `The number of events to send downstream before committing that Stream has read them. Default: 42`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"compress": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`none`),
								Description: `Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"none",
										"gzip",
									),
								},
							},
							"max_buffer_size": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1000),
								Description: `The maximum number of events to hold in memory before writing the events to disk. Default: 1000`,
								Validators: []validator.Float64{
									float64validator.AtLeast(42),
								},
							},
							"max_file_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`1 MB`),
								Description: `The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"max_size": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`5GB`),
								Description: `The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^\d+\s*(?:\w{2})?$`), "must match pattern "+regexp.MustCompile(`^\d+\s*(?:\w{2})?$`).String()),
								},
							},
							"mode": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`always`),
								Description: `With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"smart",
										"always",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`$CRIBL_HOME/state/queues`),
								Description: `The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"`,
							},
						},
					},
					"pq_enabled": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false`,
					},
					"request_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0`,
					},
					"send_to_routes": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Select whether to send data to Routes, or directly to Destinations. Default: true`,
					},
					"socket_timeout": schema.Float64Attribute{
						Computed:    true,
						Optional:    true,
						Default:     float64default.StaticFloat64(0),
						Description: `How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping in @{product}`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"cert_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.`,
							},
							"certificate_name": schema.StringAttribute{
								Optional:    true,
								Description: `The name of the predefined certificate`,
							},
							"common_name_regex": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"disabled": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Default: true`,
							},
							"max_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Optional:    true,
								Description: `must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"passphrase": schema.StringAttribute{
								Optional:    true,
								Description: `Passphrase to use to decrypt private key`,
							},
							"priv_key_path": schema.StringAttribute{
								Optional:    true,
								Description: `Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.`,
							},
							"reject_unauthorized": schema.StringAttribute{
								Optional:    true,
								Description: `Parsed as JSON.`,
								Validators: []validator.String{
									validators.IsValidJSON(),
								},
							},
							"request_cert": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false`,
							},
						},
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `must be "zscaler_hec"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"zscaler_hec",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_appscope"),
						path.MatchRelative().AtParent().AtName("input_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collection"),
						path.MatchRelative().AtParent().AtName("input_confluent_cloud"),
						path.MatchRelative().AtParent().AtName("input_cribl"),
						path.MatchRelative().AtParent().AtName("input_cribl_http"),
						path.MatchRelative().AtParent().AtName("input_cribl_lake_http"),
						path.MatchRelative().AtParent().AtName("input_criblmetrics"),
						path.MatchRelative().AtParent().AtName("input_cribl_tcp"),
						path.MatchRelative().AtParent().AtName("input_crowdstrike"),
						path.MatchRelative().AtParent().AtName("input_datadog_agent"),
						path.MatchRelative().AtParent().AtName("input_datagen"),
						path.MatchRelative().AtParent().AtName("input_edge_prometheus"),
						path.MatchRelative().AtParent().AtName("input_elastic"),
						path.MatchRelative().AtParent().AtName("input_eventhub"),
						path.MatchRelative().AtParent().AtName("input_exec"),
						path.MatchRelative().AtParent().AtName("input_file"),
						path.MatchRelative().AtParent().AtName("input_firehose"),
						path.MatchRelative().AtParent().AtName("input_google_pubsub"),
						path.MatchRelative().AtParent().AtName("input_grafana"),
						path.MatchRelative().AtParent().AtName("input_http"),
						path.MatchRelative().AtParent().AtName("input_http_raw"),
						path.MatchRelative().AtParent().AtName("input_journal_files"),
						path.MatchRelative().AtParent().AtName("input_kafka"),
						path.MatchRelative().AtParent().AtName("input_kinesis"),
						path.MatchRelative().AtParent().AtName("input_kube_events"),
						path.MatchRelative().AtParent().AtName("input_kube_logs"),
						path.MatchRelative().AtParent().AtName("input_kube_metrics"),
						path.MatchRelative().AtParent().AtName("input_loki"),
						path.MatchRelative().AtParent().AtName("input_metrics"),
						path.MatchRelative().AtParent().AtName("input_model_driven_telemetry"),
						path.MatchRelative().AtParent().AtName("input_msk"),
						path.MatchRelative().AtParent().AtName("input_netflow"),
						path.MatchRelative().AtParent().AtName("input_office365_mgmt"),
						path.MatchRelative().AtParent().AtName("input_office365_msg_trace"),
						path.MatchRelative().AtParent().AtName("input_office365_service"),
						path.MatchRelative().AtParent().AtName("input_open_telemetry"),
						path.MatchRelative().AtParent().AtName("input_prometheus"),
						path.MatchRelative().AtParent().AtName("input_prometheus_rw"),
						path.MatchRelative().AtParent().AtName("input_raw_udp"),
						path.MatchRelative().AtParent().AtName("input_s3"),
						path.MatchRelative().AtParent().AtName("input_s3_inventory"),
						path.MatchRelative().AtParent().AtName("input_security_lake"),
						path.MatchRelative().AtParent().AtName("input_snmp"),
						path.MatchRelative().AtParent().AtName("input_splunk"),
						path.MatchRelative().AtParent().AtName("input_splunk_hec"),
						path.MatchRelative().AtParent().AtName("input_splunk_search"),
						path.MatchRelative().AtParent().AtName("input_sqs"),
						path.MatchRelative().AtParent().AtName("input_syslog"),
						path.MatchRelative().AtParent().AtName("input_system_metrics"),
						path.MatchRelative().AtParent().AtName("input_system_state"),
						path.MatchRelative().AtParent().AtName("input_tcp"),
						path.MatchRelative().AtParent().AtName("input_tcpjson"),
						path.MatchRelative().AtParent().AtName("input_wef"),
						path.MatchRelative().AtParent().AtName("input_windows_metrics"),
						path.MatchRelative().AtParent().AtName("input_win_event_logs"),
						path.MatchRelative().AtParent().AtName("input_wiz"),
					}...),
				},
			},
			"items": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"comments": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"additional_properties": schema.StringAttribute{
										Computed:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"comment": schema.StringAttribute{
										Computed:    true,
										Description: `Optional, short description of this Route's purpose`,
									},
								},
							},
							Description: `Comments`,
						},
						"conf": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"async_func_timeout": schema.Int64Attribute{
									Computed:    true,
									Description: `Time (in ms) to wait for an async function to complete processing of a data item`,
									Validators: []validator.Int64{
										int64validator.AtMost(10000),
									},
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"functions": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"conf": schema.SingleNestedAttribute{
												Computed: true,
											},
											"description": schema.StringAttribute{
												Computed:    true,
												Description: `Simple description of this step`,
											},
											"disabled": schema.BoolAttribute{
												Computed:    true,
												Description: `If true, data will not be pushed through this function`,
											},
											"filter": schema.StringAttribute{
												Computed:    true,
												Default:     stringdefault.StaticString(`true`),
												Description: `Filter that selects data to be fed through this Function. Default: "true"`,
											},
											"final": schema.BoolAttribute{
												Computed:    true,
												Description: `If enabled, stops the results of this Function from being passed to the downstream Functions`,
											},
											"group_id": schema.StringAttribute{
												Computed:    true,
												Description: `Group ID`,
											},
											"id": schema.StringAttribute{
												Computed:    true,
												Description: `Function ID`,
											},
										},
									},
									Description: `List of Functions to pass data through`,
								},
								"groups": schema.MapNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"description": schema.StringAttribute{
												Computed:    true,
												Description: `Short description of this group`,
											},
											"disabled": schema.BoolAttribute{
												Computed:    true,
												Description: `Whether this group is disabled`,
											},
											"name": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
								"output": schema.StringAttribute{
									Computed:    true,
									Default:     stringdefault.StaticString(`default`),
									Description: `The output destination for events processed by this Pipeline. Default: "default"`,
								},
								"streamtags": schema.ListAttribute{
									Computed:    true,
									Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
									ElementType: types.StringType,
									Description: `Tags for filtering and grouping in @{product}`,
								},
							},
						},
						"groups": schema.MapNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"description": schema.StringAttribute{
										Computed:    true,
										Description: `Short description of this group`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Description: `Whether this group is disabled`,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
								},
							},
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"routes": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"additional_properties": schema.StringAttribute{
										Computed:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Description: `Disable this routing rule`,
									},
									"enable_output_expression": schema.BoolAttribute{
										Computed:    true,
										Default:     booldefault.StaticBool(false),
										Description: `Enable to use a JavaScript expression that evaluates to the name of the Description below. Default: false`,
									},
									"filter": schema.StringAttribute{
										Computed:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `JavaScript expression to select data to route. Default: "true"`,
									},
									"final": schema.BoolAttribute{
										Computed:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Flag to control whether the event gets consumed by this Route (Final), or cloned into it. Default: true`,
									},
									"id": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"output": schema.StringAttribute{
										Computed:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"output_expression": schema.StringAttribute{
										Computed:    true,
										Description: `Parsed as JSON.`,
										Validators: []validator.String{
											validators.IsValidJSON(),
										},
									},
									"pipeline": schema.StringAttribute{
										Computed:    true,
										Description: `Pipeline to send the matching data to`,
									},
								},
							},
							Description: `Pipeline routing rules`,
						},
					},
				},
			},
			"pack": schema.StringAttribute{
				Required:    true,
				Description: `pack inputs to POST`,
			},
		},
	}
}

func (r *PackSourceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.CriblIo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.CriblIo, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *PackSourceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *PackSourceResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsCreateSystemInputsByPackRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Pipelines.CreateSystemInputsByPack(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsCreateSystemInputsByPackResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetSystemInputsByPackAndIDRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Routes.GetSystemInputsByPackAndID(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSystemInputsByPackAndIDResponseBody(ctx, res1.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PackSourceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *PackSourceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetSystemInputsByPackAndIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Routes.GetSystemInputsByPackAndID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSystemInputsByPackAndIDResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PackSourceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *PackSourceResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateSystemInputsByPackRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Pipelines.UpdateSystemInputsByPack(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsUpdateSystemInputsByPackResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetSystemInputsByPackAndIDRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Routes.GetSystemInputsByPackAndID(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSystemInputsByPackAndIDResponseBody(ctx, res1.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PackSourceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *PackSourceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteSystemInputsByPackRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Pipelines.DeleteSystemInputsByPack(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *PackSourceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	dec := json.NewDecoder(bytes.NewReader([]byte(req.ID)))
	dec.DisallowUnknownFields()
	var data struct {
		GroupID string `json:"group_id"`
		ID      string `json:"id"`
		Pack    string `json:"pack"`
	}

	if err := dec.Decode(&data); err != nil {
		resp.Diagnostics.AddError("Invalid ID", `The import ID is not valid. It is expected to be a JSON object string with the format: '{"group_id": "", "id": "", "pack": ""}': `+err.Error())
		return
	}

	if len(data.GroupID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field group_id is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("group_id"), data.GroupID)...)
	if len(data.ID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field id is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), data.ID)...)
	if len(data.Pack) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field pack is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("pack"), data.Pack)...)
}
