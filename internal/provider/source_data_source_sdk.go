// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/speakeasy/terraform-provider-criblio/internal/provider/types"
	"github.com/speakeasy/terraform-provider-criblio/internal/sdk/models/operations"
	"github.com/speakeasy/terraform-provider-criblio/internal/sdk/models/shared"
)

func (r *SourceDataSourceModel) ToOperationsListInputRequest(ctx context.Context) (*operations.ListInputRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var groupID string
	groupID = r.GroupID.ValueString()

	out := operations.ListInputRequest{
		GroupID: groupID,
	}

	return &out, diags
}

func (r *SourceDataSourceModel) RefreshFromSharedInput(ctx context.Context, resp *shared.Input) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp.InputAppscope != nil {
		r.InputAppscope = &tfTypes.InputAppscope{}
		r.InputAppscope.AuthToken = types.StringPointerValue(resp.InputAppscope.AuthToken)
		if resp.InputAppscope.AuthType != nil {
			r.InputAppscope.AuthType = types.StringValue(string(*resp.InputAppscope.AuthType))
		} else {
			r.InputAppscope.AuthType = types.StringNull()
		}
		r.InputAppscope.BreakerRulesets = make([]types.String, 0, len(resp.InputAppscope.BreakerRulesets))
		for _, v := range resp.InputAppscope.BreakerRulesets {
			r.InputAppscope.BreakerRulesets = append(r.InputAppscope.BreakerRulesets, types.StringValue(v))
		}
		r.InputAppscope.Connections = []tfTypes.InputAppscopeConnection{}
		if len(r.InputAppscope.Connections) > len(resp.InputAppscope.Connections) {
			r.InputAppscope.Connections = r.InputAppscope.Connections[:len(resp.InputAppscope.Connections)]
		}
		for connectionsCount, connectionsItem := range resp.InputAppscope.Connections {
			var connections tfTypes.InputAppscopeConnection
			connections.Output = types.StringValue(connectionsItem.Output)
			connections.Pipeline = types.StringPointerValue(connectionsItem.Pipeline)
			if connectionsCount+1 > len(r.InputAppscope.Connections) {
				r.InputAppscope.Connections = append(r.InputAppscope.Connections, connections)
			} else {
				r.InputAppscope.Connections[connectionsCount].Output = connections.Output
				r.InputAppscope.Connections[connectionsCount].Pipeline = connections.Pipeline
			}
		}
		r.InputAppscope.Description = types.StringPointerValue(resp.InputAppscope.Description)
		r.InputAppscope.Disabled = types.BoolPointerValue(resp.InputAppscope.Disabled)
		r.InputAppscope.EnableProxyHeader = types.BoolPointerValue(resp.InputAppscope.EnableProxyHeader)
		r.InputAppscope.EnableUnixPath = types.BoolPointerValue(resp.InputAppscope.EnableUnixPath)
		r.InputAppscope.Environment = types.StringPointerValue(resp.InputAppscope.Environment)
		if resp.InputAppscope.Filter == nil {
			r.InputAppscope.Filter = nil
		} else {
			r.InputAppscope.Filter = &tfTypes.InputAppscopeFilter{}
			r.InputAppscope.Filter.Allow = []tfTypes.Allow{}
			if len(r.InputAppscope.Filter.Allow) > len(resp.InputAppscope.Filter.Allow) {
				r.InputAppscope.Filter.Allow = r.InputAppscope.Filter.Allow[:len(resp.InputAppscope.Filter.Allow)]
			}
			for allowCount, allowItem := range resp.InputAppscope.Filter.Allow {
				var allow tfTypes.Allow
				allow.Arg = types.StringPointerValue(allowItem.Arg)
				allow.Config = types.StringValue(allowItem.Config)
				allow.Procname = types.StringValue(allowItem.Procname)
				if allowCount+1 > len(r.InputAppscope.Filter.Allow) {
					r.InputAppscope.Filter.Allow = append(r.InputAppscope.Filter.Allow, allow)
				} else {
					r.InputAppscope.Filter.Allow[allowCount].Arg = allow.Arg
					r.InputAppscope.Filter.Allow[allowCount].Config = allow.Config
					r.InputAppscope.Filter.Allow[allowCount].Procname = allow.Procname
				}
			}
			r.InputAppscope.Filter.TransportURL = types.StringPointerValue(resp.InputAppscope.Filter.TransportURL)
		}
		r.InputAppscope.Host = types.StringPointerValue(resp.InputAppscope.Host)
		r.InputAppscope.ID = types.StringValue(resp.InputAppscope.ID)
		r.InputAppscope.IPWhitelistRegex = types.StringPointerValue(resp.InputAppscope.IPWhitelistRegex)
		r.InputAppscope.MaxActiveCxn = types.Float64PointerValue(resp.InputAppscope.MaxActiveCxn)
		r.InputAppscope.Metadata = []tfTypes.InputAppscopeMetadatum{}
		if len(r.InputAppscope.Metadata) > len(resp.InputAppscope.Metadata) {
			r.InputAppscope.Metadata = r.InputAppscope.Metadata[:len(resp.InputAppscope.Metadata)]
		}
		for metadataCount, metadataItem := range resp.InputAppscope.Metadata {
			var metadata tfTypes.InputAppscopeMetadatum
			metadata.Name = types.StringValue(metadataItem.Name)
			metadata.Value = types.StringValue(metadataItem.Value)
			if metadataCount+1 > len(r.InputAppscope.Metadata) {
				r.InputAppscope.Metadata = append(r.InputAppscope.Metadata, metadata)
			} else {
				r.InputAppscope.Metadata[metadataCount].Name = metadata.Name
				r.InputAppscope.Metadata[metadataCount].Value = metadata.Value
			}
		}
		if resp.InputAppscope.Persistence == nil {
			r.InputAppscope.Persistence = nil
		} else {
			r.InputAppscope.Persistence = &tfTypes.InputAppscopePersistence{}
			if resp.InputAppscope.Persistence.Compress != nil {
				r.InputAppscope.Persistence.Compress = types.StringValue(string(*resp.InputAppscope.Persistence.Compress))
			} else {
				r.InputAppscope.Persistence.Compress = types.StringNull()
			}
			r.InputAppscope.Persistence.DestPath = types.StringPointerValue(resp.InputAppscope.Persistence.DestPath)
			r.InputAppscope.Persistence.Enable = types.BoolPointerValue(resp.InputAppscope.Persistence.Enable)
			r.InputAppscope.Persistence.MaxDataSize = types.StringPointerValue(resp.InputAppscope.Persistence.MaxDataSize)
			r.InputAppscope.Persistence.MaxDataTime = types.StringPointerValue(resp.InputAppscope.Persistence.MaxDataTime)
			r.InputAppscope.Persistence.TimeWindow = types.StringPointerValue(resp.InputAppscope.Persistence.TimeWindow)
		}
		r.InputAppscope.Pipeline = types.StringPointerValue(resp.InputAppscope.Pipeline)
		r.InputAppscope.Port = types.Float64PointerValue(resp.InputAppscope.Port)
		if resp.InputAppscope.Pq == nil {
			r.InputAppscope.Pq = nil
		} else {
			r.InputAppscope.Pq = &tfTypes.InputAppscopePq{}
			r.InputAppscope.Pq.CommitFrequency = types.Float64PointerValue(resp.InputAppscope.Pq.CommitFrequency)
			if resp.InputAppscope.Pq.Compress != nil {
				r.InputAppscope.Pq.Compress = types.StringValue(string(*resp.InputAppscope.Pq.Compress))
			} else {
				r.InputAppscope.Pq.Compress = types.StringNull()
			}
			r.InputAppscope.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputAppscope.Pq.MaxBufferSize)
			r.InputAppscope.Pq.MaxFileSize = types.StringPointerValue(resp.InputAppscope.Pq.MaxFileSize)
			r.InputAppscope.Pq.MaxSize = types.StringPointerValue(resp.InputAppscope.Pq.MaxSize)
			if resp.InputAppscope.Pq.Mode != nil {
				r.InputAppscope.Pq.Mode = types.StringValue(string(*resp.InputAppscope.Pq.Mode))
			} else {
				r.InputAppscope.Pq.Mode = types.StringNull()
			}
			r.InputAppscope.Pq.Path = types.StringPointerValue(resp.InputAppscope.Pq.Path)
		}
		r.InputAppscope.PqEnabled = types.BoolPointerValue(resp.InputAppscope.PqEnabled)
		r.InputAppscope.SendToRoutes = types.BoolPointerValue(resp.InputAppscope.SendToRoutes)
		r.InputAppscope.SocketEndingMaxWait = types.Float64PointerValue(resp.InputAppscope.SocketEndingMaxWait)
		r.InputAppscope.SocketIdleTimeout = types.Float64PointerValue(resp.InputAppscope.SocketIdleTimeout)
		r.InputAppscope.SocketMaxLifespan = types.Float64PointerValue(resp.InputAppscope.SocketMaxLifespan)
		r.InputAppscope.StaleChannelFlushMs = types.Float64PointerValue(resp.InputAppscope.StaleChannelFlushMs)
		r.InputAppscope.Streamtags = make([]types.String, 0, len(resp.InputAppscope.Streamtags))
		for _, v := range resp.InputAppscope.Streamtags {
			r.InputAppscope.Streamtags = append(r.InputAppscope.Streamtags, types.StringValue(v))
		}
		r.InputAppscope.TextSecret = types.StringPointerValue(resp.InputAppscope.TextSecret)
		if resp.InputAppscope.TLS == nil {
			r.InputAppscope.TLS = nil
		} else {
			r.InputAppscope.TLS = &tfTypes.InputAppscopeTLSSettingsServerSide{}
			r.InputAppscope.TLS.CaPath = types.StringPointerValue(resp.InputAppscope.TLS.CaPath)
			r.InputAppscope.TLS.CertificateName = types.StringPointerValue(resp.InputAppscope.TLS.CertificateName)
			r.InputAppscope.TLS.CertPath = types.StringPointerValue(resp.InputAppscope.TLS.CertPath)
			if resp.InputAppscope.TLS.CommonNameRegex == nil {
				r.InputAppscope.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult, _ := json.Marshal(resp.InputAppscope.TLS.CommonNameRegex)
				r.InputAppscope.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult))
			}
			r.InputAppscope.TLS.Disabled = types.BoolPointerValue(resp.InputAppscope.TLS.Disabled)
			if resp.InputAppscope.TLS.MaxVersion != nil {
				r.InputAppscope.TLS.MaxVersion = types.StringValue(string(*resp.InputAppscope.TLS.MaxVersion))
			} else {
				r.InputAppscope.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputAppscope.TLS.MinVersion != nil {
				r.InputAppscope.TLS.MinVersion = types.StringValue(string(*resp.InputAppscope.TLS.MinVersion))
			} else {
				r.InputAppscope.TLS.MinVersion = types.StringNull()
			}
			r.InputAppscope.TLS.Passphrase = types.StringPointerValue(resp.InputAppscope.TLS.Passphrase)
			r.InputAppscope.TLS.PrivKeyPath = types.StringPointerValue(resp.InputAppscope.TLS.PrivKeyPath)
			if resp.InputAppscope.TLS.RejectUnauthorized == nil {
				r.InputAppscope.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult, _ := json.Marshal(resp.InputAppscope.TLS.RejectUnauthorized)
				r.InputAppscope.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult))
			}
			r.InputAppscope.TLS.RequestCert = types.BoolPointerValue(resp.InputAppscope.TLS.RequestCert)
		}
		r.InputAppscope.Type = types.StringValue(string(resp.InputAppscope.Type))
		r.InputAppscope.UnixSocketPath = types.StringPointerValue(resp.InputAppscope.UnixSocketPath)
		r.InputAppscope.UnixSocketPerms = types.StringPointerValue(resp.InputAppscope.UnixSocketPerms)
	}
	if resp.InputAzureBlob != nil {
		r.InputAzureBlob = &tfTypes.InputAzureBlob{}
		if resp.InputAzureBlob.AuthType != nil {
			r.InputAzureBlob.AuthType = types.StringValue(string(*resp.InputAzureBlob.AuthType))
		} else {
			r.InputAzureBlob.AuthType = types.StringNull()
		}
		r.InputAzureBlob.AzureCloud = types.StringPointerValue(resp.InputAzureBlob.AzureCloud)
		r.InputAzureBlob.BreakerRulesets = make([]types.String, 0, len(resp.InputAzureBlob.BreakerRulesets))
		for _, v := range resp.InputAzureBlob.BreakerRulesets {
			r.InputAzureBlob.BreakerRulesets = append(r.InputAzureBlob.BreakerRulesets, types.StringValue(v))
		}
		if resp.InputAzureBlob.Certificate == nil {
			r.InputAzureBlob.Certificate = nil
		} else {
			r.InputAzureBlob.Certificate = &tfTypes.InputAzureBlobCertificate{}
			r.InputAzureBlob.Certificate.CertificateName = types.StringValue(resp.InputAzureBlob.Certificate.CertificateName)
		}
		r.InputAzureBlob.ClientID = types.StringPointerValue(resp.InputAzureBlob.ClientID)
		r.InputAzureBlob.ClientTextSecret = types.StringPointerValue(resp.InputAzureBlob.ClientTextSecret)
		r.InputAzureBlob.Connections = []tfTypes.InputAzureBlobConnection{}
		if len(r.InputAzureBlob.Connections) > len(resp.InputAzureBlob.Connections) {
			r.InputAzureBlob.Connections = r.InputAzureBlob.Connections[:len(resp.InputAzureBlob.Connections)]
		}
		for connectionsCount1, connectionsItem1 := range resp.InputAzureBlob.Connections {
			var connections1 tfTypes.InputAzureBlobConnection
			connections1.Output = types.StringValue(connectionsItem1.Output)
			connections1.Pipeline = types.StringPointerValue(connectionsItem1.Pipeline)
			if connectionsCount1+1 > len(r.InputAzureBlob.Connections) {
				r.InputAzureBlob.Connections = append(r.InputAzureBlob.Connections, connections1)
			} else {
				r.InputAzureBlob.Connections[connectionsCount1].Output = connections1.Output
				r.InputAzureBlob.Connections[connectionsCount1].Pipeline = connections1.Pipeline
			}
		}
		r.InputAzureBlob.ConnectionString = types.StringPointerValue(resp.InputAzureBlob.ConnectionString)
		r.InputAzureBlob.Description = types.StringPointerValue(resp.InputAzureBlob.Description)
		r.InputAzureBlob.Disabled = types.BoolPointerValue(resp.InputAzureBlob.Disabled)
		r.InputAzureBlob.EndpointSuffix = types.StringPointerValue(resp.InputAzureBlob.EndpointSuffix)
		r.InputAzureBlob.Environment = types.StringPointerValue(resp.InputAzureBlob.Environment)
		r.InputAzureBlob.FileFilter = types.StringPointerValue(resp.InputAzureBlob.FileFilter)
		r.InputAzureBlob.ID = types.StringPointerValue(resp.InputAzureBlob.ID)
		r.InputAzureBlob.MaxMessages = types.Float64PointerValue(resp.InputAzureBlob.MaxMessages)
		r.InputAzureBlob.Metadata = []tfTypes.InputAzureBlobMetadatum{}
		if len(r.InputAzureBlob.Metadata) > len(resp.InputAzureBlob.Metadata) {
			r.InputAzureBlob.Metadata = r.InputAzureBlob.Metadata[:len(resp.InputAzureBlob.Metadata)]
		}
		for metadataCount1, metadataItem1 := range resp.InputAzureBlob.Metadata {
			var metadata1 tfTypes.InputAzureBlobMetadatum
			metadata1.Name = types.StringValue(metadataItem1.Name)
			metadata1.Value = types.StringValue(metadataItem1.Value)
			if metadataCount1+1 > len(r.InputAzureBlob.Metadata) {
				r.InputAzureBlob.Metadata = append(r.InputAzureBlob.Metadata, metadata1)
			} else {
				r.InputAzureBlob.Metadata[metadataCount1].Name = metadata1.Name
				r.InputAzureBlob.Metadata[metadataCount1].Value = metadata1.Value
			}
		}
		r.InputAzureBlob.NumReceivers = types.Float64PointerValue(resp.InputAzureBlob.NumReceivers)
		r.InputAzureBlob.ParquetChunkDownloadTimeout = types.Float64PointerValue(resp.InputAzureBlob.ParquetChunkDownloadTimeout)
		r.InputAzureBlob.ParquetChunkSizeMB = types.Float64PointerValue(resp.InputAzureBlob.ParquetChunkSizeMB)
		r.InputAzureBlob.Pipeline = types.StringPointerValue(resp.InputAzureBlob.Pipeline)
		if resp.InputAzureBlob.Pq == nil {
			r.InputAzureBlob.Pq = nil
		} else {
			r.InputAzureBlob.Pq = &tfTypes.InputAzureBlobPq{}
			r.InputAzureBlob.Pq.CommitFrequency = types.Float64PointerValue(resp.InputAzureBlob.Pq.CommitFrequency)
			if resp.InputAzureBlob.Pq.Compress != nil {
				r.InputAzureBlob.Pq.Compress = types.StringValue(string(*resp.InputAzureBlob.Pq.Compress))
			} else {
				r.InputAzureBlob.Pq.Compress = types.StringNull()
			}
			r.InputAzureBlob.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputAzureBlob.Pq.MaxBufferSize)
			r.InputAzureBlob.Pq.MaxFileSize = types.StringPointerValue(resp.InputAzureBlob.Pq.MaxFileSize)
			r.InputAzureBlob.Pq.MaxSize = types.StringPointerValue(resp.InputAzureBlob.Pq.MaxSize)
			if resp.InputAzureBlob.Pq.Mode != nil {
				r.InputAzureBlob.Pq.Mode = types.StringValue(string(*resp.InputAzureBlob.Pq.Mode))
			} else {
				r.InputAzureBlob.Pq.Mode = types.StringNull()
			}
			r.InputAzureBlob.Pq.Path = types.StringPointerValue(resp.InputAzureBlob.Pq.Path)
		}
		r.InputAzureBlob.PqEnabled = types.BoolPointerValue(resp.InputAzureBlob.PqEnabled)
		r.InputAzureBlob.QueueName = types.StringValue(resp.InputAzureBlob.QueueName)
		r.InputAzureBlob.SendToRoutes = types.BoolPointerValue(resp.InputAzureBlob.SendToRoutes)
		r.InputAzureBlob.ServicePeriodSecs = types.Float64PointerValue(resp.InputAzureBlob.ServicePeriodSecs)
		r.InputAzureBlob.SkipOnError = types.BoolPointerValue(resp.InputAzureBlob.SkipOnError)
		r.InputAzureBlob.StaleChannelFlushMs = types.Float64PointerValue(resp.InputAzureBlob.StaleChannelFlushMs)
		r.InputAzureBlob.StorageAccountName = types.StringPointerValue(resp.InputAzureBlob.StorageAccountName)
		r.InputAzureBlob.Streamtags = make([]types.String, 0, len(resp.InputAzureBlob.Streamtags))
		for _, v := range resp.InputAzureBlob.Streamtags {
			r.InputAzureBlob.Streamtags = append(r.InputAzureBlob.Streamtags, types.StringValue(v))
		}
		r.InputAzureBlob.TenantID = types.StringPointerValue(resp.InputAzureBlob.TenantID)
		r.InputAzureBlob.TextSecret = types.StringPointerValue(resp.InputAzureBlob.TextSecret)
		r.InputAzureBlob.Type = types.StringValue(string(resp.InputAzureBlob.Type))
		r.InputAzureBlob.VisibilityTimeout = types.Float64PointerValue(resp.InputAzureBlob.VisibilityTimeout)
	}
	if resp.InputCollection != nil {
		r.InputCollection = &tfTypes.InputCollection{}
		r.InputCollection.BreakerRulesets = make([]types.String, 0, len(resp.InputCollection.BreakerRulesets))
		for _, v := range resp.InputCollection.BreakerRulesets {
			r.InputCollection.BreakerRulesets = append(r.InputCollection.BreakerRulesets, types.StringValue(v))
		}
		r.InputCollection.Connections = []tfTypes.InputCollectionConnection{}
		if len(r.InputCollection.Connections) > len(resp.InputCollection.Connections) {
			r.InputCollection.Connections = r.InputCollection.Connections[:len(resp.InputCollection.Connections)]
		}
		for connectionsCount2, connectionsItem2 := range resp.InputCollection.Connections {
			var connections2 tfTypes.InputCollectionConnection
			connections2.Output = types.StringValue(connectionsItem2.Output)
			connections2.Pipeline = types.StringPointerValue(connectionsItem2.Pipeline)
			if connectionsCount2+1 > len(r.InputCollection.Connections) {
				r.InputCollection.Connections = append(r.InputCollection.Connections, connections2)
			} else {
				r.InputCollection.Connections[connectionsCount2].Output = connections2.Output
				r.InputCollection.Connections[connectionsCount2].Pipeline = connections2.Pipeline
			}
		}
		r.InputCollection.Disabled = types.BoolPointerValue(resp.InputCollection.Disabled)
		r.InputCollection.Environment = types.StringPointerValue(resp.InputCollection.Environment)
		r.InputCollection.ID = types.StringValue(resp.InputCollection.ID)
		r.InputCollection.Metadata = []tfTypes.InputCollectionMetadatum{}
		if len(r.InputCollection.Metadata) > len(resp.InputCollection.Metadata) {
			r.InputCollection.Metadata = r.InputCollection.Metadata[:len(resp.InputCollection.Metadata)]
		}
		for metadataCount2, metadataItem2 := range resp.InputCollection.Metadata {
			var metadata2 tfTypes.InputCollectionMetadatum
			metadata2.Name = types.StringValue(metadataItem2.Name)
			metadata2.Value = types.StringValue(metadataItem2.Value)
			if metadataCount2+1 > len(r.InputCollection.Metadata) {
				r.InputCollection.Metadata = append(r.InputCollection.Metadata, metadata2)
			} else {
				r.InputCollection.Metadata[metadataCount2].Name = metadata2.Name
				r.InputCollection.Metadata[metadataCount2].Value = metadata2.Value
			}
		}
		r.InputCollection.Output = types.StringPointerValue(resp.InputCollection.Output)
		r.InputCollection.Pipeline = types.StringPointerValue(resp.InputCollection.Pipeline)
		if resp.InputCollection.Pq == nil {
			r.InputCollection.Pq = nil
		} else {
			r.InputCollection.Pq = &tfTypes.InputCollectionPq{}
			r.InputCollection.Pq.CommitFrequency = types.Float64PointerValue(resp.InputCollection.Pq.CommitFrequency)
			if resp.InputCollection.Pq.Compress != nil {
				r.InputCollection.Pq.Compress = types.StringValue(string(*resp.InputCollection.Pq.Compress))
			} else {
				r.InputCollection.Pq.Compress = types.StringNull()
			}
			r.InputCollection.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputCollection.Pq.MaxBufferSize)
			r.InputCollection.Pq.MaxFileSize = types.StringPointerValue(resp.InputCollection.Pq.MaxFileSize)
			r.InputCollection.Pq.MaxSize = types.StringPointerValue(resp.InputCollection.Pq.MaxSize)
			if resp.InputCollection.Pq.Mode != nil {
				r.InputCollection.Pq.Mode = types.StringValue(string(*resp.InputCollection.Pq.Mode))
			} else {
				r.InputCollection.Pq.Mode = types.StringNull()
			}
			r.InputCollection.Pq.Path = types.StringPointerValue(resp.InputCollection.Pq.Path)
		}
		r.InputCollection.PqEnabled = types.BoolPointerValue(resp.InputCollection.PqEnabled)
		if resp.InputCollection.Preprocess == nil {
			r.InputCollection.Preprocess = nil
		} else {
			r.InputCollection.Preprocess = &tfTypes.InputCollectionPreprocess{}
			r.InputCollection.Preprocess.Args = make([]types.String, 0, len(resp.InputCollection.Preprocess.Args))
			for _, v := range resp.InputCollection.Preprocess.Args {
				r.InputCollection.Preprocess.Args = append(r.InputCollection.Preprocess.Args, types.StringValue(v))
			}
			r.InputCollection.Preprocess.Command = types.StringPointerValue(resp.InputCollection.Preprocess.Command)
			r.InputCollection.Preprocess.Disabled = types.BoolPointerValue(resp.InputCollection.Preprocess.Disabled)
		}
		r.InputCollection.SendToRoutes = types.BoolPointerValue(resp.InputCollection.SendToRoutes)
		r.InputCollection.StaleChannelFlushMs = types.Float64PointerValue(resp.InputCollection.StaleChannelFlushMs)
		r.InputCollection.Streamtags = make([]types.String, 0, len(resp.InputCollection.Streamtags))
		for _, v := range resp.InputCollection.Streamtags {
			r.InputCollection.Streamtags = append(r.InputCollection.Streamtags, types.StringValue(v))
		}
		r.InputCollection.ThrottleRatePerSec = types.StringPointerValue(resp.InputCollection.ThrottleRatePerSec)
		if resp.InputCollection.Type != nil {
			r.InputCollection.Type = types.StringValue(string(*resp.InputCollection.Type))
		} else {
			r.InputCollection.Type = types.StringNull()
		}
	}
	if resp.InputConfluentCloud != nil {
		r.InputConfluentCloud = &tfTypes.InputConfluentCloud{}
		r.InputConfluentCloud.AuthenticationTimeout = types.Float64PointerValue(resp.InputConfluentCloud.AuthenticationTimeout)
		r.InputConfluentCloud.AutoCommitInterval = types.Float64PointerValue(resp.InputConfluentCloud.AutoCommitInterval)
		r.InputConfluentCloud.AutoCommitThreshold = types.Float64PointerValue(resp.InputConfluentCloud.AutoCommitThreshold)
		r.InputConfluentCloud.BackoffRate = types.Float64PointerValue(resp.InputConfluentCloud.BackoffRate)
		r.InputConfluentCloud.Brokers = make([]types.String, 0, len(resp.InputConfluentCloud.Brokers))
		for _, v := range resp.InputConfluentCloud.Brokers {
			r.InputConfluentCloud.Brokers = append(r.InputConfluentCloud.Brokers, types.StringValue(v))
		}
		r.InputConfluentCloud.Connections = []tfTypes.InputConfluentCloudConnection{}
		if len(r.InputConfluentCloud.Connections) > len(resp.InputConfluentCloud.Connections) {
			r.InputConfluentCloud.Connections = r.InputConfluentCloud.Connections[:len(resp.InputConfluentCloud.Connections)]
		}
		for connectionsCount3, connectionsItem3 := range resp.InputConfluentCloud.Connections {
			var connections3 tfTypes.InputConfluentCloudConnection
			connections3.Output = types.StringValue(connectionsItem3.Output)
			connections3.Pipeline = types.StringPointerValue(connectionsItem3.Pipeline)
			if connectionsCount3+1 > len(r.InputConfluentCloud.Connections) {
				r.InputConfluentCloud.Connections = append(r.InputConfluentCloud.Connections, connections3)
			} else {
				r.InputConfluentCloud.Connections[connectionsCount3].Output = connections3.Output
				r.InputConfluentCloud.Connections[connectionsCount3].Pipeline = connections3.Pipeline
			}
		}
		r.InputConfluentCloud.ConnectionTimeout = types.Float64PointerValue(resp.InputConfluentCloud.ConnectionTimeout)
		r.InputConfluentCloud.Description = types.StringPointerValue(resp.InputConfluentCloud.Description)
		r.InputConfluentCloud.Disabled = types.BoolPointerValue(resp.InputConfluentCloud.Disabled)
		r.InputConfluentCloud.Environment = types.StringPointerValue(resp.InputConfluentCloud.Environment)
		r.InputConfluentCloud.FromBeginning = types.BoolPointerValue(resp.InputConfluentCloud.FromBeginning)
		r.InputConfluentCloud.GroupID = types.StringPointerValue(resp.InputConfluentCloud.GroupID)
		r.InputConfluentCloud.HeartbeatInterval = types.Float64PointerValue(resp.InputConfluentCloud.HeartbeatInterval)
		r.InputConfluentCloud.ID = types.StringPointerValue(resp.InputConfluentCloud.ID)
		r.InputConfluentCloud.InitialBackoff = types.Float64PointerValue(resp.InputConfluentCloud.InitialBackoff)
		if resp.InputConfluentCloud.KafkaSchemaRegistry == nil {
			r.InputConfluentCloud.KafkaSchemaRegistry = nil
		} else {
			r.InputConfluentCloud.KafkaSchemaRegistry = &tfTypes.InputConfluentCloudKafkaSchemaRegistryAuthentication{}
			if resp.InputConfluentCloud.KafkaSchemaRegistry.Auth == nil {
				r.InputConfluentCloud.KafkaSchemaRegistry.Auth = nil
			} else {
				r.InputConfluentCloud.KafkaSchemaRegistry.Auth = &tfTypes.InputConfluentCloudAuth{}
				r.InputConfluentCloud.KafkaSchemaRegistry.Auth.CredentialsSecret = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.Auth.CredentialsSecret)
				r.InputConfluentCloud.KafkaSchemaRegistry.Auth.Disabled = types.BoolPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.Auth.Disabled)
			}
			r.InputConfluentCloud.KafkaSchemaRegistry.ConnectionTimeout = types.Float64PointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.ConnectionTimeout)
			r.InputConfluentCloud.KafkaSchemaRegistry.Disabled = types.BoolPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.Disabled)
			r.InputConfluentCloud.KafkaSchemaRegistry.MaxRetries = types.Float64PointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.MaxRetries)
			r.InputConfluentCloud.KafkaSchemaRegistry.RequestTimeout = types.Float64PointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.RequestTimeout)
			r.InputConfluentCloud.KafkaSchemaRegistry.SchemaRegistryURL = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.SchemaRegistryURL)
			if resp.InputConfluentCloud.KafkaSchemaRegistry.TLS == nil {
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS = nil
			} else {
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS = &tfTypes.InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide{}
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.CaPath = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.CaPath)
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.CertificateName = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.CertificateName)
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.CertPath = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.CertPath)
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.Disabled = types.BoolPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.Disabled)
				if resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.MaxVersion != nil {
					r.InputConfluentCloud.KafkaSchemaRegistry.TLS.MaxVersion = types.StringValue(string(*resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.MaxVersion))
				} else {
					r.InputConfluentCloud.KafkaSchemaRegistry.TLS.MaxVersion = types.StringNull()
				}
				if resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.MinVersion != nil {
					r.InputConfluentCloud.KafkaSchemaRegistry.TLS.MinVersion = types.StringValue(string(*resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.MinVersion))
				} else {
					r.InputConfluentCloud.KafkaSchemaRegistry.TLS.MinVersion = types.StringNull()
				}
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.Passphrase = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.Passphrase)
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.PrivKeyPath = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.PrivKeyPath)
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.RejectUnauthorized)
				r.InputConfluentCloud.KafkaSchemaRegistry.TLS.Servername = types.StringPointerValue(resp.InputConfluentCloud.KafkaSchemaRegistry.TLS.Servername)
			}
		}
		r.InputConfluentCloud.MaxBackOff = types.Float64PointerValue(resp.InputConfluentCloud.MaxBackOff)
		r.InputConfluentCloud.MaxBytes = types.Float64PointerValue(resp.InputConfluentCloud.MaxBytes)
		r.InputConfluentCloud.MaxBytesPerPartition = types.Float64PointerValue(resp.InputConfluentCloud.MaxBytesPerPartition)
		r.InputConfluentCloud.MaxRetries = types.Float64PointerValue(resp.InputConfluentCloud.MaxRetries)
		r.InputConfluentCloud.MaxSocketErrors = types.Float64PointerValue(resp.InputConfluentCloud.MaxSocketErrors)
		r.InputConfluentCloud.Metadata = []tfTypes.InputConfluentCloudMetadatum{}
		if len(r.InputConfluentCloud.Metadata) > len(resp.InputConfluentCloud.Metadata) {
			r.InputConfluentCloud.Metadata = r.InputConfluentCloud.Metadata[:len(resp.InputConfluentCloud.Metadata)]
		}
		for metadataCount3, metadataItem3 := range resp.InputConfluentCloud.Metadata {
			var metadata3 tfTypes.InputConfluentCloudMetadatum
			metadata3.Name = types.StringValue(metadataItem3.Name)
			metadata3.Value = types.StringValue(metadataItem3.Value)
			if metadataCount3+1 > len(r.InputConfluentCloud.Metadata) {
				r.InputConfluentCloud.Metadata = append(r.InputConfluentCloud.Metadata, metadata3)
			} else {
				r.InputConfluentCloud.Metadata[metadataCount3].Name = metadata3.Name
				r.InputConfluentCloud.Metadata[metadataCount3].Value = metadata3.Value
			}
		}
		r.InputConfluentCloud.Pipeline = types.StringPointerValue(resp.InputConfluentCloud.Pipeline)
		if resp.InputConfluentCloud.Pq == nil {
			r.InputConfluentCloud.Pq = nil
		} else {
			r.InputConfluentCloud.Pq = &tfTypes.InputConfluentCloudPq{}
			r.InputConfluentCloud.Pq.CommitFrequency = types.Float64PointerValue(resp.InputConfluentCloud.Pq.CommitFrequency)
			if resp.InputConfluentCloud.Pq.Compress != nil {
				r.InputConfluentCloud.Pq.Compress = types.StringValue(string(*resp.InputConfluentCloud.Pq.Compress))
			} else {
				r.InputConfluentCloud.Pq.Compress = types.StringNull()
			}
			r.InputConfluentCloud.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputConfluentCloud.Pq.MaxBufferSize)
			r.InputConfluentCloud.Pq.MaxFileSize = types.StringPointerValue(resp.InputConfluentCloud.Pq.MaxFileSize)
			r.InputConfluentCloud.Pq.MaxSize = types.StringPointerValue(resp.InputConfluentCloud.Pq.MaxSize)
			if resp.InputConfluentCloud.Pq.Mode != nil {
				r.InputConfluentCloud.Pq.Mode = types.StringValue(string(*resp.InputConfluentCloud.Pq.Mode))
			} else {
				r.InputConfluentCloud.Pq.Mode = types.StringNull()
			}
			r.InputConfluentCloud.Pq.Path = types.StringPointerValue(resp.InputConfluentCloud.Pq.Path)
		}
		r.InputConfluentCloud.PqEnabled = types.BoolPointerValue(resp.InputConfluentCloud.PqEnabled)
		r.InputConfluentCloud.ReauthenticationThreshold = types.Float64PointerValue(resp.InputConfluentCloud.ReauthenticationThreshold)
		r.InputConfluentCloud.RebalanceTimeout = types.Float64PointerValue(resp.InputConfluentCloud.RebalanceTimeout)
		r.InputConfluentCloud.RequestTimeout = types.Float64PointerValue(resp.InputConfluentCloud.RequestTimeout)
		if resp.InputConfluentCloud.Sasl == nil {
			r.InputConfluentCloud.Sasl = nil
		} else {
			r.InputConfluentCloud.Sasl = &tfTypes.InputConfluentCloudAuthentication{}
			r.InputConfluentCloud.Sasl.Disabled = types.BoolPointerValue(resp.InputConfluentCloud.Sasl.Disabled)
			if resp.InputConfluentCloud.Sasl.Mechanism != nil {
				r.InputConfluentCloud.Sasl.Mechanism = types.StringValue(string(*resp.InputConfluentCloud.Sasl.Mechanism))
			} else {
				r.InputConfluentCloud.Sasl.Mechanism = types.StringNull()
			}
		}
		r.InputConfluentCloud.SendToRoutes = types.BoolPointerValue(resp.InputConfluentCloud.SendToRoutes)
		r.InputConfluentCloud.SessionTimeout = types.Float64PointerValue(resp.InputConfluentCloud.SessionTimeout)
		r.InputConfluentCloud.Streamtags = make([]types.String, 0, len(resp.InputConfluentCloud.Streamtags))
		for _, v := range resp.InputConfluentCloud.Streamtags {
			r.InputConfluentCloud.Streamtags = append(r.InputConfluentCloud.Streamtags, types.StringValue(v))
		}
		if resp.InputConfluentCloud.TLS == nil {
			r.InputConfluentCloud.TLS = nil
		} else {
			r.InputConfluentCloud.TLS = &tfTypes.InputConfluentCloudTLSSettingsClientSide{}
			r.InputConfluentCloud.TLS.CaPath = types.StringPointerValue(resp.InputConfluentCloud.TLS.CaPath)
			r.InputConfluentCloud.TLS.CertificateName = types.StringPointerValue(resp.InputConfluentCloud.TLS.CertificateName)
			r.InputConfluentCloud.TLS.CertPath = types.StringPointerValue(resp.InputConfluentCloud.TLS.CertPath)
			r.InputConfluentCloud.TLS.Disabled = types.BoolPointerValue(resp.InputConfluentCloud.TLS.Disabled)
			if resp.InputConfluentCloud.TLS.MaxVersion != nil {
				r.InputConfluentCloud.TLS.MaxVersion = types.StringValue(string(*resp.InputConfluentCloud.TLS.MaxVersion))
			} else {
				r.InputConfluentCloud.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputConfluentCloud.TLS.MinVersion != nil {
				r.InputConfluentCloud.TLS.MinVersion = types.StringValue(string(*resp.InputConfluentCloud.TLS.MinVersion))
			} else {
				r.InputConfluentCloud.TLS.MinVersion = types.StringNull()
			}
			r.InputConfluentCloud.TLS.Passphrase = types.StringPointerValue(resp.InputConfluentCloud.TLS.Passphrase)
			r.InputConfluentCloud.TLS.PrivKeyPath = types.StringPointerValue(resp.InputConfluentCloud.TLS.PrivKeyPath)
			r.InputConfluentCloud.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputConfluentCloud.TLS.RejectUnauthorized)
			r.InputConfluentCloud.TLS.Servername = types.StringPointerValue(resp.InputConfluentCloud.TLS.Servername)
		}
		r.InputConfluentCloud.Topics = make([]types.String, 0, len(resp.InputConfluentCloud.Topics))
		for _, v := range resp.InputConfluentCloud.Topics {
			r.InputConfluentCloud.Topics = append(r.InputConfluentCloud.Topics, types.StringValue(v))
		}
		if resp.InputConfluentCloud.Type != nil {
			r.InputConfluentCloud.Type = types.StringValue(string(*resp.InputConfluentCloud.Type))
		} else {
			r.InputConfluentCloud.Type = types.StringNull()
		}
	}
	if resp.InputCribl != nil {
		r.InputCribl = &tfTypes.InputCribl{}
		r.InputCribl.Connections = []tfTypes.InputCriblConnection{}
		if len(r.InputCribl.Connections) > len(resp.InputCribl.Connections) {
			r.InputCribl.Connections = r.InputCribl.Connections[:len(resp.InputCribl.Connections)]
		}
		for connectionsCount4, connectionsItem4 := range resp.InputCribl.Connections {
			var connections4 tfTypes.InputCriblConnection
			connections4.Output = types.StringValue(connectionsItem4.Output)
			connections4.Pipeline = types.StringPointerValue(connectionsItem4.Pipeline)
			if connectionsCount4+1 > len(r.InputCribl.Connections) {
				r.InputCribl.Connections = append(r.InputCribl.Connections, connections4)
			} else {
				r.InputCribl.Connections[connectionsCount4].Output = connections4.Output
				r.InputCribl.Connections[connectionsCount4].Pipeline = connections4.Pipeline
			}
		}
		r.InputCribl.Description = types.StringPointerValue(resp.InputCribl.Description)
		r.InputCribl.Disabled = types.BoolPointerValue(resp.InputCribl.Disabled)
		r.InputCribl.Environment = types.StringPointerValue(resp.InputCribl.Environment)
		r.InputCribl.Filter = types.StringPointerValue(resp.InputCribl.Filter)
		r.InputCribl.ID = types.StringValue(resp.InputCribl.ID)
		r.InputCribl.Metadata = []tfTypes.InputCriblMetadatum{}
		if len(r.InputCribl.Metadata) > len(resp.InputCribl.Metadata) {
			r.InputCribl.Metadata = r.InputCribl.Metadata[:len(resp.InputCribl.Metadata)]
		}
		for metadataCount4, metadataItem4 := range resp.InputCribl.Metadata {
			var metadata4 tfTypes.InputCriblMetadatum
			metadata4.Name = types.StringValue(metadataItem4.Name)
			metadata4.Value = types.StringValue(metadataItem4.Value)
			if metadataCount4+1 > len(r.InputCribl.Metadata) {
				r.InputCribl.Metadata = append(r.InputCribl.Metadata, metadata4)
			} else {
				r.InputCribl.Metadata[metadataCount4].Name = metadata4.Name
				r.InputCribl.Metadata[metadataCount4].Value = metadata4.Value
			}
		}
		r.InputCribl.Pipeline = types.StringPointerValue(resp.InputCribl.Pipeline)
		if resp.InputCribl.Pq == nil {
			r.InputCribl.Pq = nil
		} else {
			r.InputCribl.Pq = &tfTypes.InputCriblPq{}
			r.InputCribl.Pq.CommitFrequency = types.Float64PointerValue(resp.InputCribl.Pq.CommitFrequency)
			if resp.InputCribl.Pq.Compress != nil {
				r.InputCribl.Pq.Compress = types.StringValue(string(*resp.InputCribl.Pq.Compress))
			} else {
				r.InputCribl.Pq.Compress = types.StringNull()
			}
			r.InputCribl.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputCribl.Pq.MaxBufferSize)
			r.InputCribl.Pq.MaxFileSize = types.StringPointerValue(resp.InputCribl.Pq.MaxFileSize)
			r.InputCribl.Pq.MaxSize = types.StringPointerValue(resp.InputCribl.Pq.MaxSize)
			if resp.InputCribl.Pq.Mode != nil {
				r.InputCribl.Pq.Mode = types.StringValue(string(*resp.InputCribl.Pq.Mode))
			} else {
				r.InputCribl.Pq.Mode = types.StringNull()
			}
			r.InputCribl.Pq.Path = types.StringPointerValue(resp.InputCribl.Pq.Path)
		}
		r.InputCribl.PqEnabled = types.BoolPointerValue(resp.InputCribl.PqEnabled)
		r.InputCribl.SendToRoutes = types.BoolPointerValue(resp.InputCribl.SendToRoutes)
		r.InputCribl.Streamtags = make([]types.String, 0, len(resp.InputCribl.Streamtags))
		for _, v := range resp.InputCribl.Streamtags {
			r.InputCribl.Streamtags = append(r.InputCribl.Streamtags, types.StringValue(v))
		}
		r.InputCribl.Type = types.StringValue(string(resp.InputCribl.Type))
	}
	if resp.InputCriblHTTP != nil {
		r.InputCriblHTTP = &tfTypes.InputCriblHTTP{}
		r.InputCriblHTTP.ActivityLogSampleRate = types.Float64PointerValue(resp.InputCriblHTTP.ActivityLogSampleRate)
		r.InputCriblHTTP.AuthTokens = make([]types.String, 0, len(resp.InputCriblHTTP.AuthTokens))
		for _, v := range resp.InputCriblHTTP.AuthTokens {
			r.InputCriblHTTP.AuthTokens = append(r.InputCriblHTTP.AuthTokens, types.StringValue(v))
		}
		r.InputCriblHTTP.CaptureHeaders = types.BoolPointerValue(resp.InputCriblHTTP.CaptureHeaders)
		r.InputCriblHTTP.Connections = []tfTypes.InputCriblHTTPConnection{}
		if len(r.InputCriblHTTP.Connections) > len(resp.InputCriblHTTP.Connections) {
			r.InputCriblHTTP.Connections = r.InputCriblHTTP.Connections[:len(resp.InputCriblHTTP.Connections)]
		}
		for connectionsCount5, connectionsItem5 := range resp.InputCriblHTTP.Connections {
			var connections5 tfTypes.InputCriblHTTPConnection
			connections5.Output = types.StringValue(connectionsItem5.Output)
			connections5.Pipeline = types.StringPointerValue(connectionsItem5.Pipeline)
			if connectionsCount5+1 > len(r.InputCriblHTTP.Connections) {
				r.InputCriblHTTP.Connections = append(r.InputCriblHTTP.Connections, connections5)
			} else {
				r.InputCriblHTTP.Connections[connectionsCount5].Output = connections5.Output
				r.InputCriblHTTP.Connections[connectionsCount5].Pipeline = connections5.Pipeline
			}
		}
		r.InputCriblHTTP.Description = types.StringPointerValue(resp.InputCriblHTTP.Description)
		r.InputCriblHTTP.Disabled = types.BoolPointerValue(resp.InputCriblHTTP.Disabled)
		r.InputCriblHTTP.EnableHealthCheck = types.BoolPointerValue(resp.InputCriblHTTP.EnableHealthCheck)
		r.InputCriblHTTP.EnableProxyHeader = types.BoolPointerValue(resp.InputCriblHTTP.EnableProxyHeader)
		r.InputCriblHTTP.Environment = types.StringPointerValue(resp.InputCriblHTTP.Environment)
		r.InputCriblHTTP.Host = types.StringPointerValue(resp.InputCriblHTTP.Host)
		r.InputCriblHTTP.ID = types.StringPointerValue(resp.InputCriblHTTP.ID)
		r.InputCriblHTTP.IPAllowlistRegex = types.StringPointerValue(resp.InputCriblHTTP.IPAllowlistRegex)
		r.InputCriblHTTP.IPDenylistRegex = types.StringPointerValue(resp.InputCriblHTTP.IPDenylistRegex)
		r.InputCriblHTTP.KeepAliveTimeout = types.Float64PointerValue(resp.InputCriblHTTP.KeepAliveTimeout)
		r.InputCriblHTTP.MaxActiveReq = types.Float64PointerValue(resp.InputCriblHTTP.MaxActiveReq)
		r.InputCriblHTTP.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputCriblHTTP.MaxRequestsPerSocket)
		r.InputCriblHTTP.Metadata = []tfTypes.InputCriblHTTPMetadatum{}
		if len(r.InputCriblHTTP.Metadata) > len(resp.InputCriblHTTP.Metadata) {
			r.InputCriblHTTP.Metadata = r.InputCriblHTTP.Metadata[:len(resp.InputCriblHTTP.Metadata)]
		}
		for metadataCount5, metadataItem5 := range resp.InputCriblHTTP.Metadata {
			var metadata5 tfTypes.InputCriblHTTPMetadatum
			metadata5.Name = types.StringValue(metadataItem5.Name)
			metadata5.Value = types.StringValue(metadataItem5.Value)
			if metadataCount5+1 > len(r.InputCriblHTTP.Metadata) {
				r.InputCriblHTTP.Metadata = append(r.InputCriblHTTP.Metadata, metadata5)
			} else {
				r.InputCriblHTTP.Metadata[metadataCount5].Name = metadata5.Name
				r.InputCriblHTTP.Metadata[metadataCount5].Value = metadata5.Value
			}
		}
		r.InputCriblHTTP.Pipeline = types.StringPointerValue(resp.InputCriblHTTP.Pipeline)
		r.InputCriblHTTP.Port = types.Float64Value(resp.InputCriblHTTP.Port)
		if resp.InputCriblHTTP.Pq == nil {
			r.InputCriblHTTP.Pq = nil
		} else {
			r.InputCriblHTTP.Pq = &tfTypes.InputCriblHTTPPq{}
			r.InputCriblHTTP.Pq.CommitFrequency = types.Float64PointerValue(resp.InputCriblHTTP.Pq.CommitFrequency)
			if resp.InputCriblHTTP.Pq.Compress != nil {
				r.InputCriblHTTP.Pq.Compress = types.StringValue(string(*resp.InputCriblHTTP.Pq.Compress))
			} else {
				r.InputCriblHTTP.Pq.Compress = types.StringNull()
			}
			r.InputCriblHTTP.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputCriblHTTP.Pq.MaxBufferSize)
			r.InputCriblHTTP.Pq.MaxFileSize = types.StringPointerValue(resp.InputCriblHTTP.Pq.MaxFileSize)
			r.InputCriblHTTP.Pq.MaxSize = types.StringPointerValue(resp.InputCriblHTTP.Pq.MaxSize)
			if resp.InputCriblHTTP.Pq.Mode != nil {
				r.InputCriblHTTP.Pq.Mode = types.StringValue(string(*resp.InputCriblHTTP.Pq.Mode))
			} else {
				r.InputCriblHTTP.Pq.Mode = types.StringNull()
			}
			r.InputCriblHTTP.Pq.Path = types.StringPointerValue(resp.InputCriblHTTP.Pq.Path)
		}
		r.InputCriblHTTP.PqEnabled = types.BoolPointerValue(resp.InputCriblHTTP.PqEnabled)
		r.InputCriblHTTP.RequestTimeout = types.Float64PointerValue(resp.InputCriblHTTP.RequestTimeout)
		r.InputCriblHTTP.SendToRoutes = types.BoolPointerValue(resp.InputCriblHTTP.SendToRoutes)
		r.InputCriblHTTP.SocketTimeout = types.Float64PointerValue(resp.InputCriblHTTP.SocketTimeout)
		r.InputCriblHTTP.Streamtags = make([]types.String, 0, len(resp.InputCriblHTTP.Streamtags))
		for _, v := range resp.InputCriblHTTP.Streamtags {
			r.InputCriblHTTP.Streamtags = append(r.InputCriblHTTP.Streamtags, types.StringValue(v))
		}
		if resp.InputCriblHTTP.TLS == nil {
			r.InputCriblHTTP.TLS = nil
		} else {
			r.InputCriblHTTP.TLS = &tfTypes.InputCriblHTTPTLSSettingsServerSide{}
			r.InputCriblHTTP.TLS.CaPath = types.StringPointerValue(resp.InputCriblHTTP.TLS.CaPath)
			r.InputCriblHTTP.TLS.CertificateName = types.StringPointerValue(resp.InputCriblHTTP.TLS.CertificateName)
			r.InputCriblHTTP.TLS.CertPath = types.StringPointerValue(resp.InputCriblHTTP.TLS.CertPath)
			if resp.InputCriblHTTP.TLS.CommonNameRegex == nil {
				r.InputCriblHTTP.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult1, _ := json.Marshal(resp.InputCriblHTTP.TLS.CommonNameRegex)
				r.InputCriblHTTP.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult1))
			}
			r.InputCriblHTTP.TLS.Disabled = types.BoolPointerValue(resp.InputCriblHTTP.TLS.Disabled)
			if resp.InputCriblHTTP.TLS.MaxVersion != nil {
				r.InputCriblHTTP.TLS.MaxVersion = types.StringValue(string(*resp.InputCriblHTTP.TLS.MaxVersion))
			} else {
				r.InputCriblHTTP.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputCriblHTTP.TLS.MinVersion != nil {
				r.InputCriblHTTP.TLS.MinVersion = types.StringValue(string(*resp.InputCriblHTTP.TLS.MinVersion))
			} else {
				r.InputCriblHTTP.TLS.MinVersion = types.StringNull()
			}
			r.InputCriblHTTP.TLS.Passphrase = types.StringPointerValue(resp.InputCriblHTTP.TLS.Passphrase)
			r.InputCriblHTTP.TLS.PrivKeyPath = types.StringPointerValue(resp.InputCriblHTTP.TLS.PrivKeyPath)
			if resp.InputCriblHTTP.TLS.RejectUnauthorized == nil {
				r.InputCriblHTTP.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult1, _ := json.Marshal(resp.InputCriblHTTP.TLS.RejectUnauthorized)
				r.InputCriblHTTP.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult1))
			}
			r.InputCriblHTTP.TLS.RequestCert = types.BoolPointerValue(resp.InputCriblHTTP.TLS.RequestCert)
		}
		if resp.InputCriblHTTP.Type != nil {
			r.InputCriblHTTP.Type = types.StringValue(string(*resp.InputCriblHTTP.Type))
		} else {
			r.InputCriblHTTP.Type = types.StringNull()
		}
	}
	if resp.InputCriblLakeHTTP != nil {
		r.InputCriblLakeHTTP = &tfTypes.InputCriblLakeHTTP{}
		r.InputCriblLakeHTTP.ActivityLogSampleRate = types.Float64PointerValue(resp.InputCriblLakeHTTP.ActivityLogSampleRate)
		r.InputCriblLakeHTTP.AuthTokens = make([]types.String, 0, len(resp.InputCriblLakeHTTP.AuthTokens))
		for _, v := range resp.InputCriblLakeHTTP.AuthTokens {
			r.InputCriblLakeHTTP.AuthTokens = append(r.InputCriblLakeHTTP.AuthTokens, types.StringValue(v))
		}
		r.InputCriblLakeHTTP.CaptureHeaders = types.BoolPointerValue(resp.InputCriblLakeHTTP.CaptureHeaders)
		r.InputCriblLakeHTTP.Connections = []tfTypes.InputCriblLakeHTTPConnection{}
		if len(r.InputCriblLakeHTTP.Connections) > len(resp.InputCriblLakeHTTP.Connections) {
			r.InputCriblLakeHTTP.Connections = r.InputCriblLakeHTTP.Connections[:len(resp.InputCriblLakeHTTP.Connections)]
		}
		for connectionsCount6, connectionsItem6 := range resp.InputCriblLakeHTTP.Connections {
			var connections6 tfTypes.InputCriblLakeHTTPConnection
			connections6.Output = types.StringValue(connectionsItem6.Output)
			connections6.Pipeline = types.StringPointerValue(connectionsItem6.Pipeline)
			if connectionsCount6+1 > len(r.InputCriblLakeHTTP.Connections) {
				r.InputCriblLakeHTTP.Connections = append(r.InputCriblLakeHTTP.Connections, connections6)
			} else {
				r.InputCriblLakeHTTP.Connections[connectionsCount6].Output = connections6.Output
				r.InputCriblLakeHTTP.Connections[connectionsCount6].Pipeline = connections6.Pipeline
			}
		}
		r.InputCriblLakeHTTP.Description = types.StringPointerValue(resp.InputCriblLakeHTTP.Description)
		r.InputCriblLakeHTTP.Disabled = types.BoolPointerValue(resp.InputCriblLakeHTTP.Disabled)
		r.InputCriblLakeHTTP.EnableHealthCheck = types.BoolPointerValue(resp.InputCriblLakeHTTP.EnableHealthCheck)
		r.InputCriblLakeHTTP.EnableProxyHeader = types.BoolPointerValue(resp.InputCriblLakeHTTP.EnableProxyHeader)
		r.InputCriblLakeHTTP.Environment = types.StringPointerValue(resp.InputCriblLakeHTTP.Environment)
		r.InputCriblLakeHTTP.Host = types.StringPointerValue(resp.InputCriblLakeHTTP.Host)
		r.InputCriblLakeHTTP.ID = types.StringPointerValue(resp.InputCriblLakeHTTP.ID)
		r.InputCriblLakeHTTP.IPAllowlistRegex = types.StringPointerValue(resp.InputCriblLakeHTTP.IPAllowlistRegex)
		r.InputCriblLakeHTTP.IPDenylistRegex = types.StringPointerValue(resp.InputCriblLakeHTTP.IPDenylistRegex)
		r.InputCriblLakeHTTP.KeepAliveTimeout = types.Float64PointerValue(resp.InputCriblLakeHTTP.KeepAliveTimeout)
		r.InputCriblLakeHTTP.MaxActiveReq = types.Float64PointerValue(resp.InputCriblLakeHTTP.MaxActiveReq)
		r.InputCriblLakeHTTP.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputCriblLakeHTTP.MaxRequestsPerSocket)
		r.InputCriblLakeHTTP.Metadata = []tfTypes.InputCriblLakeHTTPMetadatum{}
		if len(r.InputCriblLakeHTTP.Metadata) > len(resp.InputCriblLakeHTTP.Metadata) {
			r.InputCriblLakeHTTP.Metadata = r.InputCriblLakeHTTP.Metadata[:len(resp.InputCriblLakeHTTP.Metadata)]
		}
		for metadataCount6, metadataItem6 := range resp.InputCriblLakeHTTP.Metadata {
			var metadata6 tfTypes.InputCriblLakeHTTPMetadatum
			metadata6.Name = types.StringValue(metadataItem6.Name)
			metadata6.Value = types.StringValue(metadataItem6.Value)
			if metadataCount6+1 > len(r.InputCriblLakeHTTP.Metadata) {
				r.InputCriblLakeHTTP.Metadata = append(r.InputCriblLakeHTTP.Metadata, metadata6)
			} else {
				r.InputCriblLakeHTTP.Metadata[metadataCount6].Name = metadata6.Name
				r.InputCriblLakeHTTP.Metadata[metadataCount6].Value = metadata6.Value
			}
		}
		r.InputCriblLakeHTTP.Pipeline = types.StringPointerValue(resp.InputCriblLakeHTTP.Pipeline)
		r.InputCriblLakeHTTP.Port = types.Float64Value(resp.InputCriblLakeHTTP.Port)
		if resp.InputCriblLakeHTTP.Pq == nil {
			r.InputCriblLakeHTTP.Pq = nil
		} else {
			r.InputCriblLakeHTTP.Pq = &tfTypes.InputCriblLakeHTTPPq{}
			r.InputCriblLakeHTTP.Pq.CommitFrequency = types.Float64PointerValue(resp.InputCriblLakeHTTP.Pq.CommitFrequency)
			if resp.InputCriblLakeHTTP.Pq.Compress != nil {
				r.InputCriblLakeHTTP.Pq.Compress = types.StringValue(string(*resp.InputCriblLakeHTTP.Pq.Compress))
			} else {
				r.InputCriblLakeHTTP.Pq.Compress = types.StringNull()
			}
			r.InputCriblLakeHTTP.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputCriblLakeHTTP.Pq.MaxBufferSize)
			r.InputCriblLakeHTTP.Pq.MaxFileSize = types.StringPointerValue(resp.InputCriblLakeHTTP.Pq.MaxFileSize)
			r.InputCriblLakeHTTP.Pq.MaxSize = types.StringPointerValue(resp.InputCriblLakeHTTP.Pq.MaxSize)
			if resp.InputCriblLakeHTTP.Pq.Mode != nil {
				r.InputCriblLakeHTTP.Pq.Mode = types.StringValue(string(*resp.InputCriblLakeHTTP.Pq.Mode))
			} else {
				r.InputCriblLakeHTTP.Pq.Mode = types.StringNull()
			}
			r.InputCriblLakeHTTP.Pq.Path = types.StringPointerValue(resp.InputCriblLakeHTTP.Pq.Path)
		}
		r.InputCriblLakeHTTP.PqEnabled = types.BoolPointerValue(resp.InputCriblLakeHTTP.PqEnabled)
		r.InputCriblLakeHTTP.RequestTimeout = types.Float64PointerValue(resp.InputCriblLakeHTTP.RequestTimeout)
		r.InputCriblLakeHTTP.SendToRoutes = types.BoolPointerValue(resp.InputCriblLakeHTTP.SendToRoutes)
		r.InputCriblLakeHTTP.SocketTimeout = types.Float64PointerValue(resp.InputCriblLakeHTTP.SocketTimeout)
		r.InputCriblLakeHTTP.Streamtags = make([]types.String, 0, len(resp.InputCriblLakeHTTP.Streamtags))
		for _, v := range resp.InputCriblLakeHTTP.Streamtags {
			r.InputCriblLakeHTTP.Streamtags = append(r.InputCriblLakeHTTP.Streamtags, types.StringValue(v))
		}
		if resp.InputCriblLakeHTTP.TLS == nil {
			r.InputCriblLakeHTTP.TLS = nil
		} else {
			r.InputCriblLakeHTTP.TLS = &tfTypes.InputCriblLakeHTTPTLSSettingsServerSide{}
			r.InputCriblLakeHTTP.TLS.CaPath = types.StringPointerValue(resp.InputCriblLakeHTTP.TLS.CaPath)
			r.InputCriblLakeHTTP.TLS.CertificateName = types.StringPointerValue(resp.InputCriblLakeHTTP.TLS.CertificateName)
			r.InputCriblLakeHTTP.TLS.CertPath = types.StringPointerValue(resp.InputCriblLakeHTTP.TLS.CertPath)
			if resp.InputCriblLakeHTTP.TLS.CommonNameRegex == nil {
				r.InputCriblLakeHTTP.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult2, _ := json.Marshal(resp.InputCriblLakeHTTP.TLS.CommonNameRegex)
				r.InputCriblLakeHTTP.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult2))
			}
			r.InputCriblLakeHTTP.TLS.Disabled = types.BoolPointerValue(resp.InputCriblLakeHTTP.TLS.Disabled)
			if resp.InputCriblLakeHTTP.TLS.MaxVersion != nil {
				r.InputCriblLakeHTTP.TLS.MaxVersion = types.StringValue(string(*resp.InputCriblLakeHTTP.TLS.MaxVersion))
			} else {
				r.InputCriblLakeHTTP.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputCriblLakeHTTP.TLS.MinVersion != nil {
				r.InputCriblLakeHTTP.TLS.MinVersion = types.StringValue(string(*resp.InputCriblLakeHTTP.TLS.MinVersion))
			} else {
				r.InputCriblLakeHTTP.TLS.MinVersion = types.StringNull()
			}
			r.InputCriblLakeHTTP.TLS.Passphrase = types.StringPointerValue(resp.InputCriblLakeHTTP.TLS.Passphrase)
			r.InputCriblLakeHTTP.TLS.PrivKeyPath = types.StringPointerValue(resp.InputCriblLakeHTTP.TLS.PrivKeyPath)
			if resp.InputCriblLakeHTTP.TLS.RejectUnauthorized == nil {
				r.InputCriblLakeHTTP.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult2, _ := json.Marshal(resp.InputCriblLakeHTTP.TLS.RejectUnauthorized)
				r.InputCriblLakeHTTP.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult2))
			}
			r.InputCriblLakeHTTP.TLS.RequestCert = types.BoolPointerValue(resp.InputCriblLakeHTTP.TLS.RequestCert)
		}
		if resp.InputCriblLakeHTTP.Type != nil {
			r.InputCriblLakeHTTP.Type = types.StringValue(string(*resp.InputCriblLakeHTTP.Type))
		} else {
			r.InputCriblLakeHTTP.Type = types.StringNull()
		}
	}
	if resp.InputCriblmetrics != nil {
		r.InputCriblmetrics = &tfTypes.InputCriblmetrics{}
		r.InputCriblmetrics.Connections = []tfTypes.InputCriblmetricsConnection{}
		if len(r.InputCriblmetrics.Connections) > len(resp.InputCriblmetrics.Connections) {
			r.InputCriblmetrics.Connections = r.InputCriblmetrics.Connections[:len(resp.InputCriblmetrics.Connections)]
		}
		for connectionsCount7, connectionsItem7 := range resp.InputCriblmetrics.Connections {
			var connections7 tfTypes.InputCriblmetricsConnection
			connections7.Output = types.StringValue(connectionsItem7.Output)
			connections7.Pipeline = types.StringPointerValue(connectionsItem7.Pipeline)
			if connectionsCount7+1 > len(r.InputCriblmetrics.Connections) {
				r.InputCriblmetrics.Connections = append(r.InputCriblmetrics.Connections, connections7)
			} else {
				r.InputCriblmetrics.Connections[connectionsCount7].Output = connections7.Output
				r.InputCriblmetrics.Connections[connectionsCount7].Pipeline = connections7.Pipeline
			}
		}
		r.InputCriblmetrics.Description = types.StringPointerValue(resp.InputCriblmetrics.Description)
		r.InputCriblmetrics.Disabled = types.BoolPointerValue(resp.InputCriblmetrics.Disabled)
		r.InputCriblmetrics.Environment = types.StringPointerValue(resp.InputCriblmetrics.Environment)
		r.InputCriblmetrics.FullFidelity = types.BoolPointerValue(resp.InputCriblmetrics.FullFidelity)
		r.InputCriblmetrics.ID = types.StringValue(resp.InputCriblmetrics.ID)
		r.InputCriblmetrics.Metadata = []tfTypes.InputCriblmetricsMetadatum{}
		if len(r.InputCriblmetrics.Metadata) > len(resp.InputCriblmetrics.Metadata) {
			r.InputCriblmetrics.Metadata = r.InputCriblmetrics.Metadata[:len(resp.InputCriblmetrics.Metadata)]
		}
		for metadataCount7, metadataItem7 := range resp.InputCriblmetrics.Metadata {
			var metadata7 tfTypes.InputCriblmetricsMetadatum
			metadata7.Name = types.StringValue(metadataItem7.Name)
			metadata7.Value = types.StringValue(metadataItem7.Value)
			if metadataCount7+1 > len(r.InputCriblmetrics.Metadata) {
				r.InputCriblmetrics.Metadata = append(r.InputCriblmetrics.Metadata, metadata7)
			} else {
				r.InputCriblmetrics.Metadata[metadataCount7].Name = metadata7.Name
				r.InputCriblmetrics.Metadata[metadataCount7].Value = metadata7.Value
			}
		}
		r.InputCriblmetrics.Pipeline = types.StringPointerValue(resp.InputCriblmetrics.Pipeline)
		if resp.InputCriblmetrics.Pq == nil {
			r.InputCriblmetrics.Pq = nil
		} else {
			r.InputCriblmetrics.Pq = &tfTypes.InputCriblmetricsPq{}
			r.InputCriblmetrics.Pq.CommitFrequency = types.Float64PointerValue(resp.InputCriblmetrics.Pq.CommitFrequency)
			if resp.InputCriblmetrics.Pq.Compress != nil {
				r.InputCriblmetrics.Pq.Compress = types.StringValue(string(*resp.InputCriblmetrics.Pq.Compress))
			} else {
				r.InputCriblmetrics.Pq.Compress = types.StringNull()
			}
			r.InputCriblmetrics.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputCriblmetrics.Pq.MaxBufferSize)
			r.InputCriblmetrics.Pq.MaxFileSize = types.StringPointerValue(resp.InputCriblmetrics.Pq.MaxFileSize)
			r.InputCriblmetrics.Pq.MaxSize = types.StringPointerValue(resp.InputCriblmetrics.Pq.MaxSize)
			if resp.InputCriblmetrics.Pq.Mode != nil {
				r.InputCriblmetrics.Pq.Mode = types.StringValue(string(*resp.InputCriblmetrics.Pq.Mode))
			} else {
				r.InputCriblmetrics.Pq.Mode = types.StringNull()
			}
			r.InputCriblmetrics.Pq.Path = types.StringPointerValue(resp.InputCriblmetrics.Pq.Path)
		}
		r.InputCriblmetrics.PqEnabled = types.BoolPointerValue(resp.InputCriblmetrics.PqEnabled)
		r.InputCriblmetrics.Prefix = types.StringPointerValue(resp.InputCriblmetrics.Prefix)
		r.InputCriblmetrics.SendToRoutes = types.BoolPointerValue(resp.InputCriblmetrics.SendToRoutes)
		r.InputCriblmetrics.Streamtags = make([]types.String, 0, len(resp.InputCriblmetrics.Streamtags))
		for _, v := range resp.InputCriblmetrics.Streamtags {
			r.InputCriblmetrics.Streamtags = append(r.InputCriblmetrics.Streamtags, types.StringValue(v))
		}
		r.InputCriblmetrics.Type = types.StringValue(string(resp.InputCriblmetrics.Type))
	}
	if resp.InputCriblTCP != nil {
		r.InputCriblTCP = &tfTypes.InputCriblTCP{}
		r.InputCriblTCP.Connections = []tfTypes.InputCriblTCPConnection{}
		if len(r.InputCriblTCP.Connections) > len(resp.InputCriblTCP.Connections) {
			r.InputCriblTCP.Connections = r.InputCriblTCP.Connections[:len(resp.InputCriblTCP.Connections)]
		}
		for connectionsCount8, connectionsItem8 := range resp.InputCriblTCP.Connections {
			var connections8 tfTypes.InputCriblTCPConnection
			connections8.Output = types.StringValue(connectionsItem8.Output)
			connections8.Pipeline = types.StringPointerValue(connectionsItem8.Pipeline)
			if connectionsCount8+1 > len(r.InputCriblTCP.Connections) {
				r.InputCriblTCP.Connections = append(r.InputCriblTCP.Connections, connections8)
			} else {
				r.InputCriblTCP.Connections[connectionsCount8].Output = connections8.Output
				r.InputCriblTCP.Connections[connectionsCount8].Pipeline = connections8.Pipeline
			}
		}
		r.InputCriblTCP.Description = types.StringPointerValue(resp.InputCriblTCP.Description)
		r.InputCriblTCP.Disabled = types.BoolPointerValue(resp.InputCriblTCP.Disabled)
		r.InputCriblTCP.EnableLoadBalancing = types.BoolPointerValue(resp.InputCriblTCP.EnableLoadBalancing)
		r.InputCriblTCP.EnableProxyHeader = types.BoolPointerValue(resp.InputCriblTCP.EnableProxyHeader)
		r.InputCriblTCP.Environment = types.StringPointerValue(resp.InputCriblTCP.Environment)
		r.InputCriblTCP.Host = types.StringPointerValue(resp.InputCriblTCP.Host)
		r.InputCriblTCP.ID = types.StringPointerValue(resp.InputCriblTCP.ID)
		r.InputCriblTCP.MaxActiveCxn = types.Float64PointerValue(resp.InputCriblTCP.MaxActiveCxn)
		r.InputCriblTCP.Metadata = []tfTypes.InputCriblTCPMetadatum{}
		if len(r.InputCriblTCP.Metadata) > len(resp.InputCriblTCP.Metadata) {
			r.InputCriblTCP.Metadata = r.InputCriblTCP.Metadata[:len(resp.InputCriblTCP.Metadata)]
		}
		for metadataCount8, metadataItem8 := range resp.InputCriblTCP.Metadata {
			var metadata8 tfTypes.InputCriblTCPMetadatum
			metadata8.Name = types.StringValue(metadataItem8.Name)
			metadata8.Value = types.StringValue(metadataItem8.Value)
			if metadataCount8+1 > len(r.InputCriblTCP.Metadata) {
				r.InputCriblTCP.Metadata = append(r.InputCriblTCP.Metadata, metadata8)
			} else {
				r.InputCriblTCP.Metadata[metadataCount8].Name = metadata8.Name
				r.InputCriblTCP.Metadata[metadataCount8].Value = metadata8.Value
			}
		}
		r.InputCriblTCP.Pipeline = types.StringPointerValue(resp.InputCriblTCP.Pipeline)
		r.InputCriblTCP.Port = types.Float64Value(resp.InputCriblTCP.Port)
		if resp.InputCriblTCP.Pq == nil {
			r.InputCriblTCP.Pq = nil
		} else {
			r.InputCriblTCP.Pq = &tfTypes.InputCriblTCPPq{}
			r.InputCriblTCP.Pq.CommitFrequency = types.Float64PointerValue(resp.InputCriblTCP.Pq.CommitFrequency)
			if resp.InputCriblTCP.Pq.Compress != nil {
				r.InputCriblTCP.Pq.Compress = types.StringValue(string(*resp.InputCriblTCP.Pq.Compress))
			} else {
				r.InputCriblTCP.Pq.Compress = types.StringNull()
			}
			r.InputCriblTCP.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputCriblTCP.Pq.MaxBufferSize)
			r.InputCriblTCP.Pq.MaxFileSize = types.StringPointerValue(resp.InputCriblTCP.Pq.MaxFileSize)
			r.InputCriblTCP.Pq.MaxSize = types.StringPointerValue(resp.InputCriblTCP.Pq.MaxSize)
			if resp.InputCriblTCP.Pq.Mode != nil {
				r.InputCriblTCP.Pq.Mode = types.StringValue(string(*resp.InputCriblTCP.Pq.Mode))
			} else {
				r.InputCriblTCP.Pq.Mode = types.StringNull()
			}
			r.InputCriblTCP.Pq.Path = types.StringPointerValue(resp.InputCriblTCP.Pq.Path)
		}
		r.InputCriblTCP.PqEnabled = types.BoolPointerValue(resp.InputCriblTCP.PqEnabled)
		r.InputCriblTCP.SendToRoutes = types.BoolPointerValue(resp.InputCriblTCP.SendToRoutes)
		r.InputCriblTCP.SocketEndingMaxWait = types.Float64PointerValue(resp.InputCriblTCP.SocketEndingMaxWait)
		r.InputCriblTCP.SocketIdleTimeout = types.Float64PointerValue(resp.InputCriblTCP.SocketIdleTimeout)
		r.InputCriblTCP.SocketMaxLifespan = types.Float64PointerValue(resp.InputCriblTCP.SocketMaxLifespan)
		r.InputCriblTCP.Streamtags = make([]types.String, 0, len(resp.InputCriblTCP.Streamtags))
		for _, v := range resp.InputCriblTCP.Streamtags {
			r.InputCriblTCP.Streamtags = append(r.InputCriblTCP.Streamtags, types.StringValue(v))
		}
		if resp.InputCriblTCP.TLS == nil {
			r.InputCriblTCP.TLS = nil
		} else {
			r.InputCriblTCP.TLS = &tfTypes.InputCriblTCPTLSSettingsServerSide{}
			r.InputCriblTCP.TLS.CaPath = types.StringPointerValue(resp.InputCriblTCP.TLS.CaPath)
			r.InputCriblTCP.TLS.CertificateName = types.StringPointerValue(resp.InputCriblTCP.TLS.CertificateName)
			r.InputCriblTCP.TLS.CertPath = types.StringPointerValue(resp.InputCriblTCP.TLS.CertPath)
			if resp.InputCriblTCP.TLS.CommonNameRegex == nil {
				r.InputCriblTCP.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult3, _ := json.Marshal(resp.InputCriblTCP.TLS.CommonNameRegex)
				r.InputCriblTCP.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult3))
			}
			r.InputCriblTCP.TLS.Disabled = types.BoolPointerValue(resp.InputCriblTCP.TLS.Disabled)
			if resp.InputCriblTCP.TLS.MaxVersion != nil {
				r.InputCriblTCP.TLS.MaxVersion = types.StringValue(string(*resp.InputCriblTCP.TLS.MaxVersion))
			} else {
				r.InputCriblTCP.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputCriblTCP.TLS.MinVersion != nil {
				r.InputCriblTCP.TLS.MinVersion = types.StringValue(string(*resp.InputCriblTCP.TLS.MinVersion))
			} else {
				r.InputCriblTCP.TLS.MinVersion = types.StringNull()
			}
			r.InputCriblTCP.TLS.Passphrase = types.StringPointerValue(resp.InputCriblTCP.TLS.Passphrase)
			r.InputCriblTCP.TLS.PrivKeyPath = types.StringPointerValue(resp.InputCriblTCP.TLS.PrivKeyPath)
			if resp.InputCriblTCP.TLS.RejectUnauthorized == nil {
				r.InputCriblTCP.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult3, _ := json.Marshal(resp.InputCriblTCP.TLS.RejectUnauthorized)
				r.InputCriblTCP.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult3))
			}
			r.InputCriblTCP.TLS.RequestCert = types.BoolPointerValue(resp.InputCriblTCP.TLS.RequestCert)
		}
		if resp.InputCriblTCP.Type != nil {
			r.InputCriblTCP.Type = types.StringValue(string(*resp.InputCriblTCP.Type))
		} else {
			r.InputCriblTCP.Type = types.StringNull()
		}
	}
	if resp.InputCrowdstrike != nil {
		r.InputCrowdstrike = &tfTypes.InputCrowdstrike{}
		r.InputCrowdstrike.AssumeRoleArn = types.StringPointerValue(resp.InputCrowdstrike.AssumeRoleArn)
		r.InputCrowdstrike.AssumeRoleExternalID = types.StringPointerValue(resp.InputCrowdstrike.AssumeRoleExternalID)
		r.InputCrowdstrike.AwsAccountID = types.StringPointerValue(resp.InputCrowdstrike.AwsAccountID)
		r.InputCrowdstrike.AwsAPIKey = types.StringPointerValue(resp.InputCrowdstrike.AwsAPIKey)
		if resp.InputCrowdstrike.AwsAuthenticationMethod != nil {
			r.InputCrowdstrike.AwsAuthenticationMethod = types.StringValue(string(*resp.InputCrowdstrike.AwsAuthenticationMethod))
		} else {
			r.InputCrowdstrike.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputCrowdstrike.AwsSecret = types.StringPointerValue(resp.InputCrowdstrike.AwsSecret)
		r.InputCrowdstrike.AwsSecretKey = types.StringPointerValue(resp.InputCrowdstrike.AwsSecretKey)
		r.InputCrowdstrike.BreakerRulesets = make([]types.String, 0, len(resp.InputCrowdstrike.BreakerRulesets))
		for _, v := range resp.InputCrowdstrike.BreakerRulesets {
			r.InputCrowdstrike.BreakerRulesets = append(r.InputCrowdstrike.BreakerRulesets, types.StringValue(v))
		}
		if resp.InputCrowdstrike.Checkpointing == nil {
			r.InputCrowdstrike.Checkpointing = nil
		} else {
			r.InputCrowdstrike.Checkpointing = &tfTypes.InputCrowdstrikeCheckpointing{}
			r.InputCrowdstrike.Checkpointing.Enabled = types.BoolPointerValue(resp.InputCrowdstrike.Checkpointing.Enabled)
			r.InputCrowdstrike.Checkpointing.Retries = types.Float64PointerValue(resp.InputCrowdstrike.Checkpointing.Retries)
		}
		r.InputCrowdstrike.Connections = []tfTypes.InputCrowdstrikeConnection{}
		if len(r.InputCrowdstrike.Connections) > len(resp.InputCrowdstrike.Connections) {
			r.InputCrowdstrike.Connections = r.InputCrowdstrike.Connections[:len(resp.InputCrowdstrike.Connections)]
		}
		for connectionsCount9, connectionsItem9 := range resp.InputCrowdstrike.Connections {
			var connections9 tfTypes.InputCrowdstrikeConnection
			connections9.Output = types.StringValue(connectionsItem9.Output)
			connections9.Pipeline = types.StringPointerValue(connectionsItem9.Pipeline)
			if connectionsCount9+1 > len(r.InputCrowdstrike.Connections) {
				r.InputCrowdstrike.Connections = append(r.InputCrowdstrike.Connections, connections9)
			} else {
				r.InputCrowdstrike.Connections[connectionsCount9].Output = connections9.Output
				r.InputCrowdstrike.Connections[connectionsCount9].Pipeline = connections9.Pipeline
			}
		}
		r.InputCrowdstrike.Description = types.StringPointerValue(resp.InputCrowdstrike.Description)
		r.InputCrowdstrike.Disabled = types.BoolPointerValue(resp.InputCrowdstrike.Disabled)
		r.InputCrowdstrike.DurationSeconds = types.Float64PointerValue(resp.InputCrowdstrike.DurationSeconds)
		r.InputCrowdstrike.EnableAssumeRole = types.BoolPointerValue(resp.InputCrowdstrike.EnableAssumeRole)
		r.InputCrowdstrike.EnableSQSAssumeRole = types.BoolPointerValue(resp.InputCrowdstrike.EnableSQSAssumeRole)
		r.InputCrowdstrike.Encoding = types.StringPointerValue(resp.InputCrowdstrike.Encoding)
		r.InputCrowdstrike.Endpoint = types.StringPointerValue(resp.InputCrowdstrike.Endpoint)
		r.InputCrowdstrike.Environment = types.StringPointerValue(resp.InputCrowdstrike.Environment)
		r.InputCrowdstrike.FileFilter = types.StringPointerValue(resp.InputCrowdstrike.FileFilter)
		r.InputCrowdstrike.ID = types.StringPointerValue(resp.InputCrowdstrike.ID)
		r.InputCrowdstrike.MaxMessages = types.Float64PointerValue(resp.InputCrowdstrike.MaxMessages)
		r.InputCrowdstrike.Metadata = []tfTypes.InputCrowdstrikeMetadatum{}
		if len(r.InputCrowdstrike.Metadata) > len(resp.InputCrowdstrike.Metadata) {
			r.InputCrowdstrike.Metadata = r.InputCrowdstrike.Metadata[:len(resp.InputCrowdstrike.Metadata)]
		}
		for metadataCount9, metadataItem9 := range resp.InputCrowdstrike.Metadata {
			var metadata9 tfTypes.InputCrowdstrikeMetadatum
			metadata9.Name = types.StringValue(metadataItem9.Name)
			metadata9.Value = types.StringValue(metadataItem9.Value)
			if metadataCount9+1 > len(r.InputCrowdstrike.Metadata) {
				r.InputCrowdstrike.Metadata = append(r.InputCrowdstrike.Metadata, metadata9)
			} else {
				r.InputCrowdstrike.Metadata[metadataCount9].Name = metadata9.Name
				r.InputCrowdstrike.Metadata[metadataCount9].Value = metadata9.Value
			}
		}
		r.InputCrowdstrike.NumReceivers = types.Float64PointerValue(resp.InputCrowdstrike.NumReceivers)
		r.InputCrowdstrike.Pipeline = types.StringPointerValue(resp.InputCrowdstrike.Pipeline)
		r.InputCrowdstrike.PollTimeout = types.Float64PointerValue(resp.InputCrowdstrike.PollTimeout)
		if resp.InputCrowdstrike.Pq == nil {
			r.InputCrowdstrike.Pq = nil
		} else {
			r.InputCrowdstrike.Pq = &tfTypes.InputCrowdstrikePq{}
			r.InputCrowdstrike.Pq.CommitFrequency = types.Float64PointerValue(resp.InputCrowdstrike.Pq.CommitFrequency)
			if resp.InputCrowdstrike.Pq.Compress != nil {
				r.InputCrowdstrike.Pq.Compress = types.StringValue(string(*resp.InputCrowdstrike.Pq.Compress))
			} else {
				r.InputCrowdstrike.Pq.Compress = types.StringNull()
			}
			r.InputCrowdstrike.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputCrowdstrike.Pq.MaxBufferSize)
			r.InputCrowdstrike.Pq.MaxFileSize = types.StringPointerValue(resp.InputCrowdstrike.Pq.MaxFileSize)
			r.InputCrowdstrike.Pq.MaxSize = types.StringPointerValue(resp.InputCrowdstrike.Pq.MaxSize)
			if resp.InputCrowdstrike.Pq.Mode != nil {
				r.InputCrowdstrike.Pq.Mode = types.StringValue(string(*resp.InputCrowdstrike.Pq.Mode))
			} else {
				r.InputCrowdstrike.Pq.Mode = types.StringNull()
			}
			r.InputCrowdstrike.Pq.Path = types.StringPointerValue(resp.InputCrowdstrike.Pq.Path)
		}
		r.InputCrowdstrike.PqEnabled = types.BoolPointerValue(resp.InputCrowdstrike.PqEnabled)
		if resp.InputCrowdstrike.Preprocess == nil {
			r.InputCrowdstrike.Preprocess = nil
		} else {
			r.InputCrowdstrike.Preprocess = &tfTypes.InputCrowdstrikePreprocess{}
			r.InputCrowdstrike.Preprocess.Args = make([]types.String, 0, len(resp.InputCrowdstrike.Preprocess.Args))
			for _, v := range resp.InputCrowdstrike.Preprocess.Args {
				r.InputCrowdstrike.Preprocess.Args = append(r.InputCrowdstrike.Preprocess.Args, types.StringValue(v))
			}
			r.InputCrowdstrike.Preprocess.Command = types.StringPointerValue(resp.InputCrowdstrike.Preprocess.Command)
			r.InputCrowdstrike.Preprocess.Disabled = types.BoolPointerValue(resp.InputCrowdstrike.Preprocess.Disabled)
		}
		r.InputCrowdstrike.ProcessedTagKey = types.StringPointerValue(resp.InputCrowdstrike.ProcessedTagKey)
		r.InputCrowdstrike.ProcessedTagValue = types.StringPointerValue(resp.InputCrowdstrike.ProcessedTagValue)
		r.InputCrowdstrike.QueueName = types.StringValue(resp.InputCrowdstrike.QueueName)
		r.InputCrowdstrike.Region = types.StringPointerValue(resp.InputCrowdstrike.Region)
		r.InputCrowdstrike.RejectUnauthorized = types.BoolPointerValue(resp.InputCrowdstrike.RejectUnauthorized)
		r.InputCrowdstrike.ReuseConnections = types.BoolPointerValue(resp.InputCrowdstrike.ReuseConnections)
		r.InputCrowdstrike.SendToRoutes = types.BoolPointerValue(resp.InputCrowdstrike.SendToRoutes)
		if resp.InputCrowdstrike.SignatureVersion != nil {
			r.InputCrowdstrike.SignatureVersion = types.StringValue(string(*resp.InputCrowdstrike.SignatureVersion))
		} else {
			r.InputCrowdstrike.SignatureVersion = types.StringNull()
		}
		r.InputCrowdstrike.SkipOnError = types.BoolPointerValue(resp.InputCrowdstrike.SkipOnError)
		r.InputCrowdstrike.SocketTimeout = types.Float64PointerValue(resp.InputCrowdstrike.SocketTimeout)
		r.InputCrowdstrike.StaleChannelFlushMs = types.Float64PointerValue(resp.InputCrowdstrike.StaleChannelFlushMs)
		r.InputCrowdstrike.Streamtags = make([]types.String, 0, len(resp.InputCrowdstrike.Streamtags))
		for _, v := range resp.InputCrowdstrike.Streamtags {
			r.InputCrowdstrike.Streamtags = append(r.InputCrowdstrike.Streamtags, types.StringValue(v))
		}
		if resp.InputCrowdstrike.TagAfterProcessing != nil {
			r.InputCrowdstrike.TagAfterProcessing = types.StringValue(string(*resp.InputCrowdstrike.TagAfterProcessing))
		} else {
			r.InputCrowdstrike.TagAfterProcessing = types.StringNull()
		}
		r.InputCrowdstrike.Type = types.StringValue(string(resp.InputCrowdstrike.Type))
		r.InputCrowdstrike.VisibilityTimeout = types.Float64PointerValue(resp.InputCrowdstrike.VisibilityTimeout)
	}
	if resp.InputDatadogAgent != nil {
		r.InputDatadogAgent = &tfTypes.InputDatadogAgent{}
		r.InputDatadogAgent.ActivityLogSampleRate = types.Float64PointerValue(resp.InputDatadogAgent.ActivityLogSampleRate)
		r.InputDatadogAgent.CaptureHeaders = types.BoolPointerValue(resp.InputDatadogAgent.CaptureHeaders)
		r.InputDatadogAgent.Connections = []tfTypes.InputDatadogAgentConnection{}
		if len(r.InputDatadogAgent.Connections) > len(resp.InputDatadogAgent.Connections) {
			r.InputDatadogAgent.Connections = r.InputDatadogAgent.Connections[:len(resp.InputDatadogAgent.Connections)]
		}
		for connectionsCount10, connectionsItem10 := range resp.InputDatadogAgent.Connections {
			var connections10 tfTypes.InputDatadogAgentConnection
			connections10.Output = types.StringValue(connectionsItem10.Output)
			connections10.Pipeline = types.StringPointerValue(connectionsItem10.Pipeline)
			if connectionsCount10+1 > len(r.InputDatadogAgent.Connections) {
				r.InputDatadogAgent.Connections = append(r.InputDatadogAgent.Connections, connections10)
			} else {
				r.InputDatadogAgent.Connections[connectionsCount10].Output = connections10.Output
				r.InputDatadogAgent.Connections[connectionsCount10].Pipeline = connections10.Pipeline
			}
		}
		r.InputDatadogAgent.Description = types.StringPointerValue(resp.InputDatadogAgent.Description)
		r.InputDatadogAgent.Disabled = types.BoolPointerValue(resp.InputDatadogAgent.Disabled)
		r.InputDatadogAgent.EnableHealthCheck = types.BoolPointerValue(resp.InputDatadogAgent.EnableHealthCheck)
		r.InputDatadogAgent.EnableProxyHeader = types.BoolPointerValue(resp.InputDatadogAgent.EnableProxyHeader)
		r.InputDatadogAgent.Environment = types.StringPointerValue(resp.InputDatadogAgent.Environment)
		r.InputDatadogAgent.ExtractMetrics = types.BoolPointerValue(resp.InputDatadogAgent.ExtractMetrics)
		r.InputDatadogAgent.Host = types.StringPointerValue(resp.InputDatadogAgent.Host)
		r.InputDatadogAgent.ID = types.StringPointerValue(resp.InputDatadogAgent.ID)
		r.InputDatadogAgent.IPAllowlistRegex = types.StringPointerValue(resp.InputDatadogAgent.IPAllowlistRegex)
		r.InputDatadogAgent.IPDenylistRegex = types.StringPointerValue(resp.InputDatadogAgent.IPDenylistRegex)
		r.InputDatadogAgent.KeepAliveTimeout = types.Float64PointerValue(resp.InputDatadogAgent.KeepAliveTimeout)
		r.InputDatadogAgent.MaxActiveReq = types.Float64PointerValue(resp.InputDatadogAgent.MaxActiveReq)
		r.InputDatadogAgent.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputDatadogAgent.MaxRequestsPerSocket)
		r.InputDatadogAgent.Metadata = []tfTypes.InputDatadogAgentMetadatum{}
		if len(r.InputDatadogAgent.Metadata) > len(resp.InputDatadogAgent.Metadata) {
			r.InputDatadogAgent.Metadata = r.InputDatadogAgent.Metadata[:len(resp.InputDatadogAgent.Metadata)]
		}
		for metadataCount10, metadataItem10 := range resp.InputDatadogAgent.Metadata {
			var metadata10 tfTypes.InputDatadogAgentMetadatum
			metadata10.Name = types.StringValue(metadataItem10.Name)
			metadata10.Value = types.StringValue(metadataItem10.Value)
			if metadataCount10+1 > len(r.InputDatadogAgent.Metadata) {
				r.InputDatadogAgent.Metadata = append(r.InputDatadogAgent.Metadata, metadata10)
			} else {
				r.InputDatadogAgent.Metadata[metadataCount10].Name = metadata10.Name
				r.InputDatadogAgent.Metadata[metadataCount10].Value = metadata10.Value
			}
		}
		r.InputDatadogAgent.Pipeline = types.StringPointerValue(resp.InputDatadogAgent.Pipeline)
		r.InputDatadogAgent.Port = types.Float64Value(resp.InputDatadogAgent.Port)
		if resp.InputDatadogAgent.Pq == nil {
			r.InputDatadogAgent.Pq = nil
		} else {
			r.InputDatadogAgent.Pq = &tfTypes.InputDatadogAgentPq{}
			r.InputDatadogAgent.Pq.CommitFrequency = types.Float64PointerValue(resp.InputDatadogAgent.Pq.CommitFrequency)
			if resp.InputDatadogAgent.Pq.Compress != nil {
				r.InputDatadogAgent.Pq.Compress = types.StringValue(string(*resp.InputDatadogAgent.Pq.Compress))
			} else {
				r.InputDatadogAgent.Pq.Compress = types.StringNull()
			}
			r.InputDatadogAgent.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputDatadogAgent.Pq.MaxBufferSize)
			r.InputDatadogAgent.Pq.MaxFileSize = types.StringPointerValue(resp.InputDatadogAgent.Pq.MaxFileSize)
			r.InputDatadogAgent.Pq.MaxSize = types.StringPointerValue(resp.InputDatadogAgent.Pq.MaxSize)
			if resp.InputDatadogAgent.Pq.Mode != nil {
				r.InputDatadogAgent.Pq.Mode = types.StringValue(string(*resp.InputDatadogAgent.Pq.Mode))
			} else {
				r.InputDatadogAgent.Pq.Mode = types.StringNull()
			}
			r.InputDatadogAgent.Pq.Path = types.StringPointerValue(resp.InputDatadogAgent.Pq.Path)
		}
		r.InputDatadogAgent.PqEnabled = types.BoolPointerValue(resp.InputDatadogAgent.PqEnabled)
		if resp.InputDatadogAgent.ProxyMode == nil {
			r.InputDatadogAgent.ProxyMode = nil
		} else {
			r.InputDatadogAgent.ProxyMode = &tfTypes.InputDatadogAgentProxyMode{}
			r.InputDatadogAgent.ProxyMode.Enabled = types.BoolPointerValue(resp.InputDatadogAgent.ProxyMode.Enabled)
			r.InputDatadogAgent.ProxyMode.RejectUnauthorized = types.BoolPointerValue(resp.InputDatadogAgent.ProxyMode.RejectUnauthorized)
		}
		r.InputDatadogAgent.RequestTimeout = types.Float64PointerValue(resp.InputDatadogAgent.RequestTimeout)
		r.InputDatadogAgent.SendToRoutes = types.BoolPointerValue(resp.InputDatadogAgent.SendToRoutes)
		r.InputDatadogAgent.SocketTimeout = types.Float64PointerValue(resp.InputDatadogAgent.SocketTimeout)
		r.InputDatadogAgent.Streamtags = make([]types.String, 0, len(resp.InputDatadogAgent.Streamtags))
		for _, v := range resp.InputDatadogAgent.Streamtags {
			r.InputDatadogAgent.Streamtags = append(r.InputDatadogAgent.Streamtags, types.StringValue(v))
		}
		if resp.InputDatadogAgent.TLS == nil {
			r.InputDatadogAgent.TLS = nil
		} else {
			r.InputDatadogAgent.TLS = &tfTypes.InputDatadogAgentTLSSettingsServerSide{}
			r.InputDatadogAgent.TLS.CaPath = types.StringPointerValue(resp.InputDatadogAgent.TLS.CaPath)
			r.InputDatadogAgent.TLS.CertificateName = types.StringPointerValue(resp.InputDatadogAgent.TLS.CertificateName)
			r.InputDatadogAgent.TLS.CertPath = types.StringPointerValue(resp.InputDatadogAgent.TLS.CertPath)
			if resp.InputDatadogAgent.TLS.CommonNameRegex == nil {
				r.InputDatadogAgent.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult4, _ := json.Marshal(resp.InputDatadogAgent.TLS.CommonNameRegex)
				r.InputDatadogAgent.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult4))
			}
			r.InputDatadogAgent.TLS.Disabled = types.BoolPointerValue(resp.InputDatadogAgent.TLS.Disabled)
			if resp.InputDatadogAgent.TLS.MaxVersion != nil {
				r.InputDatadogAgent.TLS.MaxVersion = types.StringValue(string(*resp.InputDatadogAgent.TLS.MaxVersion))
			} else {
				r.InputDatadogAgent.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputDatadogAgent.TLS.MinVersion != nil {
				r.InputDatadogAgent.TLS.MinVersion = types.StringValue(string(*resp.InputDatadogAgent.TLS.MinVersion))
			} else {
				r.InputDatadogAgent.TLS.MinVersion = types.StringNull()
			}
			r.InputDatadogAgent.TLS.Passphrase = types.StringPointerValue(resp.InputDatadogAgent.TLS.Passphrase)
			r.InputDatadogAgent.TLS.PrivKeyPath = types.StringPointerValue(resp.InputDatadogAgent.TLS.PrivKeyPath)
			if resp.InputDatadogAgent.TLS.RejectUnauthorized == nil {
				r.InputDatadogAgent.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult4, _ := json.Marshal(resp.InputDatadogAgent.TLS.RejectUnauthorized)
				r.InputDatadogAgent.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult4))
			}
			r.InputDatadogAgent.TLS.RequestCert = types.BoolPointerValue(resp.InputDatadogAgent.TLS.RequestCert)
		}
		if resp.InputDatadogAgent.Type != nil {
			r.InputDatadogAgent.Type = types.StringValue(string(*resp.InputDatadogAgent.Type))
		} else {
			r.InputDatadogAgent.Type = types.StringNull()
		}
	}
	if resp.InputDatagen != nil {
		r.InputDatagen = &tfTypes.InputDatagen{}
		r.InputDatagen.Connections = []tfTypes.InputDatagenConnection{}
		if len(r.InputDatagen.Connections) > len(resp.InputDatagen.Connections) {
			r.InputDatagen.Connections = r.InputDatagen.Connections[:len(resp.InputDatagen.Connections)]
		}
		for connectionsCount11, connectionsItem11 := range resp.InputDatagen.Connections {
			var connections11 tfTypes.InputDatagenConnection
			connections11.Output = types.StringValue(connectionsItem11.Output)
			connections11.Pipeline = types.StringPointerValue(connectionsItem11.Pipeline)
			if connectionsCount11+1 > len(r.InputDatagen.Connections) {
				r.InputDatagen.Connections = append(r.InputDatagen.Connections, connections11)
			} else {
				r.InputDatagen.Connections[connectionsCount11].Output = connections11.Output
				r.InputDatagen.Connections[connectionsCount11].Pipeline = connections11.Pipeline
			}
		}
		r.InputDatagen.Description = types.StringPointerValue(resp.InputDatagen.Description)
		r.InputDatagen.Disabled = types.BoolPointerValue(resp.InputDatagen.Disabled)
		r.InputDatagen.Environment = types.StringPointerValue(resp.InputDatagen.Environment)
		r.InputDatagen.ID = types.StringPointerValue(resp.InputDatagen.ID)
		r.InputDatagen.Metadata = []tfTypes.InputDatagenMetadatum{}
		if len(r.InputDatagen.Metadata) > len(resp.InputDatagen.Metadata) {
			r.InputDatagen.Metadata = r.InputDatagen.Metadata[:len(resp.InputDatagen.Metadata)]
		}
		for metadataCount11, metadataItem11 := range resp.InputDatagen.Metadata {
			var metadata11 tfTypes.InputDatagenMetadatum
			metadata11.Name = types.StringValue(metadataItem11.Name)
			metadata11.Value = types.StringValue(metadataItem11.Value)
			if metadataCount11+1 > len(r.InputDatagen.Metadata) {
				r.InputDatagen.Metadata = append(r.InputDatagen.Metadata, metadata11)
			} else {
				r.InputDatagen.Metadata[metadataCount11].Name = metadata11.Name
				r.InputDatagen.Metadata[metadataCount11].Value = metadata11.Value
			}
		}
		r.InputDatagen.Pipeline = types.StringPointerValue(resp.InputDatagen.Pipeline)
		if resp.InputDatagen.Pq == nil {
			r.InputDatagen.Pq = nil
		} else {
			r.InputDatagen.Pq = &tfTypes.InputDatagenPq{}
			r.InputDatagen.Pq.CommitFrequency = types.Float64PointerValue(resp.InputDatagen.Pq.CommitFrequency)
			if resp.InputDatagen.Pq.Compress != nil {
				r.InputDatagen.Pq.Compress = types.StringValue(string(*resp.InputDatagen.Pq.Compress))
			} else {
				r.InputDatagen.Pq.Compress = types.StringNull()
			}
			r.InputDatagen.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputDatagen.Pq.MaxBufferSize)
			r.InputDatagen.Pq.MaxFileSize = types.StringPointerValue(resp.InputDatagen.Pq.MaxFileSize)
			r.InputDatagen.Pq.MaxSize = types.StringPointerValue(resp.InputDatagen.Pq.MaxSize)
			if resp.InputDatagen.Pq.Mode != nil {
				r.InputDatagen.Pq.Mode = types.StringValue(string(*resp.InputDatagen.Pq.Mode))
			} else {
				r.InputDatagen.Pq.Mode = types.StringNull()
			}
			r.InputDatagen.Pq.Path = types.StringPointerValue(resp.InputDatagen.Pq.Path)
		}
		r.InputDatagen.PqEnabled = types.BoolPointerValue(resp.InputDatagen.PqEnabled)
		r.InputDatagen.Samples = []tfTypes.Sample{}
		if len(r.InputDatagen.Samples) > len(resp.InputDatagen.Samples) {
			r.InputDatagen.Samples = r.InputDatagen.Samples[:len(resp.InputDatagen.Samples)]
		}
		for samplesCount, samplesItem := range resp.InputDatagen.Samples {
			var samples tfTypes.Sample
			samples.EventsPerSec = types.Float64PointerValue(samplesItem.EventsPerSec)
			samples.Sample = types.StringValue(samplesItem.Sample)
			if samplesCount+1 > len(r.InputDatagen.Samples) {
				r.InputDatagen.Samples = append(r.InputDatagen.Samples, samples)
			} else {
				r.InputDatagen.Samples[samplesCount].EventsPerSec = samples.EventsPerSec
				r.InputDatagen.Samples[samplesCount].Sample = samples.Sample
			}
		}
		r.InputDatagen.SendToRoutes = types.BoolPointerValue(resp.InputDatagen.SendToRoutes)
		r.InputDatagen.Streamtags = make([]types.String, 0, len(resp.InputDatagen.Streamtags))
		for _, v := range resp.InputDatagen.Streamtags {
			r.InputDatagen.Streamtags = append(r.InputDatagen.Streamtags, types.StringValue(v))
		}
		r.InputDatagen.Type = types.StringValue(string(resp.InputDatagen.Type))
	}
	if resp.InputEdgePrometheus != nil {
		r.InputEdgePrometheus = &tfTypes.InputEdgePrometheus{}
		r.InputEdgePrometheus.AssumeRoleArn = types.StringPointerValue(resp.InputEdgePrometheus.AssumeRoleArn)
		r.InputEdgePrometheus.AssumeRoleExternalID = types.StringPointerValue(resp.InputEdgePrometheus.AssumeRoleExternalID)
		if resp.InputEdgePrometheus.AuthType != nil {
			r.InputEdgePrometheus.AuthType = types.StringValue(string(*resp.InputEdgePrometheus.AuthType))
		} else {
			r.InputEdgePrometheus.AuthType = types.StringNull()
		}
		if resp.InputEdgePrometheus.AwsAuthenticationMethod != nil {
			r.InputEdgePrometheus.AwsAuthenticationMethod = types.StringValue(string(*resp.InputEdgePrometheus.AwsAuthenticationMethod))
		} else {
			r.InputEdgePrometheus.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputEdgePrometheus.AwsSecretKey = types.StringPointerValue(resp.InputEdgePrometheus.AwsSecretKey)
		r.InputEdgePrometheus.Connections = []tfTypes.InputEdgePrometheusConnection{}
		if len(r.InputEdgePrometheus.Connections) > len(resp.InputEdgePrometheus.Connections) {
			r.InputEdgePrometheus.Connections = r.InputEdgePrometheus.Connections[:len(resp.InputEdgePrometheus.Connections)]
		}
		for connectionsCount12, connectionsItem12 := range resp.InputEdgePrometheus.Connections {
			var connections12 tfTypes.InputEdgePrometheusConnection
			connections12.Output = types.StringValue(connectionsItem12.Output)
			connections12.Pipeline = types.StringPointerValue(connectionsItem12.Pipeline)
			if connectionsCount12+1 > len(r.InputEdgePrometheus.Connections) {
				r.InputEdgePrometheus.Connections = append(r.InputEdgePrometheus.Connections, connections12)
			} else {
				r.InputEdgePrometheus.Connections[connectionsCount12].Output = connections12.Output
				r.InputEdgePrometheus.Connections[connectionsCount12].Pipeline = connections12.Pipeline
			}
		}
		r.InputEdgePrometheus.CredentialsSecret = types.StringPointerValue(resp.InputEdgePrometheus.CredentialsSecret)
		r.InputEdgePrometheus.Description = types.StringPointerValue(resp.InputEdgePrometheus.Description)
		r.InputEdgePrometheus.DimensionList = make([]types.String, 0, len(resp.InputEdgePrometheus.DimensionList))
		for _, v := range resp.InputEdgePrometheus.DimensionList {
			r.InputEdgePrometheus.DimensionList = append(r.InputEdgePrometheus.DimensionList, types.StringValue(v))
		}
		r.InputEdgePrometheus.Disabled = types.BoolPointerValue(resp.InputEdgePrometheus.Disabled)
		if resp.InputEdgePrometheus.DiscoveryType != nil {
			r.InputEdgePrometheus.DiscoveryType = types.StringValue(string(*resp.InputEdgePrometheus.DiscoveryType))
		} else {
			r.InputEdgePrometheus.DiscoveryType = types.StringNull()
		}
		r.InputEdgePrometheus.DurationSeconds = types.Float64PointerValue(resp.InputEdgePrometheus.DurationSeconds)
		r.InputEdgePrometheus.EnableAssumeRole = types.BoolPointerValue(resp.InputEdgePrometheus.EnableAssumeRole)
		r.InputEdgePrometheus.Endpoint = types.StringPointerValue(resp.InputEdgePrometheus.Endpoint)
		r.InputEdgePrometheus.Environment = types.StringPointerValue(resp.InputEdgePrometheus.Environment)
		r.InputEdgePrometheus.ID = types.StringPointerValue(resp.InputEdgePrometheus.ID)
		r.InputEdgePrometheus.Interval = types.Float64PointerValue(resp.InputEdgePrometheus.Interval)
		r.InputEdgePrometheus.Metadata = []tfTypes.InputEdgePrometheusMetadatum{}
		if len(r.InputEdgePrometheus.Metadata) > len(resp.InputEdgePrometheus.Metadata) {
			r.InputEdgePrometheus.Metadata = r.InputEdgePrometheus.Metadata[:len(resp.InputEdgePrometheus.Metadata)]
		}
		for metadataCount12, metadataItem12 := range resp.InputEdgePrometheus.Metadata {
			var metadata12 tfTypes.InputEdgePrometheusMetadatum
			metadata12.Name = types.StringValue(metadataItem12.Name)
			metadata12.Value = types.StringValue(metadataItem12.Value)
			if metadataCount12+1 > len(r.InputEdgePrometheus.Metadata) {
				r.InputEdgePrometheus.Metadata = append(r.InputEdgePrometheus.Metadata, metadata12)
			} else {
				r.InputEdgePrometheus.Metadata[metadataCount12].Name = metadata12.Name
				r.InputEdgePrometheus.Metadata[metadataCount12].Value = metadata12.Value
			}
		}
		r.InputEdgePrometheus.NameList = make([]types.String, 0, len(resp.InputEdgePrometheus.NameList))
		for _, v := range resp.InputEdgePrometheus.NameList {
			r.InputEdgePrometheus.NameList = append(r.InputEdgePrometheus.NameList, types.StringValue(v))
		}
		r.InputEdgePrometheus.Password = types.StringPointerValue(resp.InputEdgePrometheus.Password)
		if resp.InputEdgePrometheus.Persistence == nil {
			r.InputEdgePrometheus.Persistence = nil
		} else {
			r.InputEdgePrometheus.Persistence = &tfTypes.InputEdgePrometheusDiskSpooling{}
			if resp.InputEdgePrometheus.Persistence.Compress != nil {
				r.InputEdgePrometheus.Persistence.Compress = types.StringValue(string(*resp.InputEdgePrometheus.Persistence.Compress))
			} else {
				r.InputEdgePrometheus.Persistence.Compress = types.StringNull()
			}
			r.InputEdgePrometheus.Persistence.Enable = types.BoolPointerValue(resp.InputEdgePrometheus.Persistence.Enable)
			r.InputEdgePrometheus.Persistence.MaxDataSize = types.StringPointerValue(resp.InputEdgePrometheus.Persistence.MaxDataSize)
			r.InputEdgePrometheus.Persistence.MaxDataTime = types.StringPointerValue(resp.InputEdgePrometheus.Persistence.MaxDataTime)
			r.InputEdgePrometheus.Persistence.TimeWindow = types.StringPointerValue(resp.InputEdgePrometheus.Persistence.TimeWindow)
		}
		r.InputEdgePrometheus.Pipeline = types.StringPointerValue(resp.InputEdgePrometheus.Pipeline)
		r.InputEdgePrometheus.PodFilter = []tfTypes.PodFilter{}
		if len(r.InputEdgePrometheus.PodFilter) > len(resp.InputEdgePrometheus.PodFilter) {
			r.InputEdgePrometheus.PodFilter = r.InputEdgePrometheus.PodFilter[:len(resp.InputEdgePrometheus.PodFilter)]
		}
		for podFilterCount, podFilterItem := range resp.InputEdgePrometheus.PodFilter {
			var podFilter tfTypes.PodFilter
			podFilter.Description = types.StringPointerValue(podFilterItem.Description)
			podFilter.Filter = types.StringValue(podFilterItem.Filter)
			if podFilterCount+1 > len(r.InputEdgePrometheus.PodFilter) {
				r.InputEdgePrometheus.PodFilter = append(r.InputEdgePrometheus.PodFilter, podFilter)
			} else {
				r.InputEdgePrometheus.PodFilter[podFilterCount].Description = podFilter.Description
				r.InputEdgePrometheus.PodFilter[podFilterCount].Filter = podFilter.Filter
			}
		}
		if resp.InputEdgePrometheus.Pq == nil {
			r.InputEdgePrometheus.Pq = nil
		} else {
			r.InputEdgePrometheus.Pq = &tfTypes.InputEdgePrometheusPq{}
			r.InputEdgePrometheus.Pq.CommitFrequency = types.Float64PointerValue(resp.InputEdgePrometheus.Pq.CommitFrequency)
			if resp.InputEdgePrometheus.Pq.Compress != nil {
				r.InputEdgePrometheus.Pq.Compress = types.StringValue(string(*resp.InputEdgePrometheus.Pq.Compress))
			} else {
				r.InputEdgePrometheus.Pq.Compress = types.StringNull()
			}
			r.InputEdgePrometheus.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputEdgePrometheus.Pq.MaxBufferSize)
			r.InputEdgePrometheus.Pq.MaxFileSize = types.StringPointerValue(resp.InputEdgePrometheus.Pq.MaxFileSize)
			r.InputEdgePrometheus.Pq.MaxSize = types.StringPointerValue(resp.InputEdgePrometheus.Pq.MaxSize)
			if resp.InputEdgePrometheus.Pq.Mode != nil {
				r.InputEdgePrometheus.Pq.Mode = types.StringValue(string(*resp.InputEdgePrometheus.Pq.Mode))
			} else {
				r.InputEdgePrometheus.Pq.Mode = types.StringNull()
			}
			r.InputEdgePrometheus.Pq.Path = types.StringPointerValue(resp.InputEdgePrometheus.Pq.Path)
		}
		r.InputEdgePrometheus.PqEnabled = types.BoolPointerValue(resp.InputEdgePrometheus.PqEnabled)
		if resp.InputEdgePrometheus.RecordType != nil {
			r.InputEdgePrometheus.RecordType = types.StringValue(string(*resp.InputEdgePrometheus.RecordType))
		} else {
			r.InputEdgePrometheus.RecordType = types.StringNull()
		}
		r.InputEdgePrometheus.Region = types.StringPointerValue(resp.InputEdgePrometheus.Region)
		r.InputEdgePrometheus.RejectUnauthorized = types.BoolPointerValue(resp.InputEdgePrometheus.RejectUnauthorized)
		r.InputEdgePrometheus.ReuseConnections = types.BoolPointerValue(resp.InputEdgePrometheus.ReuseConnections)
		r.InputEdgePrometheus.ScrapePath = types.StringPointerValue(resp.InputEdgePrometheus.ScrapePath)
		r.InputEdgePrometheus.ScrapePathExpr = types.StringPointerValue(resp.InputEdgePrometheus.ScrapePathExpr)
		r.InputEdgePrometheus.ScrapePort = types.Float64PointerValue(resp.InputEdgePrometheus.ScrapePort)
		r.InputEdgePrometheus.ScrapePortExpr = types.StringPointerValue(resp.InputEdgePrometheus.ScrapePortExpr)
		if resp.InputEdgePrometheus.ScrapeProtocol != nil {
			r.InputEdgePrometheus.ScrapeProtocol = types.StringValue(string(*resp.InputEdgePrometheus.ScrapeProtocol))
		} else {
			r.InputEdgePrometheus.ScrapeProtocol = types.StringNull()
		}
		r.InputEdgePrometheus.ScrapeProtocolExpr = types.StringPointerValue(resp.InputEdgePrometheus.ScrapeProtocolExpr)
		r.InputEdgePrometheus.SearchFilter = []tfTypes.InputEdgePrometheusSearchFilter{}
		if len(r.InputEdgePrometheus.SearchFilter) > len(resp.InputEdgePrometheus.SearchFilter) {
			r.InputEdgePrometheus.SearchFilter = r.InputEdgePrometheus.SearchFilter[:len(resp.InputEdgePrometheus.SearchFilter)]
		}
		for searchFilterCount, searchFilterItem := range resp.InputEdgePrometheus.SearchFilter {
			var searchFilter tfTypes.InputEdgePrometheusSearchFilter
			searchFilter.Name = types.StringValue(searchFilterItem.Name)
			searchFilter.Values = make([]types.String, 0, len(searchFilterItem.Values))
			for _, v := range searchFilterItem.Values {
				searchFilter.Values = append(searchFilter.Values, types.StringValue(v))
			}
			if searchFilterCount+1 > len(r.InputEdgePrometheus.SearchFilter) {
				r.InputEdgePrometheus.SearchFilter = append(r.InputEdgePrometheus.SearchFilter, searchFilter)
			} else {
				r.InputEdgePrometheus.SearchFilter[searchFilterCount].Name = searchFilter.Name
				r.InputEdgePrometheus.SearchFilter[searchFilterCount].Values = searchFilter.Values
			}
		}
		r.InputEdgePrometheus.SendToRoutes = types.BoolPointerValue(resp.InputEdgePrometheus.SendToRoutes)
		if resp.InputEdgePrometheus.SignatureVersion != nil {
			r.InputEdgePrometheus.SignatureVersion = types.StringValue(string(*resp.InputEdgePrometheus.SignatureVersion))
		} else {
			r.InputEdgePrometheus.SignatureVersion = types.StringNull()
		}
		r.InputEdgePrometheus.Streamtags = make([]types.String, 0, len(resp.InputEdgePrometheus.Streamtags))
		for _, v := range resp.InputEdgePrometheus.Streamtags {
			r.InputEdgePrometheus.Streamtags = append(r.InputEdgePrometheus.Streamtags, types.StringValue(v))
		}
		r.InputEdgePrometheus.Targets = []tfTypes.Target{}
		if len(r.InputEdgePrometheus.Targets) > len(resp.InputEdgePrometheus.Targets) {
			r.InputEdgePrometheus.Targets = r.InputEdgePrometheus.Targets[:len(resp.InputEdgePrometheus.Targets)]
		}
		for targetsCount, targetsItem := range resp.InputEdgePrometheus.Targets {
			var targets tfTypes.Target
			targets.Host = types.StringValue(targetsItem.Host)
			targets.Path = types.StringPointerValue(targetsItem.Path)
			targets.Port = types.Float64PointerValue(targetsItem.Port)
			if targetsItem.Protocol != nil {
				targets.Protocol = types.StringValue(string(*targetsItem.Protocol))
			} else {
				targets.Protocol = types.StringNull()
			}
			if targetsCount+1 > len(r.InputEdgePrometheus.Targets) {
				r.InputEdgePrometheus.Targets = append(r.InputEdgePrometheus.Targets, targets)
			} else {
				r.InputEdgePrometheus.Targets[targetsCount].Host = targets.Host
				r.InputEdgePrometheus.Targets[targetsCount].Path = targets.Path
				r.InputEdgePrometheus.Targets[targetsCount].Port = targets.Port
				r.InputEdgePrometheus.Targets[targetsCount].Protocol = targets.Protocol
			}
		}
		r.InputEdgePrometheus.Timeout = types.Float64PointerValue(resp.InputEdgePrometheus.Timeout)
		if resp.InputEdgePrometheus.Type != nil {
			r.InputEdgePrometheus.Type = types.StringValue(string(*resp.InputEdgePrometheus.Type))
		} else {
			r.InputEdgePrometheus.Type = types.StringNull()
		}
		r.InputEdgePrometheus.UsePublicIP = types.BoolPointerValue(resp.InputEdgePrometheus.UsePublicIP)
		r.InputEdgePrometheus.Username = types.StringPointerValue(resp.InputEdgePrometheus.Username)
	}
	if resp.InputElastic != nil {
		r.InputElastic = &tfTypes.InputElastic{}
		r.InputElastic.ActivityLogSampleRate = types.Float64PointerValue(resp.InputElastic.ActivityLogSampleRate)
		if resp.InputElastic.APIVersion != nil {
			r.InputElastic.APIVersion = types.StringValue(string(*resp.InputElastic.APIVersion))
		} else {
			r.InputElastic.APIVersion = types.StringNull()
		}
		r.InputElastic.AuthTokens = make([]types.String, 0, len(resp.InputElastic.AuthTokens))
		for _, v := range resp.InputElastic.AuthTokens {
			r.InputElastic.AuthTokens = append(r.InputElastic.AuthTokens, types.StringValue(v))
		}
		if resp.InputElastic.AuthType != nil {
			r.InputElastic.AuthType = types.StringValue(string(*resp.InputElastic.AuthType))
		} else {
			r.InputElastic.AuthType = types.StringNull()
		}
		r.InputElastic.CaptureHeaders = types.BoolPointerValue(resp.InputElastic.CaptureHeaders)
		r.InputElastic.Connections = []tfTypes.InputElasticConnection{}
		if len(r.InputElastic.Connections) > len(resp.InputElastic.Connections) {
			r.InputElastic.Connections = r.InputElastic.Connections[:len(resp.InputElastic.Connections)]
		}
		for connectionsCount13, connectionsItem13 := range resp.InputElastic.Connections {
			var connections13 tfTypes.InputElasticConnection
			connections13.Output = types.StringValue(connectionsItem13.Output)
			connections13.Pipeline = types.StringPointerValue(connectionsItem13.Pipeline)
			if connectionsCount13+1 > len(r.InputElastic.Connections) {
				r.InputElastic.Connections = append(r.InputElastic.Connections, connections13)
			} else {
				r.InputElastic.Connections[connectionsCount13].Output = connections13.Output
				r.InputElastic.Connections[connectionsCount13].Pipeline = connections13.Pipeline
			}
		}
		r.InputElastic.CredentialsSecret = types.StringPointerValue(resp.InputElastic.CredentialsSecret)
		r.InputElastic.CustomAPIVersion = types.StringPointerValue(resp.InputElastic.CustomAPIVersion)
		r.InputElastic.Description = types.StringPointerValue(resp.InputElastic.Description)
		r.InputElastic.Disabled = types.BoolPointerValue(resp.InputElastic.Disabled)
		r.InputElastic.ElasticAPI = types.StringPointerValue(resp.InputElastic.ElasticAPI)
		r.InputElastic.EnableHealthCheck = types.BoolPointerValue(resp.InputElastic.EnableHealthCheck)
		r.InputElastic.EnableProxyHeader = types.BoolPointerValue(resp.InputElastic.EnableProxyHeader)
		r.InputElastic.Environment = types.StringPointerValue(resp.InputElastic.Environment)
		r.InputElastic.ExtraHTTPHeaders = []tfTypes.InputElasticExtraHTTPHeader{}
		if len(r.InputElastic.ExtraHTTPHeaders) > len(resp.InputElastic.ExtraHTTPHeaders) {
			r.InputElastic.ExtraHTTPHeaders = r.InputElastic.ExtraHTTPHeaders[:len(resp.InputElastic.ExtraHTTPHeaders)]
		}
		for extraHTTPHeadersCount, extraHTTPHeadersItem := range resp.InputElastic.ExtraHTTPHeaders {
			var extraHTTPHeaders tfTypes.InputElasticExtraHTTPHeader
			extraHTTPHeaders.Name = types.StringPointerValue(extraHTTPHeadersItem.Name)
			extraHTTPHeaders.Value = types.StringValue(extraHTTPHeadersItem.Value)
			if extraHTTPHeadersCount+1 > len(r.InputElastic.ExtraHTTPHeaders) {
				r.InputElastic.ExtraHTTPHeaders = append(r.InputElastic.ExtraHTTPHeaders, extraHTTPHeaders)
			} else {
				r.InputElastic.ExtraHTTPHeaders[extraHTTPHeadersCount].Name = extraHTTPHeaders.Name
				r.InputElastic.ExtraHTTPHeaders[extraHTTPHeadersCount].Value = extraHTTPHeaders.Value
			}
		}
		r.InputElastic.Host = types.StringPointerValue(resp.InputElastic.Host)
		r.InputElastic.ID = types.StringPointerValue(resp.InputElastic.ID)
		r.InputElastic.IPAllowlistRegex = types.StringPointerValue(resp.InputElastic.IPAllowlistRegex)
		r.InputElastic.IPDenylistRegex = types.StringPointerValue(resp.InputElastic.IPDenylistRegex)
		r.InputElastic.KeepAliveTimeout = types.Float64PointerValue(resp.InputElastic.KeepAliveTimeout)
		r.InputElastic.MaxActiveReq = types.Float64PointerValue(resp.InputElastic.MaxActiveReq)
		r.InputElastic.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputElastic.MaxRequestsPerSocket)
		r.InputElastic.Metadata = []tfTypes.InputElasticMetadatum{}
		if len(r.InputElastic.Metadata) > len(resp.InputElastic.Metadata) {
			r.InputElastic.Metadata = r.InputElastic.Metadata[:len(resp.InputElastic.Metadata)]
		}
		for metadataCount13, metadataItem13 := range resp.InputElastic.Metadata {
			var metadata13 tfTypes.InputElasticMetadatum
			metadata13.Name = types.StringValue(metadataItem13.Name)
			metadata13.Value = types.StringValue(metadataItem13.Value)
			if metadataCount13+1 > len(r.InputElastic.Metadata) {
				r.InputElastic.Metadata = append(r.InputElastic.Metadata, metadata13)
			} else {
				r.InputElastic.Metadata[metadataCount13].Name = metadata13.Name
				r.InputElastic.Metadata[metadataCount13].Value = metadata13.Value
			}
		}
		r.InputElastic.Password = types.StringPointerValue(resp.InputElastic.Password)
		r.InputElastic.Pipeline = types.StringPointerValue(resp.InputElastic.Pipeline)
		r.InputElastic.Port = types.Float64Value(resp.InputElastic.Port)
		if resp.InputElastic.Pq == nil {
			r.InputElastic.Pq = nil
		} else {
			r.InputElastic.Pq = &tfTypes.InputElasticPq{}
			r.InputElastic.Pq.CommitFrequency = types.Float64PointerValue(resp.InputElastic.Pq.CommitFrequency)
			if resp.InputElastic.Pq.Compress != nil {
				r.InputElastic.Pq.Compress = types.StringValue(string(*resp.InputElastic.Pq.Compress))
			} else {
				r.InputElastic.Pq.Compress = types.StringNull()
			}
			r.InputElastic.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputElastic.Pq.MaxBufferSize)
			r.InputElastic.Pq.MaxFileSize = types.StringPointerValue(resp.InputElastic.Pq.MaxFileSize)
			r.InputElastic.Pq.MaxSize = types.StringPointerValue(resp.InputElastic.Pq.MaxSize)
			if resp.InputElastic.Pq.Mode != nil {
				r.InputElastic.Pq.Mode = types.StringValue(string(*resp.InputElastic.Pq.Mode))
			} else {
				r.InputElastic.Pq.Mode = types.StringNull()
			}
			r.InputElastic.Pq.Path = types.StringPointerValue(resp.InputElastic.Pq.Path)
		}
		r.InputElastic.PqEnabled = types.BoolPointerValue(resp.InputElastic.PqEnabled)
		if resp.InputElastic.ProxyMode == nil {
			r.InputElastic.ProxyMode = nil
		} else {
			r.InputElastic.ProxyMode = &tfTypes.InputElasticProxyMode{}
			if resp.InputElastic.ProxyMode.AuthType != nil {
				r.InputElastic.ProxyMode.AuthType = types.StringValue(string(*resp.InputElastic.ProxyMode.AuthType))
			} else {
				r.InputElastic.ProxyMode.AuthType = types.StringNull()
			}
			r.InputElastic.ProxyMode.Enabled = types.BoolPointerValue(resp.InputElastic.ProxyMode.Enabled)
			r.InputElastic.ProxyMode.RejectUnauthorized = types.BoolPointerValue(resp.InputElastic.ProxyMode.RejectUnauthorized)
			r.InputElastic.ProxyMode.RemoveHeaders = make([]types.String, 0, len(resp.InputElastic.ProxyMode.RemoveHeaders))
			for _, v := range resp.InputElastic.ProxyMode.RemoveHeaders {
				r.InputElastic.ProxyMode.RemoveHeaders = append(r.InputElastic.ProxyMode.RemoveHeaders, types.StringValue(v))
			}
			r.InputElastic.ProxyMode.TimeoutSec = types.Float64PointerValue(resp.InputElastic.ProxyMode.TimeoutSec)
			r.InputElastic.ProxyMode.URL = types.StringPointerValue(resp.InputElastic.ProxyMode.URL)
		}
		r.InputElastic.RequestTimeout = types.Float64PointerValue(resp.InputElastic.RequestTimeout)
		r.InputElastic.SendToRoutes = types.BoolPointerValue(resp.InputElastic.SendToRoutes)
		r.InputElastic.SocketTimeout = types.Float64PointerValue(resp.InputElastic.SocketTimeout)
		r.InputElastic.Streamtags = make([]types.String, 0, len(resp.InputElastic.Streamtags))
		for _, v := range resp.InputElastic.Streamtags {
			r.InputElastic.Streamtags = append(r.InputElastic.Streamtags, types.StringValue(v))
		}
		if resp.InputElastic.TLS == nil {
			r.InputElastic.TLS = nil
		} else {
			r.InputElastic.TLS = &tfTypes.InputElasticTLSSettingsServerSide{}
			r.InputElastic.TLS.CaPath = types.StringPointerValue(resp.InputElastic.TLS.CaPath)
			r.InputElastic.TLS.CertificateName = types.StringPointerValue(resp.InputElastic.TLS.CertificateName)
			r.InputElastic.TLS.CertPath = types.StringPointerValue(resp.InputElastic.TLS.CertPath)
			if resp.InputElastic.TLS.CommonNameRegex == nil {
				r.InputElastic.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult5, _ := json.Marshal(resp.InputElastic.TLS.CommonNameRegex)
				r.InputElastic.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult5))
			}
			r.InputElastic.TLS.Disabled = types.BoolPointerValue(resp.InputElastic.TLS.Disabled)
			if resp.InputElastic.TLS.MaxVersion != nil {
				r.InputElastic.TLS.MaxVersion = types.StringValue(string(*resp.InputElastic.TLS.MaxVersion))
			} else {
				r.InputElastic.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputElastic.TLS.MinVersion != nil {
				r.InputElastic.TLS.MinVersion = types.StringValue(string(*resp.InputElastic.TLS.MinVersion))
			} else {
				r.InputElastic.TLS.MinVersion = types.StringNull()
			}
			r.InputElastic.TLS.Passphrase = types.StringPointerValue(resp.InputElastic.TLS.Passphrase)
			r.InputElastic.TLS.PrivKeyPath = types.StringPointerValue(resp.InputElastic.TLS.PrivKeyPath)
			if resp.InputElastic.TLS.RejectUnauthorized == nil {
				r.InputElastic.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult5, _ := json.Marshal(resp.InputElastic.TLS.RejectUnauthorized)
				r.InputElastic.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult5))
			}
			r.InputElastic.TLS.RequestCert = types.BoolPointerValue(resp.InputElastic.TLS.RequestCert)
		}
		if resp.InputElastic.Type != nil {
			r.InputElastic.Type = types.StringValue(string(*resp.InputElastic.Type))
		} else {
			r.InputElastic.Type = types.StringNull()
		}
		r.InputElastic.Username = types.StringPointerValue(resp.InputElastic.Username)
	}
	if resp.InputEventhub != nil {
		r.InputEventhub = &tfTypes.InputEventhub{}
		r.InputEventhub.AuthenticationTimeout = types.Float64PointerValue(resp.InputEventhub.AuthenticationTimeout)
		r.InputEventhub.AutoCommitInterval = types.Float64PointerValue(resp.InputEventhub.AutoCommitInterval)
		r.InputEventhub.AutoCommitThreshold = types.Float64PointerValue(resp.InputEventhub.AutoCommitThreshold)
		r.InputEventhub.BackoffRate = types.Float64PointerValue(resp.InputEventhub.BackoffRate)
		r.InputEventhub.Brokers = make([]types.String, 0, len(resp.InputEventhub.Brokers))
		for _, v := range resp.InputEventhub.Brokers {
			r.InputEventhub.Brokers = append(r.InputEventhub.Brokers, types.StringValue(v))
		}
		r.InputEventhub.Connections = []tfTypes.InputEventhubConnection{}
		if len(r.InputEventhub.Connections) > len(resp.InputEventhub.Connections) {
			r.InputEventhub.Connections = r.InputEventhub.Connections[:len(resp.InputEventhub.Connections)]
		}
		for connectionsCount14, connectionsItem14 := range resp.InputEventhub.Connections {
			var connections14 tfTypes.InputEventhubConnection
			connections14.Output = types.StringValue(connectionsItem14.Output)
			connections14.Pipeline = types.StringPointerValue(connectionsItem14.Pipeline)
			if connectionsCount14+1 > len(r.InputEventhub.Connections) {
				r.InputEventhub.Connections = append(r.InputEventhub.Connections, connections14)
			} else {
				r.InputEventhub.Connections[connectionsCount14].Output = connections14.Output
				r.InputEventhub.Connections[connectionsCount14].Pipeline = connections14.Pipeline
			}
		}
		r.InputEventhub.ConnectionTimeout = types.Float64PointerValue(resp.InputEventhub.ConnectionTimeout)
		r.InputEventhub.Description = types.StringPointerValue(resp.InputEventhub.Description)
		r.InputEventhub.Disabled = types.BoolPointerValue(resp.InputEventhub.Disabled)
		r.InputEventhub.Environment = types.StringPointerValue(resp.InputEventhub.Environment)
		r.InputEventhub.FromBeginning = types.BoolPointerValue(resp.InputEventhub.FromBeginning)
		r.InputEventhub.GroupID = types.StringPointerValue(resp.InputEventhub.GroupID)
		r.InputEventhub.HeartbeatInterval = types.Float64PointerValue(resp.InputEventhub.HeartbeatInterval)
		r.InputEventhub.ID = types.StringPointerValue(resp.InputEventhub.ID)
		r.InputEventhub.InitialBackoff = types.Float64PointerValue(resp.InputEventhub.InitialBackoff)
		r.InputEventhub.MaxBackOff = types.Float64PointerValue(resp.InputEventhub.MaxBackOff)
		r.InputEventhub.MaxBytes = types.Float64PointerValue(resp.InputEventhub.MaxBytes)
		r.InputEventhub.MaxBytesPerPartition = types.Float64PointerValue(resp.InputEventhub.MaxBytesPerPartition)
		r.InputEventhub.MaxRetries = types.Float64PointerValue(resp.InputEventhub.MaxRetries)
		r.InputEventhub.MaxSocketErrors = types.Float64PointerValue(resp.InputEventhub.MaxSocketErrors)
		r.InputEventhub.Metadata = []tfTypes.InputEventhubMetadatum{}
		if len(r.InputEventhub.Metadata) > len(resp.InputEventhub.Metadata) {
			r.InputEventhub.Metadata = r.InputEventhub.Metadata[:len(resp.InputEventhub.Metadata)]
		}
		for metadataCount14, metadataItem14 := range resp.InputEventhub.Metadata {
			var metadata14 tfTypes.InputEventhubMetadatum
			metadata14.Name = types.StringValue(metadataItem14.Name)
			metadata14.Value = types.StringValue(metadataItem14.Value)
			if metadataCount14+1 > len(r.InputEventhub.Metadata) {
				r.InputEventhub.Metadata = append(r.InputEventhub.Metadata, metadata14)
			} else {
				r.InputEventhub.Metadata[metadataCount14].Name = metadata14.Name
				r.InputEventhub.Metadata[metadataCount14].Value = metadata14.Value
			}
		}
		r.InputEventhub.MinimizeDuplicates = types.BoolPointerValue(resp.InputEventhub.MinimizeDuplicates)
		r.InputEventhub.Pipeline = types.StringPointerValue(resp.InputEventhub.Pipeline)
		if resp.InputEventhub.Pq == nil {
			r.InputEventhub.Pq = nil
		} else {
			r.InputEventhub.Pq = &tfTypes.InputEventhubPq{}
			r.InputEventhub.Pq.CommitFrequency = types.Float64PointerValue(resp.InputEventhub.Pq.CommitFrequency)
			if resp.InputEventhub.Pq.Compress != nil {
				r.InputEventhub.Pq.Compress = types.StringValue(string(*resp.InputEventhub.Pq.Compress))
			} else {
				r.InputEventhub.Pq.Compress = types.StringNull()
			}
			r.InputEventhub.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputEventhub.Pq.MaxBufferSize)
			r.InputEventhub.Pq.MaxFileSize = types.StringPointerValue(resp.InputEventhub.Pq.MaxFileSize)
			r.InputEventhub.Pq.MaxSize = types.StringPointerValue(resp.InputEventhub.Pq.MaxSize)
			if resp.InputEventhub.Pq.Mode != nil {
				r.InputEventhub.Pq.Mode = types.StringValue(string(*resp.InputEventhub.Pq.Mode))
			} else {
				r.InputEventhub.Pq.Mode = types.StringNull()
			}
			r.InputEventhub.Pq.Path = types.StringPointerValue(resp.InputEventhub.Pq.Path)
		}
		r.InputEventhub.PqEnabled = types.BoolPointerValue(resp.InputEventhub.PqEnabled)
		r.InputEventhub.ReauthenticationThreshold = types.Float64PointerValue(resp.InputEventhub.ReauthenticationThreshold)
		r.InputEventhub.RebalanceTimeout = types.Float64PointerValue(resp.InputEventhub.RebalanceTimeout)
		r.InputEventhub.RequestTimeout = types.Float64PointerValue(resp.InputEventhub.RequestTimeout)
		if resp.InputEventhub.Sasl == nil {
			r.InputEventhub.Sasl = nil
		} else {
			r.InputEventhub.Sasl = &tfTypes.InputEventhubAuthentication{}
			r.InputEventhub.Sasl.Disabled = types.BoolPointerValue(resp.InputEventhub.Sasl.Disabled)
			if resp.InputEventhub.Sasl.Mechanism != nil {
				r.InputEventhub.Sasl.Mechanism = types.StringValue(string(*resp.InputEventhub.Sasl.Mechanism))
			} else {
				r.InputEventhub.Sasl.Mechanism = types.StringNull()
			}
		}
		r.InputEventhub.SendToRoutes = types.BoolPointerValue(resp.InputEventhub.SendToRoutes)
		r.InputEventhub.SessionTimeout = types.Float64PointerValue(resp.InputEventhub.SessionTimeout)
		r.InputEventhub.Streamtags = make([]types.String, 0, len(resp.InputEventhub.Streamtags))
		for _, v := range resp.InputEventhub.Streamtags {
			r.InputEventhub.Streamtags = append(r.InputEventhub.Streamtags, types.StringValue(v))
		}
		if resp.InputEventhub.TLS == nil {
			r.InputEventhub.TLS = nil
		} else {
			r.InputEventhub.TLS = &tfTypes.InputEventhubTLSSettingsClientSide{}
			r.InputEventhub.TLS.Disabled = types.BoolPointerValue(resp.InputEventhub.TLS.Disabled)
			r.InputEventhub.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputEventhub.TLS.RejectUnauthorized)
		}
		r.InputEventhub.Topics = make([]types.String, 0, len(resp.InputEventhub.Topics))
		for _, v := range resp.InputEventhub.Topics {
			r.InputEventhub.Topics = append(r.InputEventhub.Topics, types.StringValue(v))
		}
		if resp.InputEventhub.Type != nil {
			r.InputEventhub.Type = types.StringValue(string(*resp.InputEventhub.Type))
		} else {
			r.InputEventhub.Type = types.StringNull()
		}
	}
	if resp.InputExec != nil {
		r.InputExec = &tfTypes.InputExec{}
		r.InputExec.BreakerRulesets = make([]types.String, 0, len(resp.InputExec.BreakerRulesets))
		for _, v := range resp.InputExec.BreakerRulesets {
			r.InputExec.BreakerRulesets = append(r.InputExec.BreakerRulesets, types.StringValue(v))
		}
		r.InputExec.Command = types.StringValue(resp.InputExec.Command)
		r.InputExec.Connections = []tfTypes.InputExecConnection{}
		if len(r.InputExec.Connections) > len(resp.InputExec.Connections) {
			r.InputExec.Connections = r.InputExec.Connections[:len(resp.InputExec.Connections)]
		}
		for connectionsCount15, connectionsItem15 := range resp.InputExec.Connections {
			var connections15 tfTypes.InputExecConnection
			connections15.Output = types.StringValue(connectionsItem15.Output)
			connections15.Pipeline = types.StringPointerValue(connectionsItem15.Pipeline)
			if connectionsCount15+1 > len(r.InputExec.Connections) {
				r.InputExec.Connections = append(r.InputExec.Connections, connections15)
			} else {
				r.InputExec.Connections[connectionsCount15].Output = connections15.Output
				r.InputExec.Connections[connectionsCount15].Pipeline = connections15.Pipeline
			}
		}
		r.InputExec.CronSchedule = types.StringPointerValue(resp.InputExec.CronSchedule)
		r.InputExec.Description = types.StringPointerValue(resp.InputExec.Description)
		r.InputExec.Disabled = types.BoolPointerValue(resp.InputExec.Disabled)
		r.InputExec.Environment = types.StringPointerValue(resp.InputExec.Environment)
		r.InputExec.ID = types.StringPointerValue(resp.InputExec.ID)
		r.InputExec.Interval = types.Float64PointerValue(resp.InputExec.Interval)
		r.InputExec.Metadata = []tfTypes.InputExecMetadatum{}
		if len(r.InputExec.Metadata) > len(resp.InputExec.Metadata) {
			r.InputExec.Metadata = r.InputExec.Metadata[:len(resp.InputExec.Metadata)]
		}
		for metadataCount15, metadataItem15 := range resp.InputExec.Metadata {
			var metadata15 tfTypes.InputExecMetadatum
			metadata15.Name = types.StringValue(metadataItem15.Name)
			metadata15.Value = types.StringValue(metadataItem15.Value)
			if metadataCount15+1 > len(r.InputExec.Metadata) {
				r.InputExec.Metadata = append(r.InputExec.Metadata, metadata15)
			} else {
				r.InputExec.Metadata[metadataCount15].Name = metadata15.Name
				r.InputExec.Metadata[metadataCount15].Value = metadata15.Value
			}
		}
		r.InputExec.Pipeline = types.StringPointerValue(resp.InputExec.Pipeline)
		if resp.InputExec.Pq == nil {
			r.InputExec.Pq = nil
		} else {
			r.InputExec.Pq = &tfTypes.InputExecPq{}
			r.InputExec.Pq.CommitFrequency = types.Float64PointerValue(resp.InputExec.Pq.CommitFrequency)
			if resp.InputExec.Pq.Compress != nil {
				r.InputExec.Pq.Compress = types.StringValue(string(*resp.InputExec.Pq.Compress))
			} else {
				r.InputExec.Pq.Compress = types.StringNull()
			}
			r.InputExec.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputExec.Pq.MaxBufferSize)
			r.InputExec.Pq.MaxFileSize = types.StringPointerValue(resp.InputExec.Pq.MaxFileSize)
			r.InputExec.Pq.MaxSize = types.StringPointerValue(resp.InputExec.Pq.MaxSize)
			if resp.InputExec.Pq.Mode != nil {
				r.InputExec.Pq.Mode = types.StringValue(string(*resp.InputExec.Pq.Mode))
			} else {
				r.InputExec.Pq.Mode = types.StringNull()
			}
			r.InputExec.Pq.Path = types.StringPointerValue(resp.InputExec.Pq.Path)
		}
		r.InputExec.PqEnabled = types.BoolPointerValue(resp.InputExec.PqEnabled)
		r.InputExec.Retries = types.Float64PointerValue(resp.InputExec.Retries)
		if resp.InputExec.ScheduleType != nil {
			r.InputExec.ScheduleType = types.StringValue(string(*resp.InputExec.ScheduleType))
		} else {
			r.InputExec.ScheduleType = types.StringNull()
		}
		r.InputExec.SendToRoutes = types.BoolPointerValue(resp.InputExec.SendToRoutes)
		r.InputExec.StaleChannelFlushMs = types.Float64PointerValue(resp.InputExec.StaleChannelFlushMs)
		r.InputExec.Streamtags = make([]types.String, 0, len(resp.InputExec.Streamtags))
		for _, v := range resp.InputExec.Streamtags {
			r.InputExec.Streamtags = append(r.InputExec.Streamtags, types.StringValue(v))
		}
		r.InputExec.Type = types.StringValue(string(resp.InputExec.Type))
	}
	if resp.InputFile != nil {
		r.InputFile = &tfTypes.InputFile{}
		r.InputFile.BreakerRulesets = make([]types.String, 0, len(resp.InputFile.BreakerRulesets))
		for _, v := range resp.InputFile.BreakerRulesets {
			r.InputFile.BreakerRulesets = append(r.InputFile.BreakerRulesets, types.StringValue(v))
		}
		r.InputFile.CheckFileModTime = types.BoolPointerValue(resp.InputFile.CheckFileModTime)
		r.InputFile.Connections = []tfTypes.InputFileConnection{}
		if len(r.InputFile.Connections) > len(resp.InputFile.Connections) {
			r.InputFile.Connections = r.InputFile.Connections[:len(resp.InputFile.Connections)]
		}
		for connectionsCount16, connectionsItem16 := range resp.InputFile.Connections {
			var connections16 tfTypes.InputFileConnection
			connections16.Output = types.StringValue(connectionsItem16.Output)
			connections16.Pipeline = types.StringPointerValue(connectionsItem16.Pipeline)
			if connectionsCount16+1 > len(r.InputFile.Connections) {
				r.InputFile.Connections = append(r.InputFile.Connections, connections16)
			} else {
				r.InputFile.Connections[connectionsCount16].Output = connections16.Output
				r.InputFile.Connections[connectionsCount16].Pipeline = connections16.Pipeline
			}
		}
		r.InputFile.DeleteFiles = types.BoolPointerValue(resp.InputFile.DeleteFiles)
		r.InputFile.Depth = types.Float64PointerValue(resp.InputFile.Depth)
		r.InputFile.Description = types.StringPointerValue(resp.InputFile.Description)
		r.InputFile.Disabled = types.BoolPointerValue(resp.InputFile.Disabled)
		r.InputFile.Environment = types.StringPointerValue(resp.InputFile.Environment)
		r.InputFile.Filenames = make([]types.String, 0, len(resp.InputFile.Filenames))
		for _, v := range resp.InputFile.Filenames {
			r.InputFile.Filenames = append(r.InputFile.Filenames, types.StringValue(v))
		}
		r.InputFile.ForceText = types.BoolPointerValue(resp.InputFile.ForceText)
		r.InputFile.HashLen = types.Float64PointerValue(resp.InputFile.HashLen)
		r.InputFile.ID = types.StringValue(resp.InputFile.ID)
		r.InputFile.IdleTimeout = types.Float64PointerValue(resp.InputFile.IdleTimeout)
		r.InputFile.IncludeUnidentifiableBinary = types.BoolPointerValue(resp.InputFile.IncludeUnidentifiableBinary)
		r.InputFile.Interval = types.Float64PointerValue(resp.InputFile.Interval)
		r.InputFile.MaxAgeDur = types.StringPointerValue(resp.InputFile.MaxAgeDur)
		r.InputFile.Metadata = []tfTypes.InputFileMetadatum{}
		if len(r.InputFile.Metadata) > len(resp.InputFile.Metadata) {
			r.InputFile.Metadata = r.InputFile.Metadata[:len(resp.InputFile.Metadata)]
		}
		for metadataCount16, metadataItem16 := range resp.InputFile.Metadata {
			var metadata16 tfTypes.InputFileMetadatum
			metadata16.Name = types.StringValue(metadataItem16.Name)
			metadata16.Value = types.StringValue(metadataItem16.Value)
			if metadataCount16+1 > len(r.InputFile.Metadata) {
				r.InputFile.Metadata = append(r.InputFile.Metadata, metadata16)
			} else {
				r.InputFile.Metadata[metadataCount16].Name = metadata16.Name
				r.InputFile.Metadata[metadataCount16].Value = metadata16.Value
			}
		}
		if resp.InputFile.Mode != nil {
			r.InputFile.Mode = types.StringValue(string(*resp.InputFile.Mode))
		} else {
			r.InputFile.Mode = types.StringNull()
		}
		r.InputFile.Path = types.StringPointerValue(resp.InputFile.Path)
		r.InputFile.Pipeline = types.StringPointerValue(resp.InputFile.Pipeline)
		if resp.InputFile.Pq == nil {
			r.InputFile.Pq = nil
		} else {
			r.InputFile.Pq = &tfTypes.InputFilePq{}
			r.InputFile.Pq.CommitFrequency = types.Float64PointerValue(resp.InputFile.Pq.CommitFrequency)
			if resp.InputFile.Pq.Compress != nil {
				r.InputFile.Pq.Compress = types.StringValue(string(*resp.InputFile.Pq.Compress))
			} else {
				r.InputFile.Pq.Compress = types.StringNull()
			}
			r.InputFile.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputFile.Pq.MaxBufferSize)
			r.InputFile.Pq.MaxFileSize = types.StringPointerValue(resp.InputFile.Pq.MaxFileSize)
			r.InputFile.Pq.MaxSize = types.StringPointerValue(resp.InputFile.Pq.MaxSize)
			if resp.InputFile.Pq.Mode != nil {
				r.InputFile.Pq.Mode = types.StringValue(string(*resp.InputFile.Pq.Mode))
			} else {
				r.InputFile.Pq.Mode = types.StringNull()
			}
			r.InputFile.Pq.Path = types.StringPointerValue(resp.InputFile.Pq.Path)
		}
		r.InputFile.PqEnabled = types.BoolPointerValue(resp.InputFile.PqEnabled)
		r.InputFile.SendToRoutes = types.BoolPointerValue(resp.InputFile.SendToRoutes)
		r.InputFile.StaleChannelFlushMs = types.Float64PointerValue(resp.InputFile.StaleChannelFlushMs)
		r.InputFile.Streamtags = make([]types.String, 0, len(resp.InputFile.Streamtags))
		for _, v := range resp.InputFile.Streamtags {
			r.InputFile.Streamtags = append(r.InputFile.Streamtags, types.StringValue(v))
		}
		r.InputFile.SuppressMissingPathErrors = types.BoolPointerValue(resp.InputFile.SuppressMissingPathErrors)
		r.InputFile.TailOnly = types.BoolPointerValue(resp.InputFile.TailOnly)
		r.InputFile.Type = types.StringValue(string(resp.InputFile.Type))
	}
	if resp.InputFirehose != nil {
		r.InputFirehose = &tfTypes.InputFirehose{}
		r.InputFirehose.ActivityLogSampleRate = types.Float64PointerValue(resp.InputFirehose.ActivityLogSampleRate)
		r.InputFirehose.AuthTokens = make([]types.String, 0, len(resp.InputFirehose.AuthTokens))
		for _, v := range resp.InputFirehose.AuthTokens {
			r.InputFirehose.AuthTokens = append(r.InputFirehose.AuthTokens, types.StringValue(v))
		}
		r.InputFirehose.CaptureHeaders = types.BoolPointerValue(resp.InputFirehose.CaptureHeaders)
		r.InputFirehose.Connections = []tfTypes.InputFirehoseConnection{}
		if len(r.InputFirehose.Connections) > len(resp.InputFirehose.Connections) {
			r.InputFirehose.Connections = r.InputFirehose.Connections[:len(resp.InputFirehose.Connections)]
		}
		for connectionsCount17, connectionsItem17 := range resp.InputFirehose.Connections {
			var connections17 tfTypes.InputFirehoseConnection
			connections17.Output = types.StringValue(connectionsItem17.Output)
			connections17.Pipeline = types.StringPointerValue(connectionsItem17.Pipeline)
			if connectionsCount17+1 > len(r.InputFirehose.Connections) {
				r.InputFirehose.Connections = append(r.InputFirehose.Connections, connections17)
			} else {
				r.InputFirehose.Connections[connectionsCount17].Output = connections17.Output
				r.InputFirehose.Connections[connectionsCount17].Pipeline = connections17.Pipeline
			}
		}
		r.InputFirehose.Description = types.StringPointerValue(resp.InputFirehose.Description)
		r.InputFirehose.Disabled = types.BoolPointerValue(resp.InputFirehose.Disabled)
		r.InputFirehose.EnableHealthCheck = types.BoolPointerValue(resp.InputFirehose.EnableHealthCheck)
		r.InputFirehose.EnableProxyHeader = types.BoolPointerValue(resp.InputFirehose.EnableProxyHeader)
		r.InputFirehose.Environment = types.StringPointerValue(resp.InputFirehose.Environment)
		r.InputFirehose.Host = types.StringPointerValue(resp.InputFirehose.Host)
		r.InputFirehose.ID = types.StringPointerValue(resp.InputFirehose.ID)
		r.InputFirehose.IPAllowlistRegex = types.StringPointerValue(resp.InputFirehose.IPAllowlistRegex)
		r.InputFirehose.IPDenylistRegex = types.StringPointerValue(resp.InputFirehose.IPDenylistRegex)
		r.InputFirehose.KeepAliveTimeout = types.Float64PointerValue(resp.InputFirehose.KeepAliveTimeout)
		r.InputFirehose.MaxActiveReq = types.Float64PointerValue(resp.InputFirehose.MaxActiveReq)
		r.InputFirehose.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputFirehose.MaxRequestsPerSocket)
		r.InputFirehose.Metadata = []tfTypes.InputFirehoseMetadatum{}
		if len(r.InputFirehose.Metadata) > len(resp.InputFirehose.Metadata) {
			r.InputFirehose.Metadata = r.InputFirehose.Metadata[:len(resp.InputFirehose.Metadata)]
		}
		for metadataCount17, metadataItem17 := range resp.InputFirehose.Metadata {
			var metadata17 tfTypes.InputFirehoseMetadatum
			metadata17.Name = types.StringValue(metadataItem17.Name)
			metadata17.Value = types.StringValue(metadataItem17.Value)
			if metadataCount17+1 > len(r.InputFirehose.Metadata) {
				r.InputFirehose.Metadata = append(r.InputFirehose.Metadata, metadata17)
			} else {
				r.InputFirehose.Metadata[metadataCount17].Name = metadata17.Name
				r.InputFirehose.Metadata[metadataCount17].Value = metadata17.Value
			}
		}
		r.InputFirehose.Pipeline = types.StringPointerValue(resp.InputFirehose.Pipeline)
		r.InputFirehose.Port = types.Float64Value(resp.InputFirehose.Port)
		if resp.InputFirehose.Pq == nil {
			r.InputFirehose.Pq = nil
		} else {
			r.InputFirehose.Pq = &tfTypes.InputFirehosePq{}
			r.InputFirehose.Pq.CommitFrequency = types.Float64PointerValue(resp.InputFirehose.Pq.CommitFrequency)
			if resp.InputFirehose.Pq.Compress != nil {
				r.InputFirehose.Pq.Compress = types.StringValue(string(*resp.InputFirehose.Pq.Compress))
			} else {
				r.InputFirehose.Pq.Compress = types.StringNull()
			}
			r.InputFirehose.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputFirehose.Pq.MaxBufferSize)
			r.InputFirehose.Pq.MaxFileSize = types.StringPointerValue(resp.InputFirehose.Pq.MaxFileSize)
			r.InputFirehose.Pq.MaxSize = types.StringPointerValue(resp.InputFirehose.Pq.MaxSize)
			if resp.InputFirehose.Pq.Mode != nil {
				r.InputFirehose.Pq.Mode = types.StringValue(string(*resp.InputFirehose.Pq.Mode))
			} else {
				r.InputFirehose.Pq.Mode = types.StringNull()
			}
			r.InputFirehose.Pq.Path = types.StringPointerValue(resp.InputFirehose.Pq.Path)
		}
		r.InputFirehose.PqEnabled = types.BoolPointerValue(resp.InputFirehose.PqEnabled)
		r.InputFirehose.RequestTimeout = types.Float64PointerValue(resp.InputFirehose.RequestTimeout)
		r.InputFirehose.SendToRoutes = types.BoolPointerValue(resp.InputFirehose.SendToRoutes)
		r.InputFirehose.SocketTimeout = types.Float64PointerValue(resp.InputFirehose.SocketTimeout)
		r.InputFirehose.Streamtags = make([]types.String, 0, len(resp.InputFirehose.Streamtags))
		for _, v := range resp.InputFirehose.Streamtags {
			r.InputFirehose.Streamtags = append(r.InputFirehose.Streamtags, types.StringValue(v))
		}
		if resp.InputFirehose.TLS == nil {
			r.InputFirehose.TLS = nil
		} else {
			r.InputFirehose.TLS = &tfTypes.InputFirehoseTLSSettingsServerSide{}
			r.InputFirehose.TLS.CaPath = types.StringPointerValue(resp.InputFirehose.TLS.CaPath)
			r.InputFirehose.TLS.CertificateName = types.StringPointerValue(resp.InputFirehose.TLS.CertificateName)
			r.InputFirehose.TLS.CertPath = types.StringPointerValue(resp.InputFirehose.TLS.CertPath)
			if resp.InputFirehose.TLS.CommonNameRegex == nil {
				r.InputFirehose.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult6, _ := json.Marshal(resp.InputFirehose.TLS.CommonNameRegex)
				r.InputFirehose.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult6))
			}
			r.InputFirehose.TLS.Disabled = types.BoolPointerValue(resp.InputFirehose.TLS.Disabled)
			if resp.InputFirehose.TLS.MaxVersion != nil {
				r.InputFirehose.TLS.MaxVersion = types.StringValue(string(*resp.InputFirehose.TLS.MaxVersion))
			} else {
				r.InputFirehose.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputFirehose.TLS.MinVersion != nil {
				r.InputFirehose.TLS.MinVersion = types.StringValue(string(*resp.InputFirehose.TLS.MinVersion))
			} else {
				r.InputFirehose.TLS.MinVersion = types.StringNull()
			}
			r.InputFirehose.TLS.Passphrase = types.StringPointerValue(resp.InputFirehose.TLS.Passphrase)
			r.InputFirehose.TLS.PrivKeyPath = types.StringPointerValue(resp.InputFirehose.TLS.PrivKeyPath)
			if resp.InputFirehose.TLS.RejectUnauthorized == nil {
				r.InputFirehose.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult6, _ := json.Marshal(resp.InputFirehose.TLS.RejectUnauthorized)
				r.InputFirehose.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult6))
			}
			r.InputFirehose.TLS.RequestCert = types.BoolPointerValue(resp.InputFirehose.TLS.RequestCert)
		}
		if resp.InputFirehose.Type != nil {
			r.InputFirehose.Type = types.StringValue(string(*resp.InputFirehose.Type))
		} else {
			r.InputFirehose.Type = types.StringNull()
		}
	}
	if resp.InputGooglePubsub != nil {
		r.InputGooglePubsub = &tfTypes.InputGooglePubsub{}
		r.InputGooglePubsub.Concurrency = types.Float64PointerValue(resp.InputGooglePubsub.Concurrency)
		r.InputGooglePubsub.Connections = []tfTypes.InputGooglePubsubConnection{}
		if len(r.InputGooglePubsub.Connections) > len(resp.InputGooglePubsub.Connections) {
			r.InputGooglePubsub.Connections = r.InputGooglePubsub.Connections[:len(resp.InputGooglePubsub.Connections)]
		}
		for connectionsCount18, connectionsItem18 := range resp.InputGooglePubsub.Connections {
			var connections18 tfTypes.InputGooglePubsubConnection
			connections18.Output = types.StringValue(connectionsItem18.Output)
			connections18.Pipeline = types.StringPointerValue(connectionsItem18.Pipeline)
			if connectionsCount18+1 > len(r.InputGooglePubsub.Connections) {
				r.InputGooglePubsub.Connections = append(r.InputGooglePubsub.Connections, connections18)
			} else {
				r.InputGooglePubsub.Connections[connectionsCount18].Output = connections18.Output
				r.InputGooglePubsub.Connections[connectionsCount18].Pipeline = connections18.Pipeline
			}
		}
		r.InputGooglePubsub.CreateSubscription = types.BoolPointerValue(resp.InputGooglePubsub.CreateSubscription)
		r.InputGooglePubsub.CreateTopic = types.BoolPointerValue(resp.InputGooglePubsub.CreateTopic)
		r.InputGooglePubsub.Description = types.StringPointerValue(resp.InputGooglePubsub.Description)
		r.InputGooglePubsub.Disabled = types.BoolPointerValue(resp.InputGooglePubsub.Disabled)
		r.InputGooglePubsub.Environment = types.StringPointerValue(resp.InputGooglePubsub.Environment)
		if resp.InputGooglePubsub.GoogleAuthMethod != nil {
			r.InputGooglePubsub.GoogleAuthMethod = types.StringValue(string(*resp.InputGooglePubsub.GoogleAuthMethod))
		} else {
			r.InputGooglePubsub.GoogleAuthMethod = types.StringNull()
		}
		r.InputGooglePubsub.ID = types.StringPointerValue(resp.InputGooglePubsub.ID)
		r.InputGooglePubsub.MaxBacklog = types.Float64PointerValue(resp.InputGooglePubsub.MaxBacklog)
		r.InputGooglePubsub.Metadata = []tfTypes.InputGooglePubsubMetadatum{}
		if len(r.InputGooglePubsub.Metadata) > len(resp.InputGooglePubsub.Metadata) {
			r.InputGooglePubsub.Metadata = r.InputGooglePubsub.Metadata[:len(resp.InputGooglePubsub.Metadata)]
		}
		for metadataCount18, metadataItem18 := range resp.InputGooglePubsub.Metadata {
			var metadata18 tfTypes.InputGooglePubsubMetadatum
			metadata18.Name = types.StringValue(metadataItem18.Name)
			metadata18.Value = types.StringValue(metadataItem18.Value)
			if metadataCount18+1 > len(r.InputGooglePubsub.Metadata) {
				r.InputGooglePubsub.Metadata = append(r.InputGooglePubsub.Metadata, metadata18)
			} else {
				r.InputGooglePubsub.Metadata[metadataCount18].Name = metadata18.Name
				r.InputGooglePubsub.Metadata[metadataCount18].Value = metadata18.Value
			}
		}
		r.InputGooglePubsub.OrderedDelivery = types.BoolPointerValue(resp.InputGooglePubsub.OrderedDelivery)
		r.InputGooglePubsub.Pipeline = types.StringPointerValue(resp.InputGooglePubsub.Pipeline)
		if resp.InputGooglePubsub.Pq == nil {
			r.InputGooglePubsub.Pq = nil
		} else {
			r.InputGooglePubsub.Pq = &tfTypes.InputGooglePubsubPq{}
			r.InputGooglePubsub.Pq.CommitFrequency = types.Float64PointerValue(resp.InputGooglePubsub.Pq.CommitFrequency)
			if resp.InputGooglePubsub.Pq.Compress != nil {
				r.InputGooglePubsub.Pq.Compress = types.StringValue(string(*resp.InputGooglePubsub.Pq.Compress))
			} else {
				r.InputGooglePubsub.Pq.Compress = types.StringNull()
			}
			r.InputGooglePubsub.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputGooglePubsub.Pq.MaxBufferSize)
			r.InputGooglePubsub.Pq.MaxFileSize = types.StringPointerValue(resp.InputGooglePubsub.Pq.MaxFileSize)
			r.InputGooglePubsub.Pq.MaxSize = types.StringPointerValue(resp.InputGooglePubsub.Pq.MaxSize)
			if resp.InputGooglePubsub.Pq.Mode != nil {
				r.InputGooglePubsub.Pq.Mode = types.StringValue(string(*resp.InputGooglePubsub.Pq.Mode))
			} else {
				r.InputGooglePubsub.Pq.Mode = types.StringNull()
			}
			r.InputGooglePubsub.Pq.Path = types.StringPointerValue(resp.InputGooglePubsub.Pq.Path)
		}
		r.InputGooglePubsub.PqEnabled = types.BoolPointerValue(resp.InputGooglePubsub.PqEnabled)
		r.InputGooglePubsub.Region = types.StringPointerValue(resp.InputGooglePubsub.Region)
		r.InputGooglePubsub.RequestTimeout = types.Float64PointerValue(resp.InputGooglePubsub.RequestTimeout)
		r.InputGooglePubsub.Secret = types.StringPointerValue(resp.InputGooglePubsub.Secret)
		r.InputGooglePubsub.SendToRoutes = types.BoolPointerValue(resp.InputGooglePubsub.SendToRoutes)
		r.InputGooglePubsub.ServiceAccountCredentials = types.StringPointerValue(resp.InputGooglePubsub.ServiceAccountCredentials)
		r.InputGooglePubsub.Streamtags = make([]types.String, 0, len(resp.InputGooglePubsub.Streamtags))
		for _, v := range resp.InputGooglePubsub.Streamtags {
			r.InputGooglePubsub.Streamtags = append(r.InputGooglePubsub.Streamtags, types.StringValue(v))
		}
		r.InputGooglePubsub.SubscriptionName = types.StringValue(resp.InputGooglePubsub.SubscriptionName)
		r.InputGooglePubsub.TopicName = types.StringValue(resp.InputGooglePubsub.TopicName)
		if resp.InputGooglePubsub.Type != nil {
			r.InputGooglePubsub.Type = types.StringValue(string(*resp.InputGooglePubsub.Type))
		} else {
			r.InputGooglePubsub.Type = types.StringNull()
		}
	}
	if resp.InputGrafana != nil {
		r.InputGrafana = &tfTypes.InputGrafana{}
		if resp.InputGrafana.InputGrafanaGrafana1 != nil {
			r.InputGrafana.InputGrafanaGrafana1 = &tfTypes.InputGrafanaGrafana1{}
			r.InputGrafana.InputGrafanaGrafana1.ActivityLogSampleRate = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.ActivityLogSampleRate)
			r.InputGrafana.InputGrafanaGrafana1.CaptureHeaders = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.CaptureHeaders)
			r.InputGrafana.InputGrafanaGrafana1.Connections = []tfTypes.InputGrafanaConnection1{}
			if len(r.InputGrafana.InputGrafanaGrafana1.Connections) > len(resp.InputGrafana.InputGrafanaGrafana1.Connections) {
				r.InputGrafana.InputGrafanaGrafana1.Connections = r.InputGrafana.InputGrafanaGrafana1.Connections[:len(resp.InputGrafana.InputGrafanaGrafana1.Connections)]
			}
			for connectionsCount19, connectionsItem19 := range resp.InputGrafana.InputGrafanaGrafana1.Connections {
				var connections19 tfTypes.InputGrafanaConnection1
				connections19.Output = types.StringValue(connectionsItem19.Output)
				connections19.Pipeline = types.StringPointerValue(connectionsItem19.Pipeline)
				if connectionsCount19+1 > len(r.InputGrafana.InputGrafanaGrafana1.Connections) {
					r.InputGrafana.InputGrafanaGrafana1.Connections = append(r.InputGrafana.InputGrafanaGrafana1.Connections, connections19)
				} else {
					r.InputGrafana.InputGrafanaGrafana1.Connections[connectionsCount19].Output = connections19.Output
					r.InputGrafana.InputGrafanaGrafana1.Connections[connectionsCount19].Pipeline = connections19.Pipeline
				}
			}
			r.InputGrafana.InputGrafanaGrafana1.Description = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Description)
			r.InputGrafana.InputGrafanaGrafana1.Disabled = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Disabled)
			r.InputGrafana.InputGrafanaGrafana1.EnableHealthCheck = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.EnableHealthCheck)
			r.InputGrafana.InputGrafanaGrafana1.EnableProxyHeader = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.EnableProxyHeader)
			r.InputGrafana.InputGrafanaGrafana1.Environment = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Environment)
			r.InputGrafana.InputGrafanaGrafana1.Host = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Host)
			r.InputGrafana.InputGrafanaGrafana1.ID = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.ID)
			r.InputGrafana.InputGrafanaGrafana1.IPAllowlistRegex = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.IPAllowlistRegex)
			r.InputGrafana.InputGrafanaGrafana1.IPDenylistRegex = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.IPDenylistRegex)
			r.InputGrafana.InputGrafanaGrafana1.KeepAliveTimeout = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.KeepAliveTimeout)
			r.InputGrafana.InputGrafanaGrafana1.LokiAPI = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAPI)
			if resp.InputGrafana.InputGrafanaGrafana1.LokiAuth == nil {
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth = &tfTypes.InputGrafanaLokiAuth1{}
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.AuthHeaderExpr = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.AuthHeaderExpr)
				if resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.AuthType != nil {
					r.InputGrafana.InputGrafanaGrafana1.LokiAuth.AuthType = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.AuthType))
				} else {
					r.InputGrafana.InputGrafanaGrafana1.LokiAuth.AuthType = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.CredentialsSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.CredentialsSecret)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.LoginURL = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.LoginURL)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders = []tfTypes.LokiAuthOauthHeader1{}
				if len(r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders) > len(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders) {
					r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders = r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders[:len(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders)]
				}
				for oauthHeadersCount, oauthHeadersItem := range resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders {
					var oauthHeaders tfTypes.LokiAuthOauthHeader1
					oauthHeaders.Name = types.StringValue(oauthHeadersItem.Name)
					oauthHeaders.Value = types.StringValue(oauthHeadersItem.Value)
					if oauthHeadersCount+1 > len(r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders) {
						r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders = append(r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders, oauthHeaders)
					} else {
						r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders[oauthHeadersCount].Name = oauthHeaders.Name
						r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthHeaders[oauthHeadersCount].Value = oauthHeaders.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams = []tfTypes.LokiAuthOauthParam1{}
				if len(r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams) > len(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams) {
					r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams = r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams[:len(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams)]
				}
				for oauthParamsCount, oauthParamsItem := range resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams {
					var oauthParams tfTypes.LokiAuthOauthParam1
					oauthParams.Name = types.StringValue(oauthParamsItem.Name)
					oauthParams.Value = types.StringValue(oauthParamsItem.Value)
					if oauthParamsCount+1 > len(r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams) {
						r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams = append(r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams, oauthParams)
					} else {
						r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams[oauthParamsCount].Name = oauthParams.Name
						r.InputGrafana.InputGrafanaGrafana1.LokiAuth.OauthParams[oauthParamsCount].Value = oauthParams.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.Password = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.Password)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.Secret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.Secret)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.SecretParamName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.SecretParamName)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.TextSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.TextSecret)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.Token = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.Token)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.TokenAttributeName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.TokenAttributeName)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.TokenTimeoutSecs = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.TokenTimeoutSecs)
				r.InputGrafana.InputGrafanaGrafana1.LokiAuth.Username = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.LokiAuth.Username)
			}
			r.InputGrafana.InputGrafanaGrafana1.MaxActiveReq = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.MaxActiveReq)
			r.InputGrafana.InputGrafanaGrafana1.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.MaxRequestsPerSocket)
			r.InputGrafana.InputGrafanaGrafana1.Metadata = []tfTypes.InputGrafanaMetadatum1{}
			if len(r.InputGrafana.InputGrafanaGrafana1.Metadata) > len(resp.InputGrafana.InputGrafanaGrafana1.Metadata) {
				r.InputGrafana.InputGrafanaGrafana1.Metadata = r.InputGrafana.InputGrafanaGrafana1.Metadata[:len(resp.InputGrafana.InputGrafanaGrafana1.Metadata)]
			}
			for metadataCount19, metadataItem19 := range resp.InputGrafana.InputGrafanaGrafana1.Metadata {
				var metadata19 tfTypes.InputGrafanaMetadatum1
				metadata19.Name = types.StringValue(metadataItem19.Name)
				metadata19.Value = types.StringValue(metadataItem19.Value)
				if metadataCount19+1 > len(r.InputGrafana.InputGrafanaGrafana1.Metadata) {
					r.InputGrafana.InputGrafanaGrafana1.Metadata = append(r.InputGrafana.InputGrafanaGrafana1.Metadata, metadata19)
				} else {
					r.InputGrafana.InputGrafanaGrafana1.Metadata[metadataCount19].Name = metadata19.Name
					r.InputGrafana.InputGrafanaGrafana1.Metadata[metadataCount19].Value = metadata19.Value
				}
			}
			r.InputGrafana.InputGrafanaGrafana1.Pipeline = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Pipeline)
			r.InputGrafana.InputGrafanaGrafana1.Port = types.Float64Value(resp.InputGrafana.InputGrafanaGrafana1.Port)
			if resp.InputGrafana.InputGrafanaGrafana1.Pq == nil {
				r.InputGrafana.InputGrafanaGrafana1.Pq = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana1.Pq = &tfTypes.InputGrafanaPq1{}
				r.InputGrafana.InputGrafanaGrafana1.Pq.CommitFrequency = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.Pq.CommitFrequency)
				if resp.InputGrafana.InputGrafanaGrafana1.Pq.Compress != nil {
					r.InputGrafana.InputGrafanaGrafana1.Pq.Compress = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana1.Pq.Compress))
				} else {
					r.InputGrafana.InputGrafanaGrafana1.Pq.Compress = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana1.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.Pq.MaxBufferSize)
				r.InputGrafana.InputGrafanaGrafana1.Pq.MaxFileSize = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Pq.MaxFileSize)
				r.InputGrafana.InputGrafanaGrafana1.Pq.MaxSize = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Pq.MaxSize)
				if resp.InputGrafana.InputGrafanaGrafana1.Pq.Mode != nil {
					r.InputGrafana.InputGrafanaGrafana1.Pq.Mode = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana1.Pq.Mode))
				} else {
					r.InputGrafana.InputGrafanaGrafana1.Pq.Mode = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana1.Pq.Path = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.Pq.Path)
			}
			r.InputGrafana.InputGrafanaGrafana1.PqEnabled = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PqEnabled)
			r.InputGrafana.InputGrafanaGrafana1.PrometheusAPI = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAPI)
			if resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth == nil {
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth = &tfTypes.InputGrafanaPrometheusAuth1{}
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.AuthHeaderExpr = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.AuthHeaderExpr)
				if resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.AuthType != nil {
					r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.AuthType = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.AuthType))
				} else {
					r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.AuthType = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.CredentialsSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.CredentialsSecret)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.LoginURL = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.LoginURL)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders = []tfTypes.PrometheusAuthOauthHeader1{}
				if len(r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders) > len(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders) {
					r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders = r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders[:len(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders)]
				}
				for oauthHeadersCount1, oauthHeadersItem1 := range resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders {
					var oauthHeaders1 tfTypes.PrometheusAuthOauthHeader1
					oauthHeaders1.Name = types.StringValue(oauthHeadersItem1.Name)
					oauthHeaders1.Value = types.StringValue(oauthHeadersItem1.Value)
					if oauthHeadersCount1+1 > len(r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders) {
						r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders = append(r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders, oauthHeaders1)
					} else {
						r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders[oauthHeadersCount1].Name = oauthHeaders1.Name
						r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthHeaders[oauthHeadersCount1].Value = oauthHeaders1.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams = []tfTypes.PrometheusAuthOauthParam1{}
				if len(r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams) > len(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams) {
					r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams = r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams[:len(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams)]
				}
				for oauthParamsCount1, oauthParamsItem1 := range resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams {
					var oauthParams1 tfTypes.PrometheusAuthOauthParam1
					oauthParams1.Name = types.StringValue(oauthParamsItem1.Name)
					oauthParams1.Value = types.StringValue(oauthParamsItem1.Value)
					if oauthParamsCount1+1 > len(r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams) {
						r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams = append(r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams, oauthParams1)
					} else {
						r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams[oauthParamsCount1].Name = oauthParams1.Name
						r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.OauthParams[oauthParamsCount1].Value = oauthParams1.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Password = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Password)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Secret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Secret)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.SecretParamName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.SecretParamName)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.TextSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.TextSecret)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Token = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Token)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.TokenAttributeName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.TokenAttributeName)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.TokenTimeoutSecs = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.TokenTimeoutSecs)
				r.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Username = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.PrometheusAuth.Username)
			}
			r.InputGrafana.InputGrafanaGrafana1.RequestTimeout = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.RequestTimeout)
			r.InputGrafana.InputGrafanaGrafana1.SendToRoutes = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.SendToRoutes)
			r.InputGrafana.InputGrafanaGrafana1.SocketTimeout = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana1.SocketTimeout)
			r.InputGrafana.InputGrafanaGrafana1.Streamtags = make([]types.String, 0, len(resp.InputGrafana.InputGrafanaGrafana1.Streamtags))
			for _, v := range resp.InputGrafana.InputGrafanaGrafana1.Streamtags {
				r.InputGrafana.InputGrafanaGrafana1.Streamtags = append(r.InputGrafana.InputGrafanaGrafana1.Streamtags, types.StringValue(v))
			}
			if resp.InputGrafana.InputGrafanaGrafana1.TLS == nil {
				r.InputGrafana.InputGrafanaGrafana1.TLS = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana1.TLS = &tfTypes.InputGrafanaTLSSettingsServerSide1{}
				r.InputGrafana.InputGrafanaGrafana1.TLS.CaPath = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.TLS.CaPath)
				r.InputGrafana.InputGrafanaGrafana1.TLS.CertificateName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.TLS.CertificateName)
				r.InputGrafana.InputGrafanaGrafana1.TLS.CertPath = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.TLS.CertPath)
				if resp.InputGrafana.InputGrafanaGrafana1.TLS.CommonNameRegex == nil {
					r.InputGrafana.InputGrafanaGrafana1.TLS.CommonNameRegex = types.StringNull()
				} else {
					commonNameRegexResult7, _ := json.Marshal(resp.InputGrafana.InputGrafanaGrafana1.TLS.CommonNameRegex)
					r.InputGrafana.InputGrafanaGrafana1.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult7))
				}
				r.InputGrafana.InputGrafanaGrafana1.TLS.Disabled = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.TLS.Disabled)
				if resp.InputGrafana.InputGrafanaGrafana1.TLS.MaxVersion != nil {
					r.InputGrafana.InputGrafanaGrafana1.TLS.MaxVersion = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana1.TLS.MaxVersion))
				} else {
					r.InputGrafana.InputGrafanaGrafana1.TLS.MaxVersion = types.StringNull()
				}
				if resp.InputGrafana.InputGrafanaGrafana1.TLS.MinVersion != nil {
					r.InputGrafana.InputGrafanaGrafana1.TLS.MinVersion = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana1.TLS.MinVersion))
				} else {
					r.InputGrafana.InputGrafanaGrafana1.TLS.MinVersion = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana1.TLS.Passphrase = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.TLS.Passphrase)
				r.InputGrafana.InputGrafanaGrafana1.TLS.PrivKeyPath = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana1.TLS.PrivKeyPath)
				if resp.InputGrafana.InputGrafanaGrafana1.TLS.RejectUnauthorized == nil {
					r.InputGrafana.InputGrafanaGrafana1.TLS.RejectUnauthorized = types.StringNull()
				} else {
					rejectUnauthorizedResult7, _ := json.Marshal(resp.InputGrafana.InputGrafanaGrafana1.TLS.RejectUnauthorized)
					r.InputGrafana.InputGrafanaGrafana1.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult7))
				}
				r.InputGrafana.InputGrafanaGrafana1.TLS.RequestCert = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana1.TLS.RequestCert)
			}
			if resp.InputGrafana.InputGrafanaGrafana1.Type != nil {
				r.InputGrafana.InputGrafanaGrafana1.Type = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana1.Type))
			} else {
				r.InputGrafana.InputGrafanaGrafana1.Type = types.StringNull()
			}
		}
		if resp.InputGrafana.InputGrafanaGrafana2 != nil {
			r.InputGrafana.InputGrafanaGrafana2 = &tfTypes.InputGrafanaGrafana2{}
			r.InputGrafana.InputGrafanaGrafana2.ActivityLogSampleRate = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.ActivityLogSampleRate)
			r.InputGrafana.InputGrafanaGrafana2.CaptureHeaders = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.CaptureHeaders)
			r.InputGrafana.InputGrafanaGrafana2.Connections = []tfTypes.InputGrafanaConnection2{}
			if len(r.InputGrafana.InputGrafanaGrafana2.Connections) > len(resp.InputGrafana.InputGrafanaGrafana2.Connections) {
				r.InputGrafana.InputGrafanaGrafana2.Connections = r.InputGrafana.InputGrafanaGrafana2.Connections[:len(resp.InputGrafana.InputGrafanaGrafana2.Connections)]
			}
			for connectionsCount20, connectionsItem20 := range resp.InputGrafana.InputGrafanaGrafana2.Connections {
				var connections20 tfTypes.InputGrafanaConnection2
				connections20.Output = types.StringValue(connectionsItem20.Output)
				connections20.Pipeline = types.StringPointerValue(connectionsItem20.Pipeline)
				if connectionsCount20+1 > len(r.InputGrafana.InputGrafanaGrafana2.Connections) {
					r.InputGrafana.InputGrafanaGrafana2.Connections = append(r.InputGrafana.InputGrafanaGrafana2.Connections, connections20)
				} else {
					r.InputGrafana.InputGrafanaGrafana2.Connections[connectionsCount20].Output = connections20.Output
					r.InputGrafana.InputGrafanaGrafana2.Connections[connectionsCount20].Pipeline = connections20.Pipeline
				}
			}
			r.InputGrafana.InputGrafanaGrafana2.Description = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Description)
			r.InputGrafana.InputGrafanaGrafana2.Disabled = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Disabled)
			r.InputGrafana.InputGrafanaGrafana2.EnableHealthCheck = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.EnableHealthCheck)
			r.InputGrafana.InputGrafanaGrafana2.EnableProxyHeader = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.EnableProxyHeader)
			r.InputGrafana.InputGrafanaGrafana2.Environment = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Environment)
			r.InputGrafana.InputGrafanaGrafana2.Host = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Host)
			r.InputGrafana.InputGrafanaGrafana2.ID = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.ID)
			r.InputGrafana.InputGrafanaGrafana2.IPAllowlistRegex = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.IPAllowlistRegex)
			r.InputGrafana.InputGrafanaGrafana2.IPDenylistRegex = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.IPDenylistRegex)
			r.InputGrafana.InputGrafanaGrafana2.KeepAliveTimeout = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.KeepAliveTimeout)
			r.InputGrafana.InputGrafanaGrafana2.LokiAPI = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAPI)
			if resp.InputGrafana.InputGrafanaGrafana2.LokiAuth == nil {
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth = &tfTypes.InputGrafanaLokiAuth2{}
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.AuthHeaderExpr = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.AuthHeaderExpr)
				if resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.AuthType != nil {
					r.InputGrafana.InputGrafanaGrafana2.LokiAuth.AuthType = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.AuthType))
				} else {
					r.InputGrafana.InputGrafanaGrafana2.LokiAuth.AuthType = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.CredentialsSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.CredentialsSecret)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.LoginURL = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.LoginURL)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders = []tfTypes.LokiAuthOauthHeader2{}
				if len(r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders) > len(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders) {
					r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders = r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders[:len(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders)]
				}
				for oauthHeadersCount2, oauthHeadersItem2 := range resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders {
					var oauthHeaders2 tfTypes.LokiAuthOauthHeader2
					oauthHeaders2.Name = types.StringValue(oauthHeadersItem2.Name)
					oauthHeaders2.Value = types.StringValue(oauthHeadersItem2.Value)
					if oauthHeadersCount2+1 > len(r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders) {
						r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders = append(r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders, oauthHeaders2)
					} else {
						r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders[oauthHeadersCount2].Name = oauthHeaders2.Name
						r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthHeaders[oauthHeadersCount2].Value = oauthHeaders2.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams = []tfTypes.LokiAuthOauthParam2{}
				if len(r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams) > len(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams) {
					r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams = r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams[:len(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams)]
				}
				for oauthParamsCount2, oauthParamsItem2 := range resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams {
					var oauthParams2 tfTypes.LokiAuthOauthParam2
					oauthParams2.Name = types.StringValue(oauthParamsItem2.Name)
					oauthParams2.Value = types.StringValue(oauthParamsItem2.Value)
					if oauthParamsCount2+1 > len(r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams) {
						r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams = append(r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams, oauthParams2)
					} else {
						r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams[oauthParamsCount2].Name = oauthParams2.Name
						r.InputGrafana.InputGrafanaGrafana2.LokiAuth.OauthParams[oauthParamsCount2].Value = oauthParams2.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.Password = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.Password)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.Secret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.Secret)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.SecretParamName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.SecretParamName)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.TextSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.TextSecret)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.Token = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.Token)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.TokenAttributeName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.TokenAttributeName)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.TokenTimeoutSecs = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.TokenTimeoutSecs)
				r.InputGrafana.InputGrafanaGrafana2.LokiAuth.Username = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.LokiAuth.Username)
			}
			r.InputGrafana.InputGrafanaGrafana2.MaxActiveReq = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.MaxActiveReq)
			r.InputGrafana.InputGrafanaGrafana2.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.MaxRequestsPerSocket)
			r.InputGrafana.InputGrafanaGrafana2.Metadata = []tfTypes.InputGrafanaMetadatum2{}
			if len(r.InputGrafana.InputGrafanaGrafana2.Metadata) > len(resp.InputGrafana.InputGrafanaGrafana2.Metadata) {
				r.InputGrafana.InputGrafanaGrafana2.Metadata = r.InputGrafana.InputGrafanaGrafana2.Metadata[:len(resp.InputGrafana.InputGrafanaGrafana2.Metadata)]
			}
			for metadataCount20, metadataItem20 := range resp.InputGrafana.InputGrafanaGrafana2.Metadata {
				var metadata20 tfTypes.InputGrafanaMetadatum2
				metadata20.Name = types.StringValue(metadataItem20.Name)
				metadata20.Value = types.StringValue(metadataItem20.Value)
				if metadataCount20+1 > len(r.InputGrafana.InputGrafanaGrafana2.Metadata) {
					r.InputGrafana.InputGrafanaGrafana2.Metadata = append(r.InputGrafana.InputGrafanaGrafana2.Metadata, metadata20)
				} else {
					r.InputGrafana.InputGrafanaGrafana2.Metadata[metadataCount20].Name = metadata20.Name
					r.InputGrafana.InputGrafanaGrafana2.Metadata[metadataCount20].Value = metadata20.Value
				}
			}
			r.InputGrafana.InputGrafanaGrafana2.Pipeline = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Pipeline)
			r.InputGrafana.InputGrafanaGrafana2.Port = types.Float64Value(resp.InputGrafana.InputGrafanaGrafana2.Port)
			if resp.InputGrafana.InputGrafanaGrafana2.Pq == nil {
				r.InputGrafana.InputGrafanaGrafana2.Pq = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana2.Pq = &tfTypes.InputGrafanaPq2{}
				r.InputGrafana.InputGrafanaGrafana2.Pq.CommitFrequency = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.Pq.CommitFrequency)
				if resp.InputGrafana.InputGrafanaGrafana2.Pq.Compress != nil {
					r.InputGrafana.InputGrafanaGrafana2.Pq.Compress = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana2.Pq.Compress))
				} else {
					r.InputGrafana.InputGrafanaGrafana2.Pq.Compress = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana2.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.Pq.MaxBufferSize)
				r.InputGrafana.InputGrafanaGrafana2.Pq.MaxFileSize = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Pq.MaxFileSize)
				r.InputGrafana.InputGrafanaGrafana2.Pq.MaxSize = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Pq.MaxSize)
				if resp.InputGrafana.InputGrafanaGrafana2.Pq.Mode != nil {
					r.InputGrafana.InputGrafanaGrafana2.Pq.Mode = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana2.Pq.Mode))
				} else {
					r.InputGrafana.InputGrafanaGrafana2.Pq.Mode = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana2.Pq.Path = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.Pq.Path)
			}
			r.InputGrafana.InputGrafanaGrafana2.PqEnabled = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PqEnabled)
			r.InputGrafana.InputGrafanaGrafana2.PrometheusAPI = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAPI)
			if resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth == nil {
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth = &tfTypes.InputGrafanaPrometheusAuth2{}
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.AuthHeaderExpr = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.AuthHeaderExpr)
				if resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.AuthType != nil {
					r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.AuthType = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.AuthType))
				} else {
					r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.AuthType = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.CredentialsSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.CredentialsSecret)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.LoginURL = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.LoginURL)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders = []tfTypes.PrometheusAuthOauthHeader2{}
				if len(r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders) > len(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders) {
					r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders = r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders[:len(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders)]
				}
				for oauthHeadersCount3, oauthHeadersItem3 := range resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders {
					var oauthHeaders3 tfTypes.PrometheusAuthOauthHeader2
					oauthHeaders3.Name = types.StringValue(oauthHeadersItem3.Name)
					oauthHeaders3.Value = types.StringValue(oauthHeadersItem3.Value)
					if oauthHeadersCount3+1 > len(r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders) {
						r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders = append(r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders, oauthHeaders3)
					} else {
						r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders[oauthHeadersCount3].Name = oauthHeaders3.Name
						r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthHeaders[oauthHeadersCount3].Value = oauthHeaders3.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams = []tfTypes.PrometheusAuthOauthParam2{}
				if len(r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams) > len(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams) {
					r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams = r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams[:len(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams)]
				}
				for oauthParamsCount3, oauthParamsItem3 := range resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams {
					var oauthParams3 tfTypes.PrometheusAuthOauthParam2
					oauthParams3.Name = types.StringValue(oauthParamsItem3.Name)
					oauthParams3.Value = types.StringValue(oauthParamsItem3.Value)
					if oauthParamsCount3+1 > len(r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams) {
						r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams = append(r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams, oauthParams3)
					} else {
						r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams[oauthParamsCount3].Name = oauthParams3.Name
						r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.OauthParams[oauthParamsCount3].Value = oauthParams3.Value
					}
				}
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Password = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Password)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Secret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Secret)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.SecretParamName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.SecretParamName)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.TextSecret = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.TextSecret)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Token = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Token)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.TokenAttributeName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.TokenAttributeName)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.TokenTimeoutSecs = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.TokenTimeoutSecs)
				r.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Username = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.PrometheusAuth.Username)
			}
			r.InputGrafana.InputGrafanaGrafana2.RequestTimeout = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.RequestTimeout)
			r.InputGrafana.InputGrafanaGrafana2.SendToRoutes = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.SendToRoutes)
			r.InputGrafana.InputGrafanaGrafana2.SocketTimeout = types.Float64PointerValue(resp.InputGrafana.InputGrafanaGrafana2.SocketTimeout)
			r.InputGrafana.InputGrafanaGrafana2.Streamtags = make([]types.String, 0, len(resp.InputGrafana.InputGrafanaGrafana2.Streamtags))
			for _, v := range resp.InputGrafana.InputGrafanaGrafana2.Streamtags {
				r.InputGrafana.InputGrafanaGrafana2.Streamtags = append(r.InputGrafana.InputGrafanaGrafana2.Streamtags, types.StringValue(v))
			}
			if resp.InputGrafana.InputGrafanaGrafana2.TLS == nil {
				r.InputGrafana.InputGrafanaGrafana2.TLS = nil
			} else {
				r.InputGrafana.InputGrafanaGrafana2.TLS = &tfTypes.InputGrafanaTLSSettingsServerSide2{}
				r.InputGrafana.InputGrafanaGrafana2.TLS.CaPath = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.TLS.CaPath)
				r.InputGrafana.InputGrafanaGrafana2.TLS.CertificateName = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.TLS.CertificateName)
				r.InputGrafana.InputGrafanaGrafana2.TLS.CertPath = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.TLS.CertPath)
				if resp.InputGrafana.InputGrafanaGrafana2.TLS.CommonNameRegex == nil {
					r.InputGrafana.InputGrafanaGrafana2.TLS.CommonNameRegex = types.StringNull()
				} else {
					commonNameRegexResult8, _ := json.Marshal(resp.InputGrafana.InputGrafanaGrafana2.TLS.CommonNameRegex)
					r.InputGrafana.InputGrafanaGrafana2.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult8))
				}
				r.InputGrafana.InputGrafanaGrafana2.TLS.Disabled = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.TLS.Disabled)
				if resp.InputGrafana.InputGrafanaGrafana2.TLS.MaxVersion != nil {
					r.InputGrafana.InputGrafanaGrafana2.TLS.MaxVersion = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana2.TLS.MaxVersion))
				} else {
					r.InputGrafana.InputGrafanaGrafana2.TLS.MaxVersion = types.StringNull()
				}
				if resp.InputGrafana.InputGrafanaGrafana2.TLS.MinVersion != nil {
					r.InputGrafana.InputGrafanaGrafana2.TLS.MinVersion = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana2.TLS.MinVersion))
				} else {
					r.InputGrafana.InputGrafanaGrafana2.TLS.MinVersion = types.StringNull()
				}
				r.InputGrafana.InputGrafanaGrafana2.TLS.Passphrase = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.TLS.Passphrase)
				r.InputGrafana.InputGrafanaGrafana2.TLS.PrivKeyPath = types.StringPointerValue(resp.InputGrafana.InputGrafanaGrafana2.TLS.PrivKeyPath)
				if resp.InputGrafana.InputGrafanaGrafana2.TLS.RejectUnauthorized == nil {
					r.InputGrafana.InputGrafanaGrafana2.TLS.RejectUnauthorized = types.StringNull()
				} else {
					rejectUnauthorizedResult8, _ := json.Marshal(resp.InputGrafana.InputGrafanaGrafana2.TLS.RejectUnauthorized)
					r.InputGrafana.InputGrafanaGrafana2.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult8))
				}
				r.InputGrafana.InputGrafanaGrafana2.TLS.RequestCert = types.BoolPointerValue(resp.InputGrafana.InputGrafanaGrafana2.TLS.RequestCert)
			}
			if resp.InputGrafana.InputGrafanaGrafana2.Type != nil {
				r.InputGrafana.InputGrafanaGrafana2.Type = types.StringValue(string(*resp.InputGrafana.InputGrafanaGrafana2.Type))
			} else {
				r.InputGrafana.InputGrafanaGrafana2.Type = types.StringNull()
			}
		}
	}
	if resp.InputHTTP != nil {
		r.InputHTTP = &tfTypes.InputHTTP{}
		r.InputHTTP.ActivityLogSampleRate = types.Float64PointerValue(resp.InputHTTP.ActivityLogSampleRate)
		r.InputHTTP.AuthTokens = make([]types.String, 0, len(resp.InputHTTP.AuthTokens))
		for _, v := range resp.InputHTTP.AuthTokens {
			r.InputHTTP.AuthTokens = append(r.InputHTTP.AuthTokens, types.StringValue(v))
		}
		r.InputHTTP.AuthTokensExt = []tfTypes.InputHTTPAuthTokensExt{}
		if len(r.InputHTTP.AuthTokensExt) > len(resp.InputHTTP.AuthTokensExt) {
			r.InputHTTP.AuthTokensExt = r.InputHTTP.AuthTokensExt[:len(resp.InputHTTP.AuthTokensExt)]
		}
		for authTokensExtCount, authTokensExtItem := range resp.InputHTTP.AuthTokensExt {
			var authTokensExt tfTypes.InputHTTPAuthTokensExt
			authTokensExt.Description = types.StringPointerValue(authTokensExtItem.Description)
			authTokensExt.Metadata = []tfTypes.InputHTTPAuthTokensExtMetadatum{}
			for metadataCount21, metadataItem21 := range authTokensExtItem.Metadata {
				var metadata21 tfTypes.InputHTTPAuthTokensExtMetadatum
				metadata21.Name = types.StringValue(metadataItem21.Name)
				metadata21.Value = types.StringValue(metadataItem21.Value)
				if metadataCount21+1 > len(authTokensExt.Metadata) {
					authTokensExt.Metadata = append(authTokensExt.Metadata, metadata21)
				} else {
					authTokensExt.Metadata[metadataCount21].Name = metadata21.Name
					authTokensExt.Metadata[metadataCount21].Value = metadata21.Value
				}
			}
			authTokensExt.Token = types.StringValue(authTokensExtItem.Token)
			if authTokensExtCount+1 > len(r.InputHTTP.AuthTokensExt) {
				r.InputHTTP.AuthTokensExt = append(r.InputHTTP.AuthTokensExt, authTokensExt)
			} else {
				r.InputHTTP.AuthTokensExt[authTokensExtCount].Description = authTokensExt.Description
				r.InputHTTP.AuthTokensExt[authTokensExtCount].Metadata = authTokensExt.Metadata
				r.InputHTTP.AuthTokensExt[authTokensExtCount].Token = authTokensExt.Token
			}
		}
		r.InputHTTP.CaptureHeaders = types.BoolPointerValue(resp.InputHTTP.CaptureHeaders)
		r.InputHTTP.Connections = []tfTypes.InputHTTPConnection{}
		if len(r.InputHTTP.Connections) > len(resp.InputHTTP.Connections) {
			r.InputHTTP.Connections = r.InputHTTP.Connections[:len(resp.InputHTTP.Connections)]
		}
		for connectionsCount21, connectionsItem21 := range resp.InputHTTP.Connections {
			var connections21 tfTypes.InputHTTPConnection
			connections21.Output = types.StringValue(connectionsItem21.Output)
			connections21.Pipeline = types.StringPointerValue(connectionsItem21.Pipeline)
			if connectionsCount21+1 > len(r.InputHTTP.Connections) {
				r.InputHTTP.Connections = append(r.InputHTTP.Connections, connections21)
			} else {
				r.InputHTTP.Connections[connectionsCount21].Output = connections21.Output
				r.InputHTTP.Connections[connectionsCount21].Pipeline = connections21.Pipeline
			}
		}
		r.InputHTTP.CriblAPI = types.StringPointerValue(resp.InputHTTP.CriblAPI)
		r.InputHTTP.Description = types.StringPointerValue(resp.InputHTTP.Description)
		r.InputHTTP.Disabled = types.BoolPointerValue(resp.InputHTTP.Disabled)
		r.InputHTTP.ElasticAPI = types.StringPointerValue(resp.InputHTTP.ElasticAPI)
		r.InputHTTP.EnableHealthCheck = types.BoolPointerValue(resp.InputHTTP.EnableHealthCheck)
		r.InputHTTP.EnableProxyHeader = types.BoolPointerValue(resp.InputHTTP.EnableProxyHeader)
		r.InputHTTP.Environment = types.StringPointerValue(resp.InputHTTP.Environment)
		r.InputHTTP.Host = types.StringPointerValue(resp.InputHTTP.Host)
		r.InputHTTP.ID = types.StringPointerValue(resp.InputHTTP.ID)
		r.InputHTTP.IPAllowlistRegex = types.StringPointerValue(resp.InputHTTP.IPAllowlistRegex)
		r.InputHTTP.IPDenylistRegex = types.StringPointerValue(resp.InputHTTP.IPDenylistRegex)
		r.InputHTTP.KeepAliveTimeout = types.Float64PointerValue(resp.InputHTTP.KeepAliveTimeout)
		r.InputHTTP.MaxActiveReq = types.Float64PointerValue(resp.InputHTTP.MaxActiveReq)
		r.InputHTTP.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputHTTP.MaxRequestsPerSocket)
		r.InputHTTP.Metadata = []tfTypes.InputHTTPMetadatum{}
		if len(r.InputHTTP.Metadata) > len(resp.InputHTTP.Metadata) {
			r.InputHTTP.Metadata = r.InputHTTP.Metadata[:len(resp.InputHTTP.Metadata)]
		}
		for metadataCount22, metadataItem22 := range resp.InputHTTP.Metadata {
			var metadata22 tfTypes.InputHTTPMetadatum
			metadata22.Name = types.StringValue(metadataItem22.Name)
			metadata22.Value = types.StringValue(metadataItem22.Value)
			if metadataCount22+1 > len(r.InputHTTP.Metadata) {
				r.InputHTTP.Metadata = append(r.InputHTTP.Metadata, metadata22)
			} else {
				r.InputHTTP.Metadata[metadataCount22].Name = metadata22.Name
				r.InputHTTP.Metadata[metadataCount22].Value = metadata22.Value
			}
		}
		r.InputHTTP.Pipeline = types.StringPointerValue(resp.InputHTTP.Pipeline)
		r.InputHTTP.Port = types.Float64Value(resp.InputHTTP.Port)
		if resp.InputHTTP.Pq == nil {
			r.InputHTTP.Pq = nil
		} else {
			r.InputHTTP.Pq = &tfTypes.InputHTTPPq{}
			r.InputHTTP.Pq.CommitFrequency = types.Float64PointerValue(resp.InputHTTP.Pq.CommitFrequency)
			if resp.InputHTTP.Pq.Compress != nil {
				r.InputHTTP.Pq.Compress = types.StringValue(string(*resp.InputHTTP.Pq.Compress))
			} else {
				r.InputHTTP.Pq.Compress = types.StringNull()
			}
			r.InputHTTP.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputHTTP.Pq.MaxBufferSize)
			r.InputHTTP.Pq.MaxFileSize = types.StringPointerValue(resp.InputHTTP.Pq.MaxFileSize)
			r.InputHTTP.Pq.MaxSize = types.StringPointerValue(resp.InputHTTP.Pq.MaxSize)
			if resp.InputHTTP.Pq.Mode != nil {
				r.InputHTTP.Pq.Mode = types.StringValue(string(*resp.InputHTTP.Pq.Mode))
			} else {
				r.InputHTTP.Pq.Mode = types.StringNull()
			}
			r.InputHTTP.Pq.Path = types.StringPointerValue(resp.InputHTTP.Pq.Path)
		}
		r.InputHTTP.PqEnabled = types.BoolPointerValue(resp.InputHTTP.PqEnabled)
		r.InputHTTP.RequestTimeout = types.Float64PointerValue(resp.InputHTTP.RequestTimeout)
		r.InputHTTP.SendToRoutes = types.BoolPointerValue(resp.InputHTTP.SendToRoutes)
		r.InputHTTP.SocketTimeout = types.Float64PointerValue(resp.InputHTTP.SocketTimeout)
		r.InputHTTP.SplunkHecAcks = types.BoolPointerValue(resp.InputHTTP.SplunkHecAcks)
		r.InputHTTP.SplunkHecAPI = types.StringPointerValue(resp.InputHTTP.SplunkHecAPI)
		r.InputHTTP.Streamtags = make([]types.String, 0, len(resp.InputHTTP.Streamtags))
		for _, v := range resp.InputHTTP.Streamtags {
			r.InputHTTP.Streamtags = append(r.InputHTTP.Streamtags, types.StringValue(v))
		}
		if resp.InputHTTP.TLS == nil {
			r.InputHTTP.TLS = nil
		} else {
			r.InputHTTP.TLS = &tfTypes.InputHTTPTLSSettingsServerSide{}
			r.InputHTTP.TLS.CaPath = types.StringPointerValue(resp.InputHTTP.TLS.CaPath)
			r.InputHTTP.TLS.CertificateName = types.StringPointerValue(resp.InputHTTP.TLS.CertificateName)
			r.InputHTTP.TLS.CertPath = types.StringPointerValue(resp.InputHTTP.TLS.CertPath)
			if resp.InputHTTP.TLS.CommonNameRegex == nil {
				r.InputHTTP.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult9, _ := json.Marshal(resp.InputHTTP.TLS.CommonNameRegex)
				r.InputHTTP.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult9))
			}
			r.InputHTTP.TLS.Disabled = types.BoolPointerValue(resp.InputHTTP.TLS.Disabled)
			if resp.InputHTTP.TLS.MaxVersion != nil {
				r.InputHTTP.TLS.MaxVersion = types.StringValue(string(*resp.InputHTTP.TLS.MaxVersion))
			} else {
				r.InputHTTP.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputHTTP.TLS.MinVersion != nil {
				r.InputHTTP.TLS.MinVersion = types.StringValue(string(*resp.InputHTTP.TLS.MinVersion))
			} else {
				r.InputHTTP.TLS.MinVersion = types.StringNull()
			}
			r.InputHTTP.TLS.Passphrase = types.StringPointerValue(resp.InputHTTP.TLS.Passphrase)
			r.InputHTTP.TLS.PrivKeyPath = types.StringPointerValue(resp.InputHTTP.TLS.PrivKeyPath)
			if resp.InputHTTP.TLS.RejectUnauthorized == nil {
				r.InputHTTP.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult9, _ := json.Marshal(resp.InputHTTP.TLS.RejectUnauthorized)
				r.InputHTTP.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult9))
			}
			r.InputHTTP.TLS.RequestCert = types.BoolPointerValue(resp.InputHTTP.TLS.RequestCert)
		}
		if resp.InputHTTP.Type != nil {
			r.InputHTTP.Type = types.StringValue(string(*resp.InputHTTP.Type))
		} else {
			r.InputHTTP.Type = types.StringNull()
		}
	}
	if resp.InputHTTPRaw != nil {
		r.InputHTTPRaw = &tfTypes.InputHTTPRaw{}
		r.InputHTTPRaw.ActivityLogSampleRate = types.Float64PointerValue(resp.InputHTTPRaw.ActivityLogSampleRate)
		r.InputHTTPRaw.AllowedMethods = make([]types.String, 0, len(resp.InputHTTPRaw.AllowedMethods))
		for _, v := range resp.InputHTTPRaw.AllowedMethods {
			r.InputHTTPRaw.AllowedMethods = append(r.InputHTTPRaw.AllowedMethods, types.StringValue(v))
		}
		r.InputHTTPRaw.AllowedPaths = make([]types.String, 0, len(resp.InputHTTPRaw.AllowedPaths))
		for _, v := range resp.InputHTTPRaw.AllowedPaths {
			r.InputHTTPRaw.AllowedPaths = append(r.InputHTTPRaw.AllowedPaths, types.StringValue(v))
		}
		r.InputHTTPRaw.AuthTokens = make([]types.String, 0, len(resp.InputHTTPRaw.AuthTokens))
		for _, v := range resp.InputHTTPRaw.AuthTokens {
			r.InputHTTPRaw.AuthTokens = append(r.InputHTTPRaw.AuthTokens, types.StringValue(v))
		}
		r.InputHTTPRaw.AuthTokensExt = []tfTypes.InputHTTPRawAuthTokensExt{}
		if len(r.InputHTTPRaw.AuthTokensExt) > len(resp.InputHTTPRaw.AuthTokensExt) {
			r.InputHTTPRaw.AuthTokensExt = r.InputHTTPRaw.AuthTokensExt[:len(resp.InputHTTPRaw.AuthTokensExt)]
		}
		for authTokensExtCount1, authTokensExtItem1 := range resp.InputHTTPRaw.AuthTokensExt {
			var authTokensExt1 tfTypes.InputHTTPRawAuthTokensExt
			authTokensExt1.Description = types.StringPointerValue(authTokensExtItem1.Description)
			authTokensExt1.Metadata = []tfTypes.InputHTTPRawAuthTokensExtMetadatum{}
			for metadataCount23, metadataItem23 := range authTokensExtItem1.Metadata {
				var metadata23 tfTypes.InputHTTPRawAuthTokensExtMetadatum
				metadata23.Name = types.StringValue(metadataItem23.Name)
				metadata23.Value = types.StringValue(metadataItem23.Value)
				if metadataCount23+1 > len(authTokensExt1.Metadata) {
					authTokensExt1.Metadata = append(authTokensExt1.Metadata, metadata23)
				} else {
					authTokensExt1.Metadata[metadataCount23].Name = metadata23.Name
					authTokensExt1.Metadata[metadataCount23].Value = metadata23.Value
				}
			}
			authTokensExt1.Token = types.StringValue(authTokensExtItem1.Token)
			if authTokensExtCount1+1 > len(r.InputHTTPRaw.AuthTokensExt) {
				r.InputHTTPRaw.AuthTokensExt = append(r.InputHTTPRaw.AuthTokensExt, authTokensExt1)
			} else {
				r.InputHTTPRaw.AuthTokensExt[authTokensExtCount1].Description = authTokensExt1.Description
				r.InputHTTPRaw.AuthTokensExt[authTokensExtCount1].Metadata = authTokensExt1.Metadata
				r.InputHTTPRaw.AuthTokensExt[authTokensExtCount1].Token = authTokensExt1.Token
			}
		}
		r.InputHTTPRaw.BreakerRulesets = make([]types.String, 0, len(resp.InputHTTPRaw.BreakerRulesets))
		for _, v := range resp.InputHTTPRaw.BreakerRulesets {
			r.InputHTTPRaw.BreakerRulesets = append(r.InputHTTPRaw.BreakerRulesets, types.StringValue(v))
		}
		r.InputHTTPRaw.CaptureHeaders = types.BoolPointerValue(resp.InputHTTPRaw.CaptureHeaders)
		r.InputHTTPRaw.Connections = []tfTypes.InputHTTPRawConnection{}
		if len(r.InputHTTPRaw.Connections) > len(resp.InputHTTPRaw.Connections) {
			r.InputHTTPRaw.Connections = r.InputHTTPRaw.Connections[:len(resp.InputHTTPRaw.Connections)]
		}
		for connectionsCount22, connectionsItem22 := range resp.InputHTTPRaw.Connections {
			var connections22 tfTypes.InputHTTPRawConnection
			connections22.Output = types.StringValue(connectionsItem22.Output)
			connections22.Pipeline = types.StringPointerValue(connectionsItem22.Pipeline)
			if connectionsCount22+1 > len(r.InputHTTPRaw.Connections) {
				r.InputHTTPRaw.Connections = append(r.InputHTTPRaw.Connections, connections22)
			} else {
				r.InputHTTPRaw.Connections[connectionsCount22].Output = connections22.Output
				r.InputHTTPRaw.Connections[connectionsCount22].Pipeline = connections22.Pipeline
			}
		}
		r.InputHTTPRaw.Description = types.StringPointerValue(resp.InputHTTPRaw.Description)
		r.InputHTTPRaw.Disabled = types.BoolPointerValue(resp.InputHTTPRaw.Disabled)
		r.InputHTTPRaw.EnableHealthCheck = types.BoolPointerValue(resp.InputHTTPRaw.EnableHealthCheck)
		r.InputHTTPRaw.EnableProxyHeader = types.BoolPointerValue(resp.InputHTTPRaw.EnableProxyHeader)
		r.InputHTTPRaw.Environment = types.StringPointerValue(resp.InputHTTPRaw.Environment)
		r.InputHTTPRaw.Host = types.StringPointerValue(resp.InputHTTPRaw.Host)
		r.InputHTTPRaw.ID = types.StringPointerValue(resp.InputHTTPRaw.ID)
		r.InputHTTPRaw.IPAllowlistRegex = types.StringPointerValue(resp.InputHTTPRaw.IPAllowlistRegex)
		r.InputHTTPRaw.IPDenylistRegex = types.StringPointerValue(resp.InputHTTPRaw.IPDenylistRegex)
		r.InputHTTPRaw.KeepAliveTimeout = types.Float64PointerValue(resp.InputHTTPRaw.KeepAliveTimeout)
		r.InputHTTPRaw.MaxActiveReq = types.Float64PointerValue(resp.InputHTTPRaw.MaxActiveReq)
		r.InputHTTPRaw.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputHTTPRaw.MaxRequestsPerSocket)
		r.InputHTTPRaw.Metadata = []tfTypes.InputHTTPRawMetadatum{}
		if len(r.InputHTTPRaw.Metadata) > len(resp.InputHTTPRaw.Metadata) {
			r.InputHTTPRaw.Metadata = r.InputHTTPRaw.Metadata[:len(resp.InputHTTPRaw.Metadata)]
		}
		for metadataCount24, metadataItem24 := range resp.InputHTTPRaw.Metadata {
			var metadata24 tfTypes.InputHTTPRawMetadatum
			metadata24.Name = types.StringValue(metadataItem24.Name)
			metadata24.Value = types.StringValue(metadataItem24.Value)
			if metadataCount24+1 > len(r.InputHTTPRaw.Metadata) {
				r.InputHTTPRaw.Metadata = append(r.InputHTTPRaw.Metadata, metadata24)
			} else {
				r.InputHTTPRaw.Metadata[metadataCount24].Name = metadata24.Name
				r.InputHTTPRaw.Metadata[metadataCount24].Value = metadata24.Value
			}
		}
		r.InputHTTPRaw.Pipeline = types.StringPointerValue(resp.InputHTTPRaw.Pipeline)
		r.InputHTTPRaw.Port = types.Float64Value(resp.InputHTTPRaw.Port)
		if resp.InputHTTPRaw.Pq == nil {
			r.InputHTTPRaw.Pq = nil
		} else {
			r.InputHTTPRaw.Pq = &tfTypes.InputHTTPRawPq{}
			r.InputHTTPRaw.Pq.CommitFrequency = types.Float64PointerValue(resp.InputHTTPRaw.Pq.CommitFrequency)
			if resp.InputHTTPRaw.Pq.Compress != nil {
				r.InputHTTPRaw.Pq.Compress = types.StringValue(string(*resp.InputHTTPRaw.Pq.Compress))
			} else {
				r.InputHTTPRaw.Pq.Compress = types.StringNull()
			}
			r.InputHTTPRaw.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputHTTPRaw.Pq.MaxBufferSize)
			r.InputHTTPRaw.Pq.MaxFileSize = types.StringPointerValue(resp.InputHTTPRaw.Pq.MaxFileSize)
			r.InputHTTPRaw.Pq.MaxSize = types.StringPointerValue(resp.InputHTTPRaw.Pq.MaxSize)
			if resp.InputHTTPRaw.Pq.Mode != nil {
				r.InputHTTPRaw.Pq.Mode = types.StringValue(string(*resp.InputHTTPRaw.Pq.Mode))
			} else {
				r.InputHTTPRaw.Pq.Mode = types.StringNull()
			}
			r.InputHTTPRaw.Pq.Path = types.StringPointerValue(resp.InputHTTPRaw.Pq.Path)
		}
		r.InputHTTPRaw.PqEnabled = types.BoolPointerValue(resp.InputHTTPRaw.PqEnabled)
		r.InputHTTPRaw.RequestTimeout = types.Float64PointerValue(resp.InputHTTPRaw.RequestTimeout)
		r.InputHTTPRaw.SendToRoutes = types.BoolPointerValue(resp.InputHTTPRaw.SendToRoutes)
		r.InputHTTPRaw.SocketTimeout = types.Float64PointerValue(resp.InputHTTPRaw.SocketTimeout)
		r.InputHTTPRaw.StaleChannelFlushMs = types.Float64PointerValue(resp.InputHTTPRaw.StaleChannelFlushMs)
		r.InputHTTPRaw.Streamtags = make([]types.String, 0, len(resp.InputHTTPRaw.Streamtags))
		for _, v := range resp.InputHTTPRaw.Streamtags {
			r.InputHTTPRaw.Streamtags = append(r.InputHTTPRaw.Streamtags, types.StringValue(v))
		}
		if resp.InputHTTPRaw.TLS == nil {
			r.InputHTTPRaw.TLS = nil
		} else {
			r.InputHTTPRaw.TLS = &tfTypes.InputHTTPRawTLSSettingsServerSide{}
			r.InputHTTPRaw.TLS.CaPath = types.StringPointerValue(resp.InputHTTPRaw.TLS.CaPath)
			r.InputHTTPRaw.TLS.CertificateName = types.StringPointerValue(resp.InputHTTPRaw.TLS.CertificateName)
			r.InputHTTPRaw.TLS.CertPath = types.StringPointerValue(resp.InputHTTPRaw.TLS.CertPath)
			if resp.InputHTTPRaw.TLS.CommonNameRegex == nil {
				r.InputHTTPRaw.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult10, _ := json.Marshal(resp.InputHTTPRaw.TLS.CommonNameRegex)
				r.InputHTTPRaw.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult10))
			}
			r.InputHTTPRaw.TLS.Disabled = types.BoolPointerValue(resp.InputHTTPRaw.TLS.Disabled)
			if resp.InputHTTPRaw.TLS.MaxVersion != nil {
				r.InputHTTPRaw.TLS.MaxVersion = types.StringValue(string(*resp.InputHTTPRaw.TLS.MaxVersion))
			} else {
				r.InputHTTPRaw.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputHTTPRaw.TLS.MinVersion != nil {
				r.InputHTTPRaw.TLS.MinVersion = types.StringValue(string(*resp.InputHTTPRaw.TLS.MinVersion))
			} else {
				r.InputHTTPRaw.TLS.MinVersion = types.StringNull()
			}
			r.InputHTTPRaw.TLS.Passphrase = types.StringPointerValue(resp.InputHTTPRaw.TLS.Passphrase)
			r.InputHTTPRaw.TLS.PrivKeyPath = types.StringPointerValue(resp.InputHTTPRaw.TLS.PrivKeyPath)
			if resp.InputHTTPRaw.TLS.RejectUnauthorized == nil {
				r.InputHTTPRaw.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult10, _ := json.Marshal(resp.InputHTTPRaw.TLS.RejectUnauthorized)
				r.InputHTTPRaw.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult10))
			}
			r.InputHTTPRaw.TLS.RequestCert = types.BoolPointerValue(resp.InputHTTPRaw.TLS.RequestCert)
		}
		if resp.InputHTTPRaw.Type != nil {
			r.InputHTTPRaw.Type = types.StringValue(string(*resp.InputHTTPRaw.Type))
		} else {
			r.InputHTTPRaw.Type = types.StringNull()
		}
	}
	if resp.InputJournalFiles != nil {
		r.InputJournalFiles = &tfTypes.InputJournalFiles{}
		r.InputJournalFiles.Connections = []tfTypes.InputJournalFilesConnection{}
		if len(r.InputJournalFiles.Connections) > len(resp.InputJournalFiles.Connections) {
			r.InputJournalFiles.Connections = r.InputJournalFiles.Connections[:len(resp.InputJournalFiles.Connections)]
		}
		for connectionsCount23, connectionsItem23 := range resp.InputJournalFiles.Connections {
			var connections23 tfTypes.InputJournalFilesConnection
			connections23.Output = types.StringValue(connectionsItem23.Output)
			connections23.Pipeline = types.StringPointerValue(connectionsItem23.Pipeline)
			if connectionsCount23+1 > len(r.InputJournalFiles.Connections) {
				r.InputJournalFiles.Connections = append(r.InputJournalFiles.Connections, connections23)
			} else {
				r.InputJournalFiles.Connections[connectionsCount23].Output = connections23.Output
				r.InputJournalFiles.Connections[connectionsCount23].Pipeline = connections23.Pipeline
			}
		}
		r.InputJournalFiles.CurrentBoot = types.BoolPointerValue(resp.InputJournalFiles.CurrentBoot)
		r.InputJournalFiles.Description = types.StringPointerValue(resp.InputJournalFiles.Description)
		r.InputJournalFiles.Disabled = types.BoolPointerValue(resp.InputJournalFiles.Disabled)
		r.InputJournalFiles.Environment = types.StringPointerValue(resp.InputJournalFiles.Environment)
		r.InputJournalFiles.ID = types.StringPointerValue(resp.InputJournalFiles.ID)
		r.InputJournalFiles.Interval = types.Float64PointerValue(resp.InputJournalFiles.Interval)
		r.InputJournalFiles.Journals = make([]types.String, 0, len(resp.InputJournalFiles.Journals))
		for _, v := range resp.InputJournalFiles.Journals {
			r.InputJournalFiles.Journals = append(r.InputJournalFiles.Journals, types.StringValue(v))
		}
		r.InputJournalFiles.MaxAgeDur = types.StringPointerValue(resp.InputJournalFiles.MaxAgeDur)
		r.InputJournalFiles.Metadata = []tfTypes.InputJournalFilesMetadatum{}
		if len(r.InputJournalFiles.Metadata) > len(resp.InputJournalFiles.Metadata) {
			r.InputJournalFiles.Metadata = r.InputJournalFiles.Metadata[:len(resp.InputJournalFiles.Metadata)]
		}
		for metadataCount25, metadataItem25 := range resp.InputJournalFiles.Metadata {
			var metadata25 tfTypes.InputJournalFilesMetadatum
			metadata25.Name = types.StringValue(metadataItem25.Name)
			metadata25.Value = types.StringValue(metadataItem25.Value)
			if metadataCount25+1 > len(r.InputJournalFiles.Metadata) {
				r.InputJournalFiles.Metadata = append(r.InputJournalFiles.Metadata, metadata25)
			} else {
				r.InputJournalFiles.Metadata[metadataCount25].Name = metadata25.Name
				r.InputJournalFiles.Metadata[metadataCount25].Value = metadata25.Value
			}
		}
		r.InputJournalFiles.Path = types.StringValue(resp.InputJournalFiles.Path)
		r.InputJournalFiles.Pipeline = types.StringPointerValue(resp.InputJournalFiles.Pipeline)
		if resp.InputJournalFiles.Pq == nil {
			r.InputJournalFiles.Pq = nil
		} else {
			r.InputJournalFiles.Pq = &tfTypes.InputJournalFilesPq{}
			r.InputJournalFiles.Pq.CommitFrequency = types.Float64PointerValue(resp.InputJournalFiles.Pq.CommitFrequency)
			if resp.InputJournalFiles.Pq.Compress != nil {
				r.InputJournalFiles.Pq.Compress = types.StringValue(string(*resp.InputJournalFiles.Pq.Compress))
			} else {
				r.InputJournalFiles.Pq.Compress = types.StringNull()
			}
			r.InputJournalFiles.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputJournalFiles.Pq.MaxBufferSize)
			r.InputJournalFiles.Pq.MaxFileSize = types.StringPointerValue(resp.InputJournalFiles.Pq.MaxFileSize)
			r.InputJournalFiles.Pq.MaxSize = types.StringPointerValue(resp.InputJournalFiles.Pq.MaxSize)
			if resp.InputJournalFiles.Pq.Mode != nil {
				r.InputJournalFiles.Pq.Mode = types.StringValue(string(*resp.InputJournalFiles.Pq.Mode))
			} else {
				r.InputJournalFiles.Pq.Mode = types.StringNull()
			}
			r.InputJournalFiles.Pq.Path = types.StringPointerValue(resp.InputJournalFiles.Pq.Path)
		}
		r.InputJournalFiles.PqEnabled = types.BoolPointerValue(resp.InputJournalFiles.PqEnabled)
		r.InputJournalFiles.Rules = []tfTypes.InputJournalFilesRule{}
		if len(r.InputJournalFiles.Rules) > len(resp.InputJournalFiles.Rules) {
			r.InputJournalFiles.Rules = r.InputJournalFiles.Rules[:len(resp.InputJournalFiles.Rules)]
		}
		for rulesCount, rulesItem := range resp.InputJournalFiles.Rules {
			var rules tfTypes.InputJournalFilesRule
			rules.Description = types.StringPointerValue(rulesItem.Description)
			rules.Filter = types.StringValue(rulesItem.Filter)
			if rulesCount+1 > len(r.InputJournalFiles.Rules) {
				r.InputJournalFiles.Rules = append(r.InputJournalFiles.Rules, rules)
			} else {
				r.InputJournalFiles.Rules[rulesCount].Description = rules.Description
				r.InputJournalFiles.Rules[rulesCount].Filter = rules.Filter
			}
		}
		r.InputJournalFiles.SendToRoutes = types.BoolPointerValue(resp.InputJournalFiles.SendToRoutes)
		r.InputJournalFiles.Streamtags = make([]types.String, 0, len(resp.InputJournalFiles.Streamtags))
		for _, v := range resp.InputJournalFiles.Streamtags {
			r.InputJournalFiles.Streamtags = append(r.InputJournalFiles.Streamtags, types.StringValue(v))
		}
		if resp.InputJournalFiles.Type != nil {
			r.InputJournalFiles.Type = types.StringValue(string(*resp.InputJournalFiles.Type))
		} else {
			r.InputJournalFiles.Type = types.StringNull()
		}
	}
	if resp.InputKafka != nil {
		r.InputKafka = &tfTypes.InputKafka{}
		r.InputKafka.AuthenticationTimeout = types.Float64PointerValue(resp.InputKafka.AuthenticationTimeout)
		r.InputKafka.AutoCommitInterval = types.Float64PointerValue(resp.InputKafka.AutoCommitInterval)
		r.InputKafka.AutoCommitThreshold = types.Float64PointerValue(resp.InputKafka.AutoCommitThreshold)
		r.InputKafka.BackoffRate = types.Float64PointerValue(resp.InputKafka.BackoffRate)
		r.InputKafka.Brokers = make([]types.String, 0, len(resp.InputKafka.Brokers))
		for _, v := range resp.InputKafka.Brokers {
			r.InputKafka.Brokers = append(r.InputKafka.Brokers, types.StringValue(v))
		}
		r.InputKafka.Connections = []tfTypes.InputKafkaConnection{}
		if len(r.InputKafka.Connections) > len(resp.InputKafka.Connections) {
			r.InputKafka.Connections = r.InputKafka.Connections[:len(resp.InputKafka.Connections)]
		}
		for connectionsCount24, connectionsItem24 := range resp.InputKafka.Connections {
			var connections24 tfTypes.InputKafkaConnection
			connections24.Output = types.StringValue(connectionsItem24.Output)
			connections24.Pipeline = types.StringPointerValue(connectionsItem24.Pipeline)
			if connectionsCount24+1 > len(r.InputKafka.Connections) {
				r.InputKafka.Connections = append(r.InputKafka.Connections, connections24)
			} else {
				r.InputKafka.Connections[connectionsCount24].Output = connections24.Output
				r.InputKafka.Connections[connectionsCount24].Pipeline = connections24.Pipeline
			}
		}
		r.InputKafka.ConnectionTimeout = types.Float64PointerValue(resp.InputKafka.ConnectionTimeout)
		r.InputKafka.Description = types.StringPointerValue(resp.InputKafka.Description)
		r.InputKafka.Disabled = types.BoolPointerValue(resp.InputKafka.Disabled)
		r.InputKafka.Environment = types.StringPointerValue(resp.InputKafka.Environment)
		r.InputKafka.FromBeginning = types.BoolPointerValue(resp.InputKafka.FromBeginning)
		r.InputKafka.GroupID = types.StringPointerValue(resp.InputKafka.GroupID)
		r.InputKafka.HeartbeatInterval = types.Float64PointerValue(resp.InputKafka.HeartbeatInterval)
		r.InputKafka.ID = types.StringPointerValue(resp.InputKafka.ID)
		r.InputKafka.InitialBackoff = types.Float64PointerValue(resp.InputKafka.InitialBackoff)
		if resp.InputKafka.KafkaSchemaRegistry == nil {
			r.InputKafka.KafkaSchemaRegistry = nil
		} else {
			r.InputKafka.KafkaSchemaRegistry = &tfTypes.InputKafkaKafkaSchemaRegistryAuthentication{}
			if resp.InputKafka.KafkaSchemaRegistry.Auth == nil {
				r.InputKafka.KafkaSchemaRegistry.Auth = nil
			} else {
				r.InputKafka.KafkaSchemaRegistry.Auth = &tfTypes.InputKafkaAuth{}
				r.InputKafka.KafkaSchemaRegistry.Auth.CredentialsSecret = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.Auth.CredentialsSecret)
				r.InputKafka.KafkaSchemaRegistry.Auth.Disabled = types.BoolPointerValue(resp.InputKafka.KafkaSchemaRegistry.Auth.Disabled)
			}
			r.InputKafka.KafkaSchemaRegistry.ConnectionTimeout = types.Float64PointerValue(resp.InputKafka.KafkaSchemaRegistry.ConnectionTimeout)
			r.InputKafka.KafkaSchemaRegistry.Disabled = types.BoolPointerValue(resp.InputKafka.KafkaSchemaRegistry.Disabled)
			r.InputKafka.KafkaSchemaRegistry.MaxRetries = types.Float64PointerValue(resp.InputKafka.KafkaSchemaRegistry.MaxRetries)
			r.InputKafka.KafkaSchemaRegistry.RequestTimeout = types.Float64PointerValue(resp.InputKafka.KafkaSchemaRegistry.RequestTimeout)
			r.InputKafka.KafkaSchemaRegistry.SchemaRegistryURL = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.SchemaRegistryURL)
			if resp.InputKafka.KafkaSchemaRegistry.TLS == nil {
				r.InputKafka.KafkaSchemaRegistry.TLS = nil
			} else {
				r.InputKafka.KafkaSchemaRegistry.TLS = &tfTypes.InputKafkaKafkaSchemaRegistryTLSSettingsClientSide{}
				r.InputKafka.KafkaSchemaRegistry.TLS.CaPath = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.CaPath)
				r.InputKafka.KafkaSchemaRegistry.TLS.CertificateName = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.CertificateName)
				r.InputKafka.KafkaSchemaRegistry.TLS.CertPath = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.CertPath)
				r.InputKafka.KafkaSchemaRegistry.TLS.Disabled = types.BoolPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.Disabled)
				if resp.InputKafka.KafkaSchemaRegistry.TLS.MaxVersion != nil {
					r.InputKafka.KafkaSchemaRegistry.TLS.MaxVersion = types.StringValue(string(*resp.InputKafka.KafkaSchemaRegistry.TLS.MaxVersion))
				} else {
					r.InputKafka.KafkaSchemaRegistry.TLS.MaxVersion = types.StringNull()
				}
				if resp.InputKafka.KafkaSchemaRegistry.TLS.MinVersion != nil {
					r.InputKafka.KafkaSchemaRegistry.TLS.MinVersion = types.StringValue(string(*resp.InputKafka.KafkaSchemaRegistry.TLS.MinVersion))
				} else {
					r.InputKafka.KafkaSchemaRegistry.TLS.MinVersion = types.StringNull()
				}
				r.InputKafka.KafkaSchemaRegistry.TLS.Passphrase = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.Passphrase)
				r.InputKafka.KafkaSchemaRegistry.TLS.PrivKeyPath = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.PrivKeyPath)
				r.InputKafka.KafkaSchemaRegistry.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.RejectUnauthorized)
				r.InputKafka.KafkaSchemaRegistry.TLS.Servername = types.StringPointerValue(resp.InputKafka.KafkaSchemaRegistry.TLS.Servername)
			}
		}
		r.InputKafka.MaxBackOff = types.Float64PointerValue(resp.InputKafka.MaxBackOff)
		r.InputKafka.MaxBytes = types.Float64PointerValue(resp.InputKafka.MaxBytes)
		r.InputKafka.MaxBytesPerPartition = types.Float64PointerValue(resp.InputKafka.MaxBytesPerPartition)
		r.InputKafka.MaxRetries = types.Float64PointerValue(resp.InputKafka.MaxRetries)
		r.InputKafka.MaxSocketErrors = types.Float64PointerValue(resp.InputKafka.MaxSocketErrors)
		r.InputKafka.Metadata = []tfTypes.InputKafkaMetadatum{}
		if len(r.InputKafka.Metadata) > len(resp.InputKafka.Metadata) {
			r.InputKafka.Metadata = r.InputKafka.Metadata[:len(resp.InputKafka.Metadata)]
		}
		for metadataCount26, metadataItem26 := range resp.InputKafka.Metadata {
			var metadata26 tfTypes.InputKafkaMetadatum
			metadata26.Name = types.StringValue(metadataItem26.Name)
			metadata26.Value = types.StringValue(metadataItem26.Value)
			if metadataCount26+1 > len(r.InputKafka.Metadata) {
				r.InputKafka.Metadata = append(r.InputKafka.Metadata, metadata26)
			} else {
				r.InputKafka.Metadata[metadataCount26].Name = metadata26.Name
				r.InputKafka.Metadata[metadataCount26].Value = metadata26.Value
			}
		}
		r.InputKafka.Pipeline = types.StringPointerValue(resp.InputKafka.Pipeline)
		if resp.InputKafka.Pq == nil {
			r.InputKafka.Pq = nil
		} else {
			r.InputKafka.Pq = &tfTypes.InputKafkaPq{}
			r.InputKafka.Pq.CommitFrequency = types.Float64PointerValue(resp.InputKafka.Pq.CommitFrequency)
			if resp.InputKafka.Pq.Compress != nil {
				r.InputKafka.Pq.Compress = types.StringValue(string(*resp.InputKafka.Pq.Compress))
			} else {
				r.InputKafka.Pq.Compress = types.StringNull()
			}
			r.InputKafka.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputKafka.Pq.MaxBufferSize)
			r.InputKafka.Pq.MaxFileSize = types.StringPointerValue(resp.InputKafka.Pq.MaxFileSize)
			r.InputKafka.Pq.MaxSize = types.StringPointerValue(resp.InputKafka.Pq.MaxSize)
			if resp.InputKafka.Pq.Mode != nil {
				r.InputKafka.Pq.Mode = types.StringValue(string(*resp.InputKafka.Pq.Mode))
			} else {
				r.InputKafka.Pq.Mode = types.StringNull()
			}
			r.InputKafka.Pq.Path = types.StringPointerValue(resp.InputKafka.Pq.Path)
		}
		r.InputKafka.PqEnabled = types.BoolPointerValue(resp.InputKafka.PqEnabled)
		r.InputKafka.ReauthenticationThreshold = types.Float64PointerValue(resp.InputKafka.ReauthenticationThreshold)
		r.InputKafka.RebalanceTimeout = types.Float64PointerValue(resp.InputKafka.RebalanceTimeout)
		r.InputKafka.RequestTimeout = types.Float64PointerValue(resp.InputKafka.RequestTimeout)
		if resp.InputKafka.Sasl == nil {
			r.InputKafka.Sasl = nil
		} else {
			r.InputKafka.Sasl = &tfTypes.InputKafkaAuthentication{}
			r.InputKafka.Sasl.Disabled = types.BoolPointerValue(resp.InputKafka.Sasl.Disabled)
			if resp.InputKafka.Sasl.Mechanism != nil {
				r.InputKafka.Sasl.Mechanism = types.StringValue(string(*resp.InputKafka.Sasl.Mechanism))
			} else {
				r.InputKafka.Sasl.Mechanism = types.StringNull()
			}
		}
		r.InputKafka.SendToRoutes = types.BoolPointerValue(resp.InputKafka.SendToRoutes)
		r.InputKafka.SessionTimeout = types.Float64PointerValue(resp.InputKafka.SessionTimeout)
		r.InputKafka.Streamtags = make([]types.String, 0, len(resp.InputKafka.Streamtags))
		for _, v := range resp.InputKafka.Streamtags {
			r.InputKafka.Streamtags = append(r.InputKafka.Streamtags, types.StringValue(v))
		}
		if resp.InputKafka.TLS == nil {
			r.InputKafka.TLS = nil
		} else {
			r.InputKafka.TLS = &tfTypes.InputKafkaTLSSettingsClientSide{}
			r.InputKafka.TLS.CaPath = types.StringPointerValue(resp.InputKafka.TLS.CaPath)
			r.InputKafka.TLS.CertificateName = types.StringPointerValue(resp.InputKafka.TLS.CertificateName)
			r.InputKafka.TLS.CertPath = types.StringPointerValue(resp.InputKafka.TLS.CertPath)
			r.InputKafka.TLS.Disabled = types.BoolPointerValue(resp.InputKafka.TLS.Disabled)
			if resp.InputKafka.TLS.MaxVersion != nil {
				r.InputKafka.TLS.MaxVersion = types.StringValue(string(*resp.InputKafka.TLS.MaxVersion))
			} else {
				r.InputKafka.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputKafka.TLS.MinVersion != nil {
				r.InputKafka.TLS.MinVersion = types.StringValue(string(*resp.InputKafka.TLS.MinVersion))
			} else {
				r.InputKafka.TLS.MinVersion = types.StringNull()
			}
			r.InputKafka.TLS.Passphrase = types.StringPointerValue(resp.InputKafka.TLS.Passphrase)
			r.InputKafka.TLS.PrivKeyPath = types.StringPointerValue(resp.InputKafka.TLS.PrivKeyPath)
			r.InputKafka.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputKafka.TLS.RejectUnauthorized)
			r.InputKafka.TLS.Servername = types.StringPointerValue(resp.InputKafka.TLS.Servername)
		}
		r.InputKafka.Topics = make([]types.String, 0, len(resp.InputKafka.Topics))
		for _, v := range resp.InputKafka.Topics {
			r.InputKafka.Topics = append(r.InputKafka.Topics, types.StringValue(v))
		}
		if resp.InputKafka.Type != nil {
			r.InputKafka.Type = types.StringValue(string(*resp.InputKafka.Type))
		} else {
			r.InputKafka.Type = types.StringNull()
		}
	}
	if resp.InputKinesis != nil {
		r.InputKinesis = &tfTypes.InputKinesis{}
		r.InputKinesis.AssumeRoleArn = types.StringPointerValue(resp.InputKinesis.AssumeRoleArn)
		r.InputKinesis.AssumeRoleExternalID = types.StringPointerValue(resp.InputKinesis.AssumeRoleExternalID)
		r.InputKinesis.AvoidDuplicates = types.BoolPointerValue(resp.InputKinesis.AvoidDuplicates)
		r.InputKinesis.AwsAPIKey = types.StringPointerValue(resp.InputKinesis.AwsAPIKey)
		if resp.InputKinesis.AwsAuthenticationMethod != nil {
			r.InputKinesis.AwsAuthenticationMethod = types.StringValue(string(*resp.InputKinesis.AwsAuthenticationMethod))
		} else {
			r.InputKinesis.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputKinesis.AwsSecret = types.StringPointerValue(resp.InputKinesis.AwsSecret)
		r.InputKinesis.AwsSecretKey = types.StringPointerValue(resp.InputKinesis.AwsSecretKey)
		r.InputKinesis.Connections = []tfTypes.InputKinesisConnection{}
		if len(r.InputKinesis.Connections) > len(resp.InputKinesis.Connections) {
			r.InputKinesis.Connections = r.InputKinesis.Connections[:len(resp.InputKinesis.Connections)]
		}
		for connectionsCount25, connectionsItem25 := range resp.InputKinesis.Connections {
			var connections25 tfTypes.InputKinesisConnection
			connections25.Output = types.StringValue(connectionsItem25.Output)
			connections25.Pipeline = types.StringPointerValue(connectionsItem25.Pipeline)
			if connectionsCount25+1 > len(r.InputKinesis.Connections) {
				r.InputKinesis.Connections = append(r.InputKinesis.Connections, connections25)
			} else {
				r.InputKinesis.Connections[connectionsCount25].Output = connections25.Output
				r.InputKinesis.Connections[connectionsCount25].Pipeline = connections25.Pipeline
			}
		}
		r.InputKinesis.Description = types.StringPointerValue(resp.InputKinesis.Description)
		r.InputKinesis.Disabled = types.BoolPointerValue(resp.InputKinesis.Disabled)
		r.InputKinesis.DurationSeconds = types.Float64PointerValue(resp.InputKinesis.DurationSeconds)
		r.InputKinesis.EnableAssumeRole = types.BoolPointerValue(resp.InputKinesis.EnableAssumeRole)
		r.InputKinesis.Endpoint = types.StringPointerValue(resp.InputKinesis.Endpoint)
		r.InputKinesis.Environment = types.StringPointerValue(resp.InputKinesis.Environment)
		r.InputKinesis.GetRecordsLimit = types.Float64PointerValue(resp.InputKinesis.GetRecordsLimit)
		r.InputKinesis.GetRecordsLimitTotal = types.Float64PointerValue(resp.InputKinesis.GetRecordsLimitTotal)
		r.InputKinesis.ID = types.StringPointerValue(resp.InputKinesis.ID)
		if resp.InputKinesis.LoadBalancingAlgorithm != nil {
			r.InputKinesis.LoadBalancingAlgorithm = types.StringValue(string(*resp.InputKinesis.LoadBalancingAlgorithm))
		} else {
			r.InputKinesis.LoadBalancingAlgorithm = types.StringNull()
		}
		r.InputKinesis.Metadata = []tfTypes.InputKinesisMetadatum{}
		if len(r.InputKinesis.Metadata) > len(resp.InputKinesis.Metadata) {
			r.InputKinesis.Metadata = r.InputKinesis.Metadata[:len(resp.InputKinesis.Metadata)]
		}
		for metadataCount27, metadataItem27 := range resp.InputKinesis.Metadata {
			var metadata27 tfTypes.InputKinesisMetadatum
			metadata27.Name = types.StringValue(metadataItem27.Name)
			metadata27.Value = types.StringValue(metadataItem27.Value)
			if metadataCount27+1 > len(r.InputKinesis.Metadata) {
				r.InputKinesis.Metadata = append(r.InputKinesis.Metadata, metadata27)
			} else {
				r.InputKinesis.Metadata[metadataCount27].Name = metadata27.Name
				r.InputKinesis.Metadata[metadataCount27].Value = metadata27.Value
			}
		}
		if resp.InputKinesis.PayloadFormat != nil {
			r.InputKinesis.PayloadFormat = types.StringValue(string(*resp.InputKinesis.PayloadFormat))
		} else {
			r.InputKinesis.PayloadFormat = types.StringNull()
		}
		r.InputKinesis.Pipeline = types.StringPointerValue(resp.InputKinesis.Pipeline)
		if resp.InputKinesis.Pq == nil {
			r.InputKinesis.Pq = nil
		} else {
			r.InputKinesis.Pq = &tfTypes.InputKinesisPq{}
			r.InputKinesis.Pq.CommitFrequency = types.Float64PointerValue(resp.InputKinesis.Pq.CommitFrequency)
			if resp.InputKinesis.Pq.Compress != nil {
				r.InputKinesis.Pq.Compress = types.StringValue(string(*resp.InputKinesis.Pq.Compress))
			} else {
				r.InputKinesis.Pq.Compress = types.StringNull()
			}
			r.InputKinesis.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputKinesis.Pq.MaxBufferSize)
			r.InputKinesis.Pq.MaxFileSize = types.StringPointerValue(resp.InputKinesis.Pq.MaxFileSize)
			r.InputKinesis.Pq.MaxSize = types.StringPointerValue(resp.InputKinesis.Pq.MaxSize)
			if resp.InputKinesis.Pq.Mode != nil {
				r.InputKinesis.Pq.Mode = types.StringValue(string(*resp.InputKinesis.Pq.Mode))
			} else {
				r.InputKinesis.Pq.Mode = types.StringNull()
			}
			r.InputKinesis.Pq.Path = types.StringPointerValue(resp.InputKinesis.Pq.Path)
		}
		r.InputKinesis.PqEnabled = types.BoolPointerValue(resp.InputKinesis.PqEnabled)
		r.InputKinesis.Region = types.StringValue(resp.InputKinesis.Region)
		r.InputKinesis.RejectUnauthorized = types.BoolPointerValue(resp.InputKinesis.RejectUnauthorized)
		r.InputKinesis.ReuseConnections = types.BoolPointerValue(resp.InputKinesis.ReuseConnections)
		r.InputKinesis.SendToRoutes = types.BoolPointerValue(resp.InputKinesis.SendToRoutes)
		r.InputKinesis.ServiceInterval = types.Float64PointerValue(resp.InputKinesis.ServiceInterval)
		r.InputKinesis.ShardExpr = types.StringPointerValue(resp.InputKinesis.ShardExpr)
		if resp.InputKinesis.ShardIteratorType != nil {
			r.InputKinesis.ShardIteratorType = types.StringValue(string(*resp.InputKinesis.ShardIteratorType))
		} else {
			r.InputKinesis.ShardIteratorType = types.StringNull()
		}
		if resp.InputKinesis.SignatureVersion != nil {
			r.InputKinesis.SignatureVersion = types.StringValue(string(*resp.InputKinesis.SignatureVersion))
		} else {
			r.InputKinesis.SignatureVersion = types.StringNull()
		}
		r.InputKinesis.StreamName = types.StringValue(resp.InputKinesis.StreamName)
		r.InputKinesis.Streamtags = make([]types.String, 0, len(resp.InputKinesis.Streamtags))
		for _, v := range resp.InputKinesis.Streamtags {
			r.InputKinesis.Streamtags = append(r.InputKinesis.Streamtags, types.StringValue(v))
		}
		if resp.InputKinesis.Type != nil {
			r.InputKinesis.Type = types.StringValue(string(*resp.InputKinesis.Type))
		} else {
			r.InputKinesis.Type = types.StringNull()
		}
		r.InputKinesis.VerifyKPLCheckSums = types.BoolPointerValue(resp.InputKinesis.VerifyKPLCheckSums)
	}
	if resp.InputKubeEvents != nil {
		r.InputKubeEvents = &tfTypes.InputKubeEvents{}
		r.InputKubeEvents.Connections = []tfTypes.InputKubeEventsConnection{}
		if len(r.InputKubeEvents.Connections) > len(resp.InputKubeEvents.Connections) {
			r.InputKubeEvents.Connections = r.InputKubeEvents.Connections[:len(resp.InputKubeEvents.Connections)]
		}
		for connectionsCount26, connectionsItem26 := range resp.InputKubeEvents.Connections {
			var connections26 tfTypes.InputKubeEventsConnection
			connections26.Output = types.StringValue(connectionsItem26.Output)
			connections26.Pipeline = types.StringPointerValue(connectionsItem26.Pipeline)
			if connectionsCount26+1 > len(r.InputKubeEvents.Connections) {
				r.InputKubeEvents.Connections = append(r.InputKubeEvents.Connections, connections26)
			} else {
				r.InputKubeEvents.Connections[connectionsCount26].Output = connections26.Output
				r.InputKubeEvents.Connections[connectionsCount26].Pipeline = connections26.Pipeline
			}
		}
		r.InputKubeEvents.Description = types.StringPointerValue(resp.InputKubeEvents.Description)
		r.InputKubeEvents.Disabled = types.BoolPointerValue(resp.InputKubeEvents.Disabled)
		r.InputKubeEvents.Environment = types.StringPointerValue(resp.InputKubeEvents.Environment)
		r.InputKubeEvents.ID = types.StringValue(resp.InputKubeEvents.ID)
		r.InputKubeEvents.Metadata = []tfTypes.InputKubeEventsMetadatum{}
		if len(r.InputKubeEvents.Metadata) > len(resp.InputKubeEvents.Metadata) {
			r.InputKubeEvents.Metadata = r.InputKubeEvents.Metadata[:len(resp.InputKubeEvents.Metadata)]
		}
		for metadataCount28, metadataItem28 := range resp.InputKubeEvents.Metadata {
			var metadata28 tfTypes.InputKubeEventsMetadatum
			metadata28.Name = types.StringValue(metadataItem28.Name)
			metadata28.Value = types.StringValue(metadataItem28.Value)
			if metadataCount28+1 > len(r.InputKubeEvents.Metadata) {
				r.InputKubeEvents.Metadata = append(r.InputKubeEvents.Metadata, metadata28)
			} else {
				r.InputKubeEvents.Metadata[metadataCount28].Name = metadata28.Name
				r.InputKubeEvents.Metadata[metadataCount28].Value = metadata28.Value
			}
		}
		r.InputKubeEvents.Pipeline = types.StringPointerValue(resp.InputKubeEvents.Pipeline)
		if resp.InputKubeEvents.Pq == nil {
			r.InputKubeEvents.Pq = nil
		} else {
			r.InputKubeEvents.Pq = &tfTypes.InputKubeEventsPq{}
			r.InputKubeEvents.Pq.CommitFrequency = types.Float64PointerValue(resp.InputKubeEvents.Pq.CommitFrequency)
			if resp.InputKubeEvents.Pq.Compress != nil {
				r.InputKubeEvents.Pq.Compress = types.StringValue(string(*resp.InputKubeEvents.Pq.Compress))
			} else {
				r.InputKubeEvents.Pq.Compress = types.StringNull()
			}
			r.InputKubeEvents.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputKubeEvents.Pq.MaxBufferSize)
			r.InputKubeEvents.Pq.MaxFileSize = types.StringPointerValue(resp.InputKubeEvents.Pq.MaxFileSize)
			r.InputKubeEvents.Pq.MaxSize = types.StringPointerValue(resp.InputKubeEvents.Pq.MaxSize)
			if resp.InputKubeEvents.Pq.Mode != nil {
				r.InputKubeEvents.Pq.Mode = types.StringValue(string(*resp.InputKubeEvents.Pq.Mode))
			} else {
				r.InputKubeEvents.Pq.Mode = types.StringNull()
			}
			r.InputKubeEvents.Pq.Path = types.StringPointerValue(resp.InputKubeEvents.Pq.Path)
		}
		r.InputKubeEvents.PqEnabled = types.BoolPointerValue(resp.InputKubeEvents.PqEnabled)
		r.InputKubeEvents.Rules = []tfTypes.InputKubeEventsRule{}
		if len(r.InputKubeEvents.Rules) > len(resp.InputKubeEvents.Rules) {
			r.InputKubeEvents.Rules = r.InputKubeEvents.Rules[:len(resp.InputKubeEvents.Rules)]
		}
		for rulesCount1, rulesItem1 := range resp.InputKubeEvents.Rules {
			var rules1 tfTypes.InputKubeEventsRule
			rules1.Description = types.StringPointerValue(rulesItem1.Description)
			rules1.Filter = types.StringValue(rulesItem1.Filter)
			if rulesCount1+1 > len(r.InputKubeEvents.Rules) {
				r.InputKubeEvents.Rules = append(r.InputKubeEvents.Rules, rules1)
			} else {
				r.InputKubeEvents.Rules[rulesCount1].Description = rules1.Description
				r.InputKubeEvents.Rules[rulesCount1].Filter = rules1.Filter
			}
		}
		r.InputKubeEvents.SendToRoutes = types.BoolPointerValue(resp.InputKubeEvents.SendToRoutes)
		r.InputKubeEvents.Streamtags = make([]types.String, 0, len(resp.InputKubeEvents.Streamtags))
		for _, v := range resp.InputKubeEvents.Streamtags {
			r.InputKubeEvents.Streamtags = append(r.InputKubeEvents.Streamtags, types.StringValue(v))
		}
		r.InputKubeEvents.Type = types.StringValue(string(resp.InputKubeEvents.Type))
	}
	if resp.InputKubeLogs != nil {
		r.InputKubeLogs = &tfTypes.InputKubeLogs{}
		r.InputKubeLogs.BreakerRulesets = make([]types.String, 0, len(resp.InputKubeLogs.BreakerRulesets))
		for _, v := range resp.InputKubeLogs.BreakerRulesets {
			r.InputKubeLogs.BreakerRulesets = append(r.InputKubeLogs.BreakerRulesets, types.StringValue(v))
		}
		r.InputKubeLogs.Connections = []tfTypes.InputKubeLogsConnection{}
		if len(r.InputKubeLogs.Connections) > len(resp.InputKubeLogs.Connections) {
			r.InputKubeLogs.Connections = r.InputKubeLogs.Connections[:len(resp.InputKubeLogs.Connections)]
		}
		for connectionsCount27, connectionsItem27 := range resp.InputKubeLogs.Connections {
			var connections27 tfTypes.InputKubeLogsConnection
			connections27.Output = types.StringValue(connectionsItem27.Output)
			connections27.Pipeline = types.StringPointerValue(connectionsItem27.Pipeline)
			if connectionsCount27+1 > len(r.InputKubeLogs.Connections) {
				r.InputKubeLogs.Connections = append(r.InputKubeLogs.Connections, connections27)
			} else {
				r.InputKubeLogs.Connections[connectionsCount27].Output = connections27.Output
				r.InputKubeLogs.Connections[connectionsCount27].Pipeline = connections27.Pipeline
			}
		}
		r.InputKubeLogs.Description = types.StringPointerValue(resp.InputKubeLogs.Description)
		r.InputKubeLogs.Disabled = types.BoolPointerValue(resp.InputKubeLogs.Disabled)
		r.InputKubeLogs.EnableLoadBalancing = types.BoolPointerValue(resp.InputKubeLogs.EnableLoadBalancing)
		r.InputKubeLogs.Environment = types.StringPointerValue(resp.InputKubeLogs.Environment)
		r.InputKubeLogs.ID = types.StringValue(resp.InputKubeLogs.ID)
		r.InputKubeLogs.Interval = types.Float64PointerValue(resp.InputKubeLogs.Interval)
		r.InputKubeLogs.Metadata = []tfTypes.InputKubeLogsMetadatum{}
		if len(r.InputKubeLogs.Metadata) > len(resp.InputKubeLogs.Metadata) {
			r.InputKubeLogs.Metadata = r.InputKubeLogs.Metadata[:len(resp.InputKubeLogs.Metadata)]
		}
		for metadataCount29, metadataItem29 := range resp.InputKubeLogs.Metadata {
			var metadata29 tfTypes.InputKubeLogsMetadatum
			metadata29.Name = types.StringValue(metadataItem29.Name)
			metadata29.Value = types.StringValue(metadataItem29.Value)
			if metadataCount29+1 > len(r.InputKubeLogs.Metadata) {
				r.InputKubeLogs.Metadata = append(r.InputKubeLogs.Metadata, metadata29)
			} else {
				r.InputKubeLogs.Metadata[metadataCount29].Name = metadata29.Name
				r.InputKubeLogs.Metadata[metadataCount29].Value = metadata29.Value
			}
		}
		if resp.InputKubeLogs.Persistence == nil {
			r.InputKubeLogs.Persistence = nil
		} else {
			r.InputKubeLogs.Persistence = &tfTypes.InputKubeLogsDiskSpooling{}
			if resp.InputKubeLogs.Persistence.Compress != nil {
				r.InputKubeLogs.Persistence.Compress = types.StringValue(string(*resp.InputKubeLogs.Persistence.Compress))
			} else {
				r.InputKubeLogs.Persistence.Compress = types.StringNull()
			}
			r.InputKubeLogs.Persistence.Enable = types.BoolPointerValue(resp.InputKubeLogs.Persistence.Enable)
			r.InputKubeLogs.Persistence.MaxDataSize = types.StringPointerValue(resp.InputKubeLogs.Persistence.MaxDataSize)
			r.InputKubeLogs.Persistence.MaxDataTime = types.StringPointerValue(resp.InputKubeLogs.Persistence.MaxDataTime)
			r.InputKubeLogs.Persistence.TimeWindow = types.StringPointerValue(resp.InputKubeLogs.Persistence.TimeWindow)
		}
		r.InputKubeLogs.Pipeline = types.StringPointerValue(resp.InputKubeLogs.Pipeline)
		if resp.InputKubeLogs.Pq == nil {
			r.InputKubeLogs.Pq = nil
		} else {
			r.InputKubeLogs.Pq = &tfTypes.InputKubeLogsPq{}
			r.InputKubeLogs.Pq.CommitFrequency = types.Float64PointerValue(resp.InputKubeLogs.Pq.CommitFrequency)
			if resp.InputKubeLogs.Pq.Compress != nil {
				r.InputKubeLogs.Pq.Compress = types.StringValue(string(*resp.InputKubeLogs.Pq.Compress))
			} else {
				r.InputKubeLogs.Pq.Compress = types.StringNull()
			}
			r.InputKubeLogs.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputKubeLogs.Pq.MaxBufferSize)
			r.InputKubeLogs.Pq.MaxFileSize = types.StringPointerValue(resp.InputKubeLogs.Pq.MaxFileSize)
			r.InputKubeLogs.Pq.MaxSize = types.StringPointerValue(resp.InputKubeLogs.Pq.MaxSize)
			if resp.InputKubeLogs.Pq.Mode != nil {
				r.InputKubeLogs.Pq.Mode = types.StringValue(string(*resp.InputKubeLogs.Pq.Mode))
			} else {
				r.InputKubeLogs.Pq.Mode = types.StringNull()
			}
			r.InputKubeLogs.Pq.Path = types.StringPointerValue(resp.InputKubeLogs.Pq.Path)
		}
		r.InputKubeLogs.PqEnabled = types.BoolPointerValue(resp.InputKubeLogs.PqEnabled)
		r.InputKubeLogs.Rules = []tfTypes.InputKubeLogsRule{}
		if len(r.InputKubeLogs.Rules) > len(resp.InputKubeLogs.Rules) {
			r.InputKubeLogs.Rules = r.InputKubeLogs.Rules[:len(resp.InputKubeLogs.Rules)]
		}
		for rulesCount2, rulesItem2 := range resp.InputKubeLogs.Rules {
			var rules2 tfTypes.InputKubeLogsRule
			rules2.Description = types.StringPointerValue(rulesItem2.Description)
			rules2.Filter = types.StringValue(rulesItem2.Filter)
			if rulesCount2+1 > len(r.InputKubeLogs.Rules) {
				r.InputKubeLogs.Rules = append(r.InputKubeLogs.Rules, rules2)
			} else {
				r.InputKubeLogs.Rules[rulesCount2].Description = rules2.Description
				r.InputKubeLogs.Rules[rulesCount2].Filter = rules2.Filter
			}
		}
		r.InputKubeLogs.SendToRoutes = types.BoolPointerValue(resp.InputKubeLogs.SendToRoutes)
		r.InputKubeLogs.StaleChannelFlushMs = types.Float64PointerValue(resp.InputKubeLogs.StaleChannelFlushMs)
		r.InputKubeLogs.Streamtags = make([]types.String, 0, len(resp.InputKubeLogs.Streamtags))
		for _, v := range resp.InputKubeLogs.Streamtags {
			r.InputKubeLogs.Streamtags = append(r.InputKubeLogs.Streamtags, types.StringValue(v))
		}
		r.InputKubeLogs.Timestamps = types.BoolPointerValue(resp.InputKubeLogs.Timestamps)
		r.InputKubeLogs.Type = types.StringValue(string(resp.InputKubeLogs.Type))
	}
	if resp.InputKubeMetrics != nil {
		r.InputKubeMetrics = &tfTypes.InputKubeMetrics{}
		r.InputKubeMetrics.Connections = []tfTypes.InputKubeMetricsConnection{}
		if len(r.InputKubeMetrics.Connections) > len(resp.InputKubeMetrics.Connections) {
			r.InputKubeMetrics.Connections = r.InputKubeMetrics.Connections[:len(resp.InputKubeMetrics.Connections)]
		}
		for connectionsCount28, connectionsItem28 := range resp.InputKubeMetrics.Connections {
			var connections28 tfTypes.InputKubeMetricsConnection
			connections28.Output = types.StringValue(connectionsItem28.Output)
			connections28.Pipeline = types.StringPointerValue(connectionsItem28.Pipeline)
			if connectionsCount28+1 > len(r.InputKubeMetrics.Connections) {
				r.InputKubeMetrics.Connections = append(r.InputKubeMetrics.Connections, connections28)
			} else {
				r.InputKubeMetrics.Connections[connectionsCount28].Output = connections28.Output
				r.InputKubeMetrics.Connections[connectionsCount28].Pipeline = connections28.Pipeline
			}
		}
		r.InputKubeMetrics.Description = types.StringPointerValue(resp.InputKubeMetrics.Description)
		r.InputKubeMetrics.Disabled = types.BoolPointerValue(resp.InputKubeMetrics.Disabled)
		r.InputKubeMetrics.Environment = types.StringPointerValue(resp.InputKubeMetrics.Environment)
		r.InputKubeMetrics.ID = types.StringValue(resp.InputKubeMetrics.ID)
		r.InputKubeMetrics.Interval = types.Float64PointerValue(resp.InputKubeMetrics.Interval)
		r.InputKubeMetrics.Metadata = []tfTypes.InputKubeMetricsMetadatum{}
		if len(r.InputKubeMetrics.Metadata) > len(resp.InputKubeMetrics.Metadata) {
			r.InputKubeMetrics.Metadata = r.InputKubeMetrics.Metadata[:len(resp.InputKubeMetrics.Metadata)]
		}
		for metadataCount30, metadataItem30 := range resp.InputKubeMetrics.Metadata {
			var metadata30 tfTypes.InputKubeMetricsMetadatum
			metadata30.Name = types.StringValue(metadataItem30.Name)
			metadata30.Value = types.StringValue(metadataItem30.Value)
			if metadataCount30+1 > len(r.InputKubeMetrics.Metadata) {
				r.InputKubeMetrics.Metadata = append(r.InputKubeMetrics.Metadata, metadata30)
			} else {
				r.InputKubeMetrics.Metadata[metadataCount30].Name = metadata30.Name
				r.InputKubeMetrics.Metadata[metadataCount30].Value = metadata30.Value
			}
		}
		if resp.InputKubeMetrics.Persistence == nil {
			r.InputKubeMetrics.Persistence = nil
		} else {
			r.InputKubeMetrics.Persistence = &tfTypes.InputKubeMetricsPersistence{}
			if resp.InputKubeMetrics.Persistence.Compress != nil {
				r.InputKubeMetrics.Persistence.Compress = types.StringValue(string(*resp.InputKubeMetrics.Persistence.Compress))
			} else {
				r.InputKubeMetrics.Persistence.Compress = types.StringNull()
			}
			r.InputKubeMetrics.Persistence.DestPath = types.StringPointerValue(resp.InputKubeMetrics.Persistence.DestPath)
			r.InputKubeMetrics.Persistence.Enable = types.BoolPointerValue(resp.InputKubeMetrics.Persistence.Enable)
			r.InputKubeMetrics.Persistence.MaxDataSize = types.StringPointerValue(resp.InputKubeMetrics.Persistence.MaxDataSize)
			r.InputKubeMetrics.Persistence.MaxDataTime = types.StringPointerValue(resp.InputKubeMetrics.Persistence.MaxDataTime)
			r.InputKubeMetrics.Persistence.TimeWindow = types.StringPointerValue(resp.InputKubeMetrics.Persistence.TimeWindow)
		}
		r.InputKubeMetrics.Pipeline = types.StringPointerValue(resp.InputKubeMetrics.Pipeline)
		if resp.InputKubeMetrics.Pq == nil {
			r.InputKubeMetrics.Pq = nil
		} else {
			r.InputKubeMetrics.Pq = &tfTypes.InputKubeMetricsPq{}
			r.InputKubeMetrics.Pq.CommitFrequency = types.Float64PointerValue(resp.InputKubeMetrics.Pq.CommitFrequency)
			if resp.InputKubeMetrics.Pq.Compress != nil {
				r.InputKubeMetrics.Pq.Compress = types.StringValue(string(*resp.InputKubeMetrics.Pq.Compress))
			} else {
				r.InputKubeMetrics.Pq.Compress = types.StringNull()
			}
			r.InputKubeMetrics.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputKubeMetrics.Pq.MaxBufferSize)
			r.InputKubeMetrics.Pq.MaxFileSize = types.StringPointerValue(resp.InputKubeMetrics.Pq.MaxFileSize)
			r.InputKubeMetrics.Pq.MaxSize = types.StringPointerValue(resp.InputKubeMetrics.Pq.MaxSize)
			if resp.InputKubeMetrics.Pq.Mode != nil {
				r.InputKubeMetrics.Pq.Mode = types.StringValue(string(*resp.InputKubeMetrics.Pq.Mode))
			} else {
				r.InputKubeMetrics.Pq.Mode = types.StringNull()
			}
			r.InputKubeMetrics.Pq.Path = types.StringPointerValue(resp.InputKubeMetrics.Pq.Path)
		}
		r.InputKubeMetrics.PqEnabled = types.BoolPointerValue(resp.InputKubeMetrics.PqEnabled)
		r.InputKubeMetrics.Rules = []tfTypes.InputKubeMetricsRule{}
		if len(r.InputKubeMetrics.Rules) > len(resp.InputKubeMetrics.Rules) {
			r.InputKubeMetrics.Rules = r.InputKubeMetrics.Rules[:len(resp.InputKubeMetrics.Rules)]
		}
		for rulesCount3, rulesItem3 := range resp.InputKubeMetrics.Rules {
			var rules3 tfTypes.InputKubeMetricsRule
			rules3.Description = types.StringPointerValue(rulesItem3.Description)
			rules3.Filter = types.StringValue(rulesItem3.Filter)
			if rulesCount3+1 > len(r.InputKubeMetrics.Rules) {
				r.InputKubeMetrics.Rules = append(r.InputKubeMetrics.Rules, rules3)
			} else {
				r.InputKubeMetrics.Rules[rulesCount3].Description = rules3.Description
				r.InputKubeMetrics.Rules[rulesCount3].Filter = rules3.Filter
			}
		}
		r.InputKubeMetrics.SendToRoutes = types.BoolPointerValue(resp.InputKubeMetrics.SendToRoutes)
		r.InputKubeMetrics.Streamtags = make([]types.String, 0, len(resp.InputKubeMetrics.Streamtags))
		for _, v := range resp.InputKubeMetrics.Streamtags {
			r.InputKubeMetrics.Streamtags = append(r.InputKubeMetrics.Streamtags, types.StringValue(v))
		}
		r.InputKubeMetrics.Type = types.StringValue(string(resp.InputKubeMetrics.Type))
	}
	if resp.InputLoki != nil {
		r.InputLoki = &tfTypes.InputLoki{}
		r.InputLoki.ActivityLogSampleRate = types.Float64PointerValue(resp.InputLoki.ActivityLogSampleRate)
		r.InputLoki.AuthHeaderExpr = types.StringPointerValue(resp.InputLoki.AuthHeaderExpr)
		if resp.InputLoki.AuthType != nil {
			r.InputLoki.AuthType = types.StringValue(string(*resp.InputLoki.AuthType))
		} else {
			r.InputLoki.AuthType = types.StringNull()
		}
		r.InputLoki.CaptureHeaders = types.BoolPointerValue(resp.InputLoki.CaptureHeaders)
		r.InputLoki.Connections = []tfTypes.InputLokiConnection{}
		if len(r.InputLoki.Connections) > len(resp.InputLoki.Connections) {
			r.InputLoki.Connections = r.InputLoki.Connections[:len(resp.InputLoki.Connections)]
		}
		for connectionsCount29, connectionsItem29 := range resp.InputLoki.Connections {
			var connections29 tfTypes.InputLokiConnection
			connections29.Output = types.StringValue(connectionsItem29.Output)
			connections29.Pipeline = types.StringPointerValue(connectionsItem29.Pipeline)
			if connectionsCount29+1 > len(r.InputLoki.Connections) {
				r.InputLoki.Connections = append(r.InputLoki.Connections, connections29)
			} else {
				r.InputLoki.Connections[connectionsCount29].Output = connections29.Output
				r.InputLoki.Connections[connectionsCount29].Pipeline = connections29.Pipeline
			}
		}
		r.InputLoki.CredentialsSecret = types.StringPointerValue(resp.InputLoki.CredentialsSecret)
		r.InputLoki.Description = types.StringPointerValue(resp.InputLoki.Description)
		r.InputLoki.Disabled = types.BoolPointerValue(resp.InputLoki.Disabled)
		r.InputLoki.EnableHealthCheck = types.BoolPointerValue(resp.InputLoki.EnableHealthCheck)
		r.InputLoki.EnableProxyHeader = types.BoolPointerValue(resp.InputLoki.EnableProxyHeader)
		r.InputLoki.Environment = types.StringPointerValue(resp.InputLoki.Environment)
		r.InputLoki.Host = types.StringPointerValue(resp.InputLoki.Host)
		r.InputLoki.ID = types.StringPointerValue(resp.InputLoki.ID)
		r.InputLoki.IPAllowlistRegex = types.StringPointerValue(resp.InputLoki.IPAllowlistRegex)
		r.InputLoki.IPDenylistRegex = types.StringPointerValue(resp.InputLoki.IPDenylistRegex)
		r.InputLoki.KeepAliveTimeout = types.Float64PointerValue(resp.InputLoki.KeepAliveTimeout)
		r.InputLoki.LoginURL = types.StringPointerValue(resp.InputLoki.LoginURL)
		r.InputLoki.LokiAPI = types.StringPointerValue(resp.InputLoki.LokiAPI)
		r.InputLoki.MaxActiveReq = types.Float64PointerValue(resp.InputLoki.MaxActiveReq)
		r.InputLoki.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputLoki.MaxRequestsPerSocket)
		r.InputLoki.Metadata = []tfTypes.InputLokiMetadatum{}
		if len(r.InputLoki.Metadata) > len(resp.InputLoki.Metadata) {
			r.InputLoki.Metadata = r.InputLoki.Metadata[:len(resp.InputLoki.Metadata)]
		}
		for metadataCount31, metadataItem31 := range resp.InputLoki.Metadata {
			var metadata31 tfTypes.InputLokiMetadatum
			metadata31.Name = types.StringValue(metadataItem31.Name)
			metadata31.Value = types.StringValue(metadataItem31.Value)
			if metadataCount31+1 > len(r.InputLoki.Metadata) {
				r.InputLoki.Metadata = append(r.InputLoki.Metadata, metadata31)
			} else {
				r.InputLoki.Metadata[metadataCount31].Name = metadata31.Name
				r.InputLoki.Metadata[metadataCount31].Value = metadata31.Value
			}
		}
		r.InputLoki.OauthHeaders = []tfTypes.InputLokiOauthHeader{}
		if len(r.InputLoki.OauthHeaders) > len(resp.InputLoki.OauthHeaders) {
			r.InputLoki.OauthHeaders = r.InputLoki.OauthHeaders[:len(resp.InputLoki.OauthHeaders)]
		}
		for oauthHeadersCount4, oauthHeadersItem4 := range resp.InputLoki.OauthHeaders {
			var oauthHeaders4 tfTypes.InputLokiOauthHeader
			oauthHeaders4.Name = types.StringValue(oauthHeadersItem4.Name)
			oauthHeaders4.Value = types.StringValue(oauthHeadersItem4.Value)
			if oauthHeadersCount4+1 > len(r.InputLoki.OauthHeaders) {
				r.InputLoki.OauthHeaders = append(r.InputLoki.OauthHeaders, oauthHeaders4)
			} else {
				r.InputLoki.OauthHeaders[oauthHeadersCount4].Name = oauthHeaders4.Name
				r.InputLoki.OauthHeaders[oauthHeadersCount4].Value = oauthHeaders4.Value
			}
		}
		r.InputLoki.OauthParams = []tfTypes.InputLokiOauthParam{}
		if len(r.InputLoki.OauthParams) > len(resp.InputLoki.OauthParams) {
			r.InputLoki.OauthParams = r.InputLoki.OauthParams[:len(resp.InputLoki.OauthParams)]
		}
		for oauthParamsCount4, oauthParamsItem4 := range resp.InputLoki.OauthParams {
			var oauthParams4 tfTypes.InputLokiOauthParam
			oauthParams4.Name = types.StringValue(oauthParamsItem4.Name)
			oauthParams4.Value = types.StringValue(oauthParamsItem4.Value)
			if oauthParamsCount4+1 > len(r.InputLoki.OauthParams) {
				r.InputLoki.OauthParams = append(r.InputLoki.OauthParams, oauthParams4)
			} else {
				r.InputLoki.OauthParams[oauthParamsCount4].Name = oauthParams4.Name
				r.InputLoki.OauthParams[oauthParamsCount4].Value = oauthParams4.Value
			}
		}
		r.InputLoki.Password = types.StringPointerValue(resp.InputLoki.Password)
		r.InputLoki.Pipeline = types.StringPointerValue(resp.InputLoki.Pipeline)
		r.InputLoki.Port = types.Float64Value(resp.InputLoki.Port)
		if resp.InputLoki.Pq == nil {
			r.InputLoki.Pq = nil
		} else {
			r.InputLoki.Pq = &tfTypes.InputLokiPq{}
			r.InputLoki.Pq.CommitFrequency = types.Float64PointerValue(resp.InputLoki.Pq.CommitFrequency)
			if resp.InputLoki.Pq.Compress != nil {
				r.InputLoki.Pq.Compress = types.StringValue(string(*resp.InputLoki.Pq.Compress))
			} else {
				r.InputLoki.Pq.Compress = types.StringNull()
			}
			r.InputLoki.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputLoki.Pq.MaxBufferSize)
			r.InputLoki.Pq.MaxFileSize = types.StringPointerValue(resp.InputLoki.Pq.MaxFileSize)
			r.InputLoki.Pq.MaxSize = types.StringPointerValue(resp.InputLoki.Pq.MaxSize)
			if resp.InputLoki.Pq.Mode != nil {
				r.InputLoki.Pq.Mode = types.StringValue(string(*resp.InputLoki.Pq.Mode))
			} else {
				r.InputLoki.Pq.Mode = types.StringNull()
			}
			r.InputLoki.Pq.Path = types.StringPointerValue(resp.InputLoki.Pq.Path)
		}
		r.InputLoki.PqEnabled = types.BoolPointerValue(resp.InputLoki.PqEnabled)
		r.InputLoki.RequestTimeout = types.Float64PointerValue(resp.InputLoki.RequestTimeout)
		r.InputLoki.Secret = types.StringPointerValue(resp.InputLoki.Secret)
		r.InputLoki.SecretParamName = types.StringPointerValue(resp.InputLoki.SecretParamName)
		r.InputLoki.SendToRoutes = types.BoolPointerValue(resp.InputLoki.SendToRoutes)
		r.InputLoki.SocketTimeout = types.Float64PointerValue(resp.InputLoki.SocketTimeout)
		r.InputLoki.Streamtags = make([]types.String, 0, len(resp.InputLoki.Streamtags))
		for _, v := range resp.InputLoki.Streamtags {
			r.InputLoki.Streamtags = append(r.InputLoki.Streamtags, types.StringValue(v))
		}
		r.InputLoki.TextSecret = types.StringPointerValue(resp.InputLoki.TextSecret)
		if resp.InputLoki.TLS == nil {
			r.InputLoki.TLS = nil
		} else {
			r.InputLoki.TLS = &tfTypes.InputLokiTLSSettingsServerSide{}
			r.InputLoki.TLS.CaPath = types.StringPointerValue(resp.InputLoki.TLS.CaPath)
			r.InputLoki.TLS.CertificateName = types.StringPointerValue(resp.InputLoki.TLS.CertificateName)
			r.InputLoki.TLS.CertPath = types.StringPointerValue(resp.InputLoki.TLS.CertPath)
			if resp.InputLoki.TLS.CommonNameRegex == nil {
				r.InputLoki.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult11, _ := json.Marshal(resp.InputLoki.TLS.CommonNameRegex)
				r.InputLoki.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult11))
			}
			r.InputLoki.TLS.Disabled = types.BoolPointerValue(resp.InputLoki.TLS.Disabled)
			if resp.InputLoki.TLS.MaxVersion != nil {
				r.InputLoki.TLS.MaxVersion = types.StringValue(string(*resp.InputLoki.TLS.MaxVersion))
			} else {
				r.InputLoki.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputLoki.TLS.MinVersion != nil {
				r.InputLoki.TLS.MinVersion = types.StringValue(string(*resp.InputLoki.TLS.MinVersion))
			} else {
				r.InputLoki.TLS.MinVersion = types.StringNull()
			}
			r.InputLoki.TLS.Passphrase = types.StringPointerValue(resp.InputLoki.TLS.Passphrase)
			r.InputLoki.TLS.PrivKeyPath = types.StringPointerValue(resp.InputLoki.TLS.PrivKeyPath)
			if resp.InputLoki.TLS.RejectUnauthorized == nil {
				r.InputLoki.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult11, _ := json.Marshal(resp.InputLoki.TLS.RejectUnauthorized)
				r.InputLoki.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult11))
			}
			r.InputLoki.TLS.RequestCert = types.BoolPointerValue(resp.InputLoki.TLS.RequestCert)
		}
		r.InputLoki.Token = types.StringPointerValue(resp.InputLoki.Token)
		r.InputLoki.TokenAttributeName = types.StringPointerValue(resp.InputLoki.TokenAttributeName)
		r.InputLoki.TokenTimeoutSecs = types.Float64PointerValue(resp.InputLoki.TokenTimeoutSecs)
		if resp.InputLoki.Type != nil {
			r.InputLoki.Type = types.StringValue(string(*resp.InputLoki.Type))
		} else {
			r.InputLoki.Type = types.StringNull()
		}
		r.InputLoki.Username = types.StringPointerValue(resp.InputLoki.Username)
	}
	if resp.InputMetrics != nil {
		r.InputMetrics = &tfTypes.InputMetrics{}
		r.InputMetrics.Connections = []tfTypes.InputMetricsConnection{}
		if len(r.InputMetrics.Connections) > len(resp.InputMetrics.Connections) {
			r.InputMetrics.Connections = r.InputMetrics.Connections[:len(resp.InputMetrics.Connections)]
		}
		for connectionsCount30, connectionsItem30 := range resp.InputMetrics.Connections {
			var connections30 tfTypes.InputMetricsConnection
			connections30.Output = types.StringValue(connectionsItem30.Output)
			connections30.Pipeline = types.StringPointerValue(connectionsItem30.Pipeline)
			if connectionsCount30+1 > len(r.InputMetrics.Connections) {
				r.InputMetrics.Connections = append(r.InputMetrics.Connections, connections30)
			} else {
				r.InputMetrics.Connections[connectionsCount30].Output = connections30.Output
				r.InputMetrics.Connections[connectionsCount30].Pipeline = connections30.Pipeline
			}
		}
		r.InputMetrics.Description = types.StringPointerValue(resp.InputMetrics.Description)
		r.InputMetrics.Disabled = types.BoolPointerValue(resp.InputMetrics.Disabled)
		r.InputMetrics.EnableProxyHeader = types.BoolPointerValue(resp.InputMetrics.EnableProxyHeader)
		r.InputMetrics.Environment = types.StringPointerValue(resp.InputMetrics.Environment)
		r.InputMetrics.Host = types.StringPointerValue(resp.InputMetrics.Host)
		r.InputMetrics.ID = types.StringPointerValue(resp.InputMetrics.ID)
		r.InputMetrics.IPWhitelistRegex = types.StringPointerValue(resp.InputMetrics.IPWhitelistRegex)
		r.InputMetrics.MaxBufferSize = types.Float64PointerValue(resp.InputMetrics.MaxBufferSize)
		r.InputMetrics.Metadata = []tfTypes.InputMetricsMetadatum{}
		if len(r.InputMetrics.Metadata) > len(resp.InputMetrics.Metadata) {
			r.InputMetrics.Metadata = r.InputMetrics.Metadata[:len(resp.InputMetrics.Metadata)]
		}
		for metadataCount32, metadataItem32 := range resp.InputMetrics.Metadata {
			var metadata32 tfTypes.InputMetricsMetadatum
			metadata32.Name = types.StringValue(metadataItem32.Name)
			metadata32.Value = types.StringValue(metadataItem32.Value)
			if metadataCount32+1 > len(r.InputMetrics.Metadata) {
				r.InputMetrics.Metadata = append(r.InputMetrics.Metadata, metadata32)
			} else {
				r.InputMetrics.Metadata[metadataCount32].Name = metadata32.Name
				r.InputMetrics.Metadata[metadataCount32].Value = metadata32.Value
			}
		}
		r.InputMetrics.Pipeline = types.StringPointerValue(resp.InputMetrics.Pipeline)
		if resp.InputMetrics.Pq == nil {
			r.InputMetrics.Pq = nil
		} else {
			r.InputMetrics.Pq = &tfTypes.InputMetricsPq{}
			r.InputMetrics.Pq.CommitFrequency = types.Float64PointerValue(resp.InputMetrics.Pq.CommitFrequency)
			if resp.InputMetrics.Pq.Compress != nil {
				r.InputMetrics.Pq.Compress = types.StringValue(string(*resp.InputMetrics.Pq.Compress))
			} else {
				r.InputMetrics.Pq.Compress = types.StringNull()
			}
			r.InputMetrics.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputMetrics.Pq.MaxBufferSize)
			r.InputMetrics.Pq.MaxFileSize = types.StringPointerValue(resp.InputMetrics.Pq.MaxFileSize)
			r.InputMetrics.Pq.MaxSize = types.StringPointerValue(resp.InputMetrics.Pq.MaxSize)
			if resp.InputMetrics.Pq.Mode != nil {
				r.InputMetrics.Pq.Mode = types.StringValue(string(*resp.InputMetrics.Pq.Mode))
			} else {
				r.InputMetrics.Pq.Mode = types.StringNull()
			}
			r.InputMetrics.Pq.Path = types.StringPointerValue(resp.InputMetrics.Pq.Path)
		}
		r.InputMetrics.PqEnabled = types.BoolPointerValue(resp.InputMetrics.PqEnabled)
		r.InputMetrics.SendToRoutes = types.BoolPointerValue(resp.InputMetrics.SendToRoutes)
		r.InputMetrics.Streamtags = make([]types.String, 0, len(resp.InputMetrics.Streamtags))
		for _, v := range resp.InputMetrics.Streamtags {
			r.InputMetrics.Streamtags = append(r.InputMetrics.Streamtags, types.StringValue(v))
		}
		r.InputMetrics.TCPPort = types.Float64PointerValue(resp.InputMetrics.TCPPort)
		if resp.InputMetrics.TLS == nil {
			r.InputMetrics.TLS = nil
		} else {
			r.InputMetrics.TLS = &tfTypes.InputMetricsTLSSettingsServerSide{}
			r.InputMetrics.TLS.CaPath = types.StringPointerValue(resp.InputMetrics.TLS.CaPath)
			r.InputMetrics.TLS.CertificateName = types.StringPointerValue(resp.InputMetrics.TLS.CertificateName)
			r.InputMetrics.TLS.CertPath = types.StringPointerValue(resp.InputMetrics.TLS.CertPath)
			if resp.InputMetrics.TLS.CommonNameRegex == nil {
				r.InputMetrics.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult12, _ := json.Marshal(resp.InputMetrics.TLS.CommonNameRegex)
				r.InputMetrics.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult12))
			}
			r.InputMetrics.TLS.Disabled = types.BoolPointerValue(resp.InputMetrics.TLS.Disabled)
			if resp.InputMetrics.TLS.MaxVersion != nil {
				r.InputMetrics.TLS.MaxVersion = types.StringValue(string(*resp.InputMetrics.TLS.MaxVersion))
			} else {
				r.InputMetrics.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputMetrics.TLS.MinVersion != nil {
				r.InputMetrics.TLS.MinVersion = types.StringValue(string(*resp.InputMetrics.TLS.MinVersion))
			} else {
				r.InputMetrics.TLS.MinVersion = types.StringNull()
			}
			r.InputMetrics.TLS.Passphrase = types.StringPointerValue(resp.InputMetrics.TLS.Passphrase)
			r.InputMetrics.TLS.PrivKeyPath = types.StringPointerValue(resp.InputMetrics.TLS.PrivKeyPath)
			if resp.InputMetrics.TLS.RejectUnauthorized == nil {
				r.InputMetrics.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult12, _ := json.Marshal(resp.InputMetrics.TLS.RejectUnauthorized)
				r.InputMetrics.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult12))
			}
			r.InputMetrics.TLS.RequestCert = types.BoolPointerValue(resp.InputMetrics.TLS.RequestCert)
		}
		r.InputMetrics.Type = types.StringValue(string(resp.InputMetrics.Type))
		r.InputMetrics.UDPPort = types.Float64PointerValue(resp.InputMetrics.UDPPort)
		r.InputMetrics.UDPSocketRxBufSize = types.Float64PointerValue(resp.InputMetrics.UDPSocketRxBufSize)
	}
	if resp.InputModelDrivenTelemetry != nil {
		r.InputModelDrivenTelemetry = &tfTypes.InputModelDrivenTelemetry{}
		r.InputModelDrivenTelemetry.Connections = []tfTypes.InputModelDrivenTelemetryConnection{}
		if len(r.InputModelDrivenTelemetry.Connections) > len(resp.InputModelDrivenTelemetry.Connections) {
			r.InputModelDrivenTelemetry.Connections = r.InputModelDrivenTelemetry.Connections[:len(resp.InputModelDrivenTelemetry.Connections)]
		}
		for connectionsCount31, connectionsItem31 := range resp.InputModelDrivenTelemetry.Connections {
			var connections31 tfTypes.InputModelDrivenTelemetryConnection
			connections31.Output = types.StringValue(connectionsItem31.Output)
			connections31.Pipeline = types.StringPointerValue(connectionsItem31.Pipeline)
			if connectionsCount31+1 > len(r.InputModelDrivenTelemetry.Connections) {
				r.InputModelDrivenTelemetry.Connections = append(r.InputModelDrivenTelemetry.Connections, connections31)
			} else {
				r.InputModelDrivenTelemetry.Connections[connectionsCount31].Output = connections31.Output
				r.InputModelDrivenTelemetry.Connections[connectionsCount31].Pipeline = connections31.Pipeline
			}
		}
		r.InputModelDrivenTelemetry.Description = types.StringPointerValue(resp.InputModelDrivenTelemetry.Description)
		r.InputModelDrivenTelemetry.Disabled = types.BoolPointerValue(resp.InputModelDrivenTelemetry.Disabled)
		r.InputModelDrivenTelemetry.Environment = types.StringPointerValue(resp.InputModelDrivenTelemetry.Environment)
		r.InputModelDrivenTelemetry.Host = types.StringPointerValue(resp.InputModelDrivenTelemetry.Host)
		r.InputModelDrivenTelemetry.ID = types.StringPointerValue(resp.InputModelDrivenTelemetry.ID)
		r.InputModelDrivenTelemetry.MaxActiveCxn = types.Float64PointerValue(resp.InputModelDrivenTelemetry.MaxActiveCxn)
		r.InputModelDrivenTelemetry.Metadata = []tfTypes.InputModelDrivenTelemetryMetadatum{}
		if len(r.InputModelDrivenTelemetry.Metadata) > len(resp.InputModelDrivenTelemetry.Metadata) {
			r.InputModelDrivenTelemetry.Metadata = r.InputModelDrivenTelemetry.Metadata[:len(resp.InputModelDrivenTelemetry.Metadata)]
		}
		for metadataCount33, metadataItem33 := range resp.InputModelDrivenTelemetry.Metadata {
			var metadata33 tfTypes.InputModelDrivenTelemetryMetadatum
			metadata33.Name = types.StringValue(metadataItem33.Name)
			metadata33.Value = types.StringValue(metadataItem33.Value)
			if metadataCount33+1 > len(r.InputModelDrivenTelemetry.Metadata) {
				r.InputModelDrivenTelemetry.Metadata = append(r.InputModelDrivenTelemetry.Metadata, metadata33)
			} else {
				r.InputModelDrivenTelemetry.Metadata[metadataCount33].Name = metadata33.Name
				r.InputModelDrivenTelemetry.Metadata[metadataCount33].Value = metadata33.Value
			}
		}
		r.InputModelDrivenTelemetry.Pipeline = types.StringPointerValue(resp.InputModelDrivenTelemetry.Pipeline)
		r.InputModelDrivenTelemetry.Port = types.Float64PointerValue(resp.InputModelDrivenTelemetry.Port)
		if resp.InputModelDrivenTelemetry.Pq == nil {
			r.InputModelDrivenTelemetry.Pq = nil
		} else {
			r.InputModelDrivenTelemetry.Pq = &tfTypes.InputModelDrivenTelemetryPq{}
			r.InputModelDrivenTelemetry.Pq.CommitFrequency = types.Float64PointerValue(resp.InputModelDrivenTelemetry.Pq.CommitFrequency)
			if resp.InputModelDrivenTelemetry.Pq.Compress != nil {
				r.InputModelDrivenTelemetry.Pq.Compress = types.StringValue(string(*resp.InputModelDrivenTelemetry.Pq.Compress))
			} else {
				r.InputModelDrivenTelemetry.Pq.Compress = types.StringNull()
			}
			r.InputModelDrivenTelemetry.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputModelDrivenTelemetry.Pq.MaxBufferSize)
			r.InputModelDrivenTelemetry.Pq.MaxFileSize = types.StringPointerValue(resp.InputModelDrivenTelemetry.Pq.MaxFileSize)
			r.InputModelDrivenTelemetry.Pq.MaxSize = types.StringPointerValue(resp.InputModelDrivenTelemetry.Pq.MaxSize)
			if resp.InputModelDrivenTelemetry.Pq.Mode != nil {
				r.InputModelDrivenTelemetry.Pq.Mode = types.StringValue(string(*resp.InputModelDrivenTelemetry.Pq.Mode))
			} else {
				r.InputModelDrivenTelemetry.Pq.Mode = types.StringNull()
			}
			r.InputModelDrivenTelemetry.Pq.Path = types.StringPointerValue(resp.InputModelDrivenTelemetry.Pq.Path)
		}
		r.InputModelDrivenTelemetry.PqEnabled = types.BoolPointerValue(resp.InputModelDrivenTelemetry.PqEnabled)
		r.InputModelDrivenTelemetry.SendToRoutes = types.BoolPointerValue(resp.InputModelDrivenTelemetry.SendToRoutes)
		r.InputModelDrivenTelemetry.ShutdownTimeoutMs = types.Float64PointerValue(resp.InputModelDrivenTelemetry.ShutdownTimeoutMs)
		r.InputModelDrivenTelemetry.Streamtags = make([]types.String, 0, len(resp.InputModelDrivenTelemetry.Streamtags))
		for _, v := range resp.InputModelDrivenTelemetry.Streamtags {
			r.InputModelDrivenTelemetry.Streamtags = append(r.InputModelDrivenTelemetry.Streamtags, types.StringValue(v))
		}
		if resp.InputModelDrivenTelemetry.TLS == nil {
			r.InputModelDrivenTelemetry.TLS = nil
		} else {
			r.InputModelDrivenTelemetry.TLS = &tfTypes.InputModelDrivenTelemetryTLSSettingsServerSide{}
			r.InputModelDrivenTelemetry.TLS.CaPath = types.StringPointerValue(resp.InputModelDrivenTelemetry.TLS.CaPath)
			r.InputModelDrivenTelemetry.TLS.CertificateName = types.StringPointerValue(resp.InputModelDrivenTelemetry.TLS.CertificateName)
			r.InputModelDrivenTelemetry.TLS.CertPath = types.StringPointerValue(resp.InputModelDrivenTelemetry.TLS.CertPath)
			if resp.InputModelDrivenTelemetry.TLS.CommonNameRegex == nil {
				r.InputModelDrivenTelemetry.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult13, _ := json.Marshal(resp.InputModelDrivenTelemetry.TLS.CommonNameRegex)
				r.InputModelDrivenTelemetry.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult13))
			}
			r.InputModelDrivenTelemetry.TLS.Disabled = types.BoolPointerValue(resp.InputModelDrivenTelemetry.TLS.Disabled)
			if resp.InputModelDrivenTelemetry.TLS.MaxVersion != nil {
				r.InputModelDrivenTelemetry.TLS.MaxVersion = types.StringValue(string(*resp.InputModelDrivenTelemetry.TLS.MaxVersion))
			} else {
				r.InputModelDrivenTelemetry.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputModelDrivenTelemetry.TLS.MinVersion != nil {
				r.InputModelDrivenTelemetry.TLS.MinVersion = types.StringValue(string(*resp.InputModelDrivenTelemetry.TLS.MinVersion))
			} else {
				r.InputModelDrivenTelemetry.TLS.MinVersion = types.StringNull()
			}
			r.InputModelDrivenTelemetry.TLS.PrivKeyPath = types.StringPointerValue(resp.InputModelDrivenTelemetry.TLS.PrivKeyPath)
			if resp.InputModelDrivenTelemetry.TLS.RejectUnauthorized == nil {
				r.InputModelDrivenTelemetry.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult13, _ := json.Marshal(resp.InputModelDrivenTelemetry.TLS.RejectUnauthorized)
				r.InputModelDrivenTelemetry.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult13))
			}
			r.InputModelDrivenTelemetry.TLS.RequestCert = types.BoolPointerValue(resp.InputModelDrivenTelemetry.TLS.RequestCert)
		}
		if resp.InputModelDrivenTelemetry.Type != nil {
			r.InputModelDrivenTelemetry.Type = types.StringValue(string(*resp.InputModelDrivenTelemetry.Type))
		} else {
			r.InputModelDrivenTelemetry.Type = types.StringNull()
		}
	}
	if resp.InputMsk != nil {
		r.InputMsk = &tfTypes.InputMsk{}
		r.InputMsk.AssumeRoleArn = types.StringPointerValue(resp.InputMsk.AssumeRoleArn)
		r.InputMsk.AssumeRoleExternalID = types.StringPointerValue(resp.InputMsk.AssumeRoleExternalID)
		r.InputMsk.AuthenticationTimeout = types.Float64PointerValue(resp.InputMsk.AuthenticationTimeout)
		r.InputMsk.AutoCommitInterval = types.Float64PointerValue(resp.InputMsk.AutoCommitInterval)
		r.InputMsk.AutoCommitThreshold = types.Float64PointerValue(resp.InputMsk.AutoCommitThreshold)
		r.InputMsk.AwsAPIKey = types.StringPointerValue(resp.InputMsk.AwsAPIKey)
		if resp.InputMsk.AwsAuthenticationMethod != nil {
			r.InputMsk.AwsAuthenticationMethod = types.StringValue(string(*resp.InputMsk.AwsAuthenticationMethod))
		} else {
			r.InputMsk.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputMsk.AwsSecret = types.StringPointerValue(resp.InputMsk.AwsSecret)
		r.InputMsk.AwsSecretKey = types.StringPointerValue(resp.InputMsk.AwsSecretKey)
		r.InputMsk.BackoffRate = types.Float64PointerValue(resp.InputMsk.BackoffRate)
		r.InputMsk.Brokers = make([]types.String, 0, len(resp.InputMsk.Brokers))
		for _, v := range resp.InputMsk.Brokers {
			r.InputMsk.Brokers = append(r.InputMsk.Brokers, types.StringValue(v))
		}
		r.InputMsk.Connections = []tfTypes.InputMskConnection{}
		if len(r.InputMsk.Connections) > len(resp.InputMsk.Connections) {
			r.InputMsk.Connections = r.InputMsk.Connections[:len(resp.InputMsk.Connections)]
		}
		for connectionsCount32, connectionsItem32 := range resp.InputMsk.Connections {
			var connections32 tfTypes.InputMskConnection
			connections32.Output = types.StringValue(connectionsItem32.Output)
			connections32.Pipeline = types.StringPointerValue(connectionsItem32.Pipeline)
			if connectionsCount32+1 > len(r.InputMsk.Connections) {
				r.InputMsk.Connections = append(r.InputMsk.Connections, connections32)
			} else {
				r.InputMsk.Connections[connectionsCount32].Output = connections32.Output
				r.InputMsk.Connections[connectionsCount32].Pipeline = connections32.Pipeline
			}
		}
		r.InputMsk.ConnectionTimeout = types.Float64PointerValue(resp.InputMsk.ConnectionTimeout)
		r.InputMsk.Description = types.StringPointerValue(resp.InputMsk.Description)
		r.InputMsk.Disabled = types.BoolPointerValue(resp.InputMsk.Disabled)
		r.InputMsk.DurationSeconds = types.Float64PointerValue(resp.InputMsk.DurationSeconds)
		r.InputMsk.EnableAssumeRole = types.BoolPointerValue(resp.InputMsk.EnableAssumeRole)
		r.InputMsk.Endpoint = types.StringPointerValue(resp.InputMsk.Endpoint)
		r.InputMsk.Environment = types.StringPointerValue(resp.InputMsk.Environment)
		r.InputMsk.FromBeginning = types.BoolPointerValue(resp.InputMsk.FromBeginning)
		r.InputMsk.GroupID = types.StringPointerValue(resp.InputMsk.GroupID)
		r.InputMsk.HeartbeatInterval = types.Float64PointerValue(resp.InputMsk.HeartbeatInterval)
		r.InputMsk.ID = types.StringPointerValue(resp.InputMsk.ID)
		r.InputMsk.InitialBackoff = types.Float64PointerValue(resp.InputMsk.InitialBackoff)
		if resp.InputMsk.KafkaSchemaRegistry == nil {
			r.InputMsk.KafkaSchemaRegistry = nil
		} else {
			r.InputMsk.KafkaSchemaRegistry = &tfTypes.InputMskKafkaSchemaRegistryAuthentication{}
			if resp.InputMsk.KafkaSchemaRegistry.Auth == nil {
				r.InputMsk.KafkaSchemaRegistry.Auth = nil
			} else {
				r.InputMsk.KafkaSchemaRegistry.Auth = &tfTypes.InputMskAuth{}
				r.InputMsk.KafkaSchemaRegistry.Auth.CredentialsSecret = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.Auth.CredentialsSecret)
				r.InputMsk.KafkaSchemaRegistry.Auth.Disabled = types.BoolPointerValue(resp.InputMsk.KafkaSchemaRegistry.Auth.Disabled)
			}
			r.InputMsk.KafkaSchemaRegistry.ConnectionTimeout = types.Float64PointerValue(resp.InputMsk.KafkaSchemaRegistry.ConnectionTimeout)
			r.InputMsk.KafkaSchemaRegistry.Disabled = types.BoolPointerValue(resp.InputMsk.KafkaSchemaRegistry.Disabled)
			r.InputMsk.KafkaSchemaRegistry.MaxRetries = types.Float64PointerValue(resp.InputMsk.KafkaSchemaRegistry.MaxRetries)
			r.InputMsk.KafkaSchemaRegistry.RequestTimeout = types.Float64PointerValue(resp.InputMsk.KafkaSchemaRegistry.RequestTimeout)
			r.InputMsk.KafkaSchemaRegistry.SchemaRegistryURL = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.SchemaRegistryURL)
			if resp.InputMsk.KafkaSchemaRegistry.TLS == nil {
				r.InputMsk.KafkaSchemaRegistry.TLS = nil
			} else {
				r.InputMsk.KafkaSchemaRegistry.TLS = &tfTypes.InputMskKafkaSchemaRegistryTLSSettingsClientSide{}
				r.InputMsk.KafkaSchemaRegistry.TLS.CaPath = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.CaPath)
				r.InputMsk.KafkaSchemaRegistry.TLS.CertificateName = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.CertificateName)
				r.InputMsk.KafkaSchemaRegistry.TLS.CertPath = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.CertPath)
				r.InputMsk.KafkaSchemaRegistry.TLS.Disabled = types.BoolPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.Disabled)
				if resp.InputMsk.KafkaSchemaRegistry.TLS.MaxVersion != nil {
					r.InputMsk.KafkaSchemaRegistry.TLS.MaxVersion = types.StringValue(string(*resp.InputMsk.KafkaSchemaRegistry.TLS.MaxVersion))
				} else {
					r.InputMsk.KafkaSchemaRegistry.TLS.MaxVersion = types.StringNull()
				}
				if resp.InputMsk.KafkaSchemaRegistry.TLS.MinVersion != nil {
					r.InputMsk.KafkaSchemaRegistry.TLS.MinVersion = types.StringValue(string(*resp.InputMsk.KafkaSchemaRegistry.TLS.MinVersion))
				} else {
					r.InputMsk.KafkaSchemaRegistry.TLS.MinVersion = types.StringNull()
				}
				r.InputMsk.KafkaSchemaRegistry.TLS.Passphrase = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.Passphrase)
				r.InputMsk.KafkaSchemaRegistry.TLS.PrivKeyPath = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.PrivKeyPath)
				r.InputMsk.KafkaSchemaRegistry.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.RejectUnauthorized)
				r.InputMsk.KafkaSchemaRegistry.TLS.Servername = types.StringPointerValue(resp.InputMsk.KafkaSchemaRegistry.TLS.Servername)
			}
		}
		r.InputMsk.MaxBackOff = types.Float64PointerValue(resp.InputMsk.MaxBackOff)
		r.InputMsk.MaxBytes = types.Float64PointerValue(resp.InputMsk.MaxBytes)
		r.InputMsk.MaxBytesPerPartition = types.Float64PointerValue(resp.InputMsk.MaxBytesPerPartition)
		r.InputMsk.MaxRetries = types.Float64PointerValue(resp.InputMsk.MaxRetries)
		r.InputMsk.MaxSocketErrors = types.Float64PointerValue(resp.InputMsk.MaxSocketErrors)
		r.InputMsk.Metadata = []tfTypes.InputMskMetadatum{}
		if len(r.InputMsk.Metadata) > len(resp.InputMsk.Metadata) {
			r.InputMsk.Metadata = r.InputMsk.Metadata[:len(resp.InputMsk.Metadata)]
		}
		for metadataCount34, metadataItem34 := range resp.InputMsk.Metadata {
			var metadata34 tfTypes.InputMskMetadatum
			metadata34.Name = types.StringValue(metadataItem34.Name)
			metadata34.Value = types.StringValue(metadataItem34.Value)
			if metadataCount34+1 > len(r.InputMsk.Metadata) {
				r.InputMsk.Metadata = append(r.InputMsk.Metadata, metadata34)
			} else {
				r.InputMsk.Metadata[metadataCount34].Name = metadata34.Name
				r.InputMsk.Metadata[metadataCount34].Value = metadata34.Value
			}
		}
		r.InputMsk.Pipeline = types.StringPointerValue(resp.InputMsk.Pipeline)
		if resp.InputMsk.Pq == nil {
			r.InputMsk.Pq = nil
		} else {
			r.InputMsk.Pq = &tfTypes.InputMskPq{}
			r.InputMsk.Pq.CommitFrequency = types.Float64PointerValue(resp.InputMsk.Pq.CommitFrequency)
			if resp.InputMsk.Pq.Compress != nil {
				r.InputMsk.Pq.Compress = types.StringValue(string(*resp.InputMsk.Pq.Compress))
			} else {
				r.InputMsk.Pq.Compress = types.StringNull()
			}
			r.InputMsk.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputMsk.Pq.MaxBufferSize)
			r.InputMsk.Pq.MaxFileSize = types.StringPointerValue(resp.InputMsk.Pq.MaxFileSize)
			r.InputMsk.Pq.MaxSize = types.StringPointerValue(resp.InputMsk.Pq.MaxSize)
			if resp.InputMsk.Pq.Mode != nil {
				r.InputMsk.Pq.Mode = types.StringValue(string(*resp.InputMsk.Pq.Mode))
			} else {
				r.InputMsk.Pq.Mode = types.StringNull()
			}
			r.InputMsk.Pq.Path = types.StringPointerValue(resp.InputMsk.Pq.Path)
		}
		r.InputMsk.PqEnabled = types.BoolPointerValue(resp.InputMsk.PqEnabled)
		r.InputMsk.ReauthenticationThreshold = types.Float64PointerValue(resp.InputMsk.ReauthenticationThreshold)
		r.InputMsk.RebalanceTimeout = types.Float64PointerValue(resp.InputMsk.RebalanceTimeout)
		r.InputMsk.Region = types.StringValue(resp.InputMsk.Region)
		r.InputMsk.RejectUnauthorized = types.BoolPointerValue(resp.InputMsk.RejectUnauthorized)
		r.InputMsk.RequestTimeout = types.Float64PointerValue(resp.InputMsk.RequestTimeout)
		r.InputMsk.ReuseConnections = types.BoolPointerValue(resp.InputMsk.ReuseConnections)
		r.InputMsk.SendToRoutes = types.BoolPointerValue(resp.InputMsk.SendToRoutes)
		r.InputMsk.SessionTimeout = types.Float64PointerValue(resp.InputMsk.SessionTimeout)
		if resp.InputMsk.SignatureVersion != nil {
			r.InputMsk.SignatureVersion = types.StringValue(string(*resp.InputMsk.SignatureVersion))
		} else {
			r.InputMsk.SignatureVersion = types.StringNull()
		}
		r.InputMsk.Streamtags = make([]types.String, 0, len(resp.InputMsk.Streamtags))
		for _, v := range resp.InputMsk.Streamtags {
			r.InputMsk.Streamtags = append(r.InputMsk.Streamtags, types.StringValue(v))
		}
		if resp.InputMsk.TLS == nil {
			r.InputMsk.TLS = nil
		} else {
			r.InputMsk.TLS = &tfTypes.InputMskTLSSettingsClientSide{}
			r.InputMsk.TLS.CaPath = types.StringPointerValue(resp.InputMsk.TLS.CaPath)
			r.InputMsk.TLS.CertificateName = types.StringPointerValue(resp.InputMsk.TLS.CertificateName)
			r.InputMsk.TLS.CertPath = types.StringPointerValue(resp.InputMsk.TLS.CertPath)
			r.InputMsk.TLS.Disabled = types.BoolPointerValue(resp.InputMsk.TLS.Disabled)
			if resp.InputMsk.TLS.MaxVersion != nil {
				r.InputMsk.TLS.MaxVersion = types.StringValue(string(*resp.InputMsk.TLS.MaxVersion))
			} else {
				r.InputMsk.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputMsk.TLS.MinVersion != nil {
				r.InputMsk.TLS.MinVersion = types.StringValue(string(*resp.InputMsk.TLS.MinVersion))
			} else {
				r.InputMsk.TLS.MinVersion = types.StringNull()
			}
			r.InputMsk.TLS.Passphrase = types.StringPointerValue(resp.InputMsk.TLS.Passphrase)
			r.InputMsk.TLS.PrivKeyPath = types.StringPointerValue(resp.InputMsk.TLS.PrivKeyPath)
			r.InputMsk.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputMsk.TLS.RejectUnauthorized)
			r.InputMsk.TLS.Servername = types.StringPointerValue(resp.InputMsk.TLS.Servername)
		}
		r.InputMsk.Topics = make([]types.String, 0, len(resp.InputMsk.Topics))
		for _, v := range resp.InputMsk.Topics {
			r.InputMsk.Topics = append(r.InputMsk.Topics, types.StringValue(v))
		}
		if resp.InputMsk.Type != nil {
			r.InputMsk.Type = types.StringValue(string(*resp.InputMsk.Type))
		} else {
			r.InputMsk.Type = types.StringNull()
		}
	}
	if resp.InputNetflow != nil {
		r.InputNetflow = &tfTypes.InputNetflow{}
		r.InputNetflow.Connections = []tfTypes.InputNetflowConnection{}
		if len(r.InputNetflow.Connections) > len(resp.InputNetflow.Connections) {
			r.InputNetflow.Connections = r.InputNetflow.Connections[:len(resp.InputNetflow.Connections)]
		}
		for connectionsCount33, connectionsItem33 := range resp.InputNetflow.Connections {
			var connections33 tfTypes.InputNetflowConnection
			connections33.Output = types.StringValue(connectionsItem33.Output)
			connections33.Pipeline = types.StringPointerValue(connectionsItem33.Pipeline)
			if connectionsCount33+1 > len(r.InputNetflow.Connections) {
				r.InputNetflow.Connections = append(r.InputNetflow.Connections, connections33)
			} else {
				r.InputNetflow.Connections[connectionsCount33].Output = connections33.Output
				r.InputNetflow.Connections[connectionsCount33].Pipeline = connections33.Pipeline
			}
		}
		r.InputNetflow.Description = types.StringPointerValue(resp.InputNetflow.Description)
		r.InputNetflow.Disabled = types.BoolPointerValue(resp.InputNetflow.Disabled)
		r.InputNetflow.EnablePassThrough = types.BoolPointerValue(resp.InputNetflow.EnablePassThrough)
		r.InputNetflow.Environment = types.StringPointerValue(resp.InputNetflow.Environment)
		r.InputNetflow.Host = types.StringPointerValue(resp.InputNetflow.Host)
		r.InputNetflow.ID = types.StringPointerValue(resp.InputNetflow.ID)
		r.InputNetflow.IPAllowlistRegex = types.StringPointerValue(resp.InputNetflow.IPAllowlistRegex)
		r.InputNetflow.IPDenylistRegex = types.StringPointerValue(resp.InputNetflow.IPDenylistRegex)
		r.InputNetflow.IpfixEnabled = types.BoolPointerValue(resp.InputNetflow.IpfixEnabled)
		r.InputNetflow.Metadata = []tfTypes.InputNetflowMetadatum{}
		if len(r.InputNetflow.Metadata) > len(resp.InputNetflow.Metadata) {
			r.InputNetflow.Metadata = r.InputNetflow.Metadata[:len(resp.InputNetflow.Metadata)]
		}
		for metadataCount35, metadataItem35 := range resp.InputNetflow.Metadata {
			var metadata35 tfTypes.InputNetflowMetadatum
			metadata35.Name = types.StringValue(metadataItem35.Name)
			metadata35.Value = types.StringValue(metadataItem35.Value)
			if metadataCount35+1 > len(r.InputNetflow.Metadata) {
				r.InputNetflow.Metadata = append(r.InputNetflow.Metadata, metadata35)
			} else {
				r.InputNetflow.Metadata[metadataCount35].Name = metadata35.Name
				r.InputNetflow.Metadata[metadataCount35].Value = metadata35.Value
			}
		}
		r.InputNetflow.Pipeline = types.StringPointerValue(resp.InputNetflow.Pipeline)
		r.InputNetflow.Port = types.Float64PointerValue(resp.InputNetflow.Port)
		if resp.InputNetflow.Pq == nil {
			r.InputNetflow.Pq = nil
		} else {
			r.InputNetflow.Pq = &tfTypes.InputNetflowPq{}
			r.InputNetflow.Pq.CommitFrequency = types.Float64PointerValue(resp.InputNetflow.Pq.CommitFrequency)
			if resp.InputNetflow.Pq.Compress != nil {
				r.InputNetflow.Pq.Compress = types.StringValue(string(*resp.InputNetflow.Pq.Compress))
			} else {
				r.InputNetflow.Pq.Compress = types.StringNull()
			}
			r.InputNetflow.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputNetflow.Pq.MaxBufferSize)
			r.InputNetflow.Pq.MaxFileSize = types.StringPointerValue(resp.InputNetflow.Pq.MaxFileSize)
			r.InputNetflow.Pq.MaxSize = types.StringPointerValue(resp.InputNetflow.Pq.MaxSize)
			if resp.InputNetflow.Pq.Mode != nil {
				r.InputNetflow.Pq.Mode = types.StringValue(string(*resp.InputNetflow.Pq.Mode))
			} else {
				r.InputNetflow.Pq.Mode = types.StringNull()
			}
			r.InputNetflow.Pq.Path = types.StringPointerValue(resp.InputNetflow.Pq.Path)
		}
		r.InputNetflow.PqEnabled = types.BoolPointerValue(resp.InputNetflow.PqEnabled)
		r.InputNetflow.SendToRoutes = types.BoolPointerValue(resp.InputNetflow.SendToRoutes)
		r.InputNetflow.Streamtags = make([]types.String, 0, len(resp.InputNetflow.Streamtags))
		for _, v := range resp.InputNetflow.Streamtags {
			r.InputNetflow.Streamtags = append(r.InputNetflow.Streamtags, types.StringValue(v))
		}
		r.InputNetflow.TemplateCacheMinutes = types.Float64PointerValue(resp.InputNetflow.TemplateCacheMinutes)
		if resp.InputNetflow.Type != nil {
			r.InputNetflow.Type = types.StringValue(string(*resp.InputNetflow.Type))
		} else {
			r.InputNetflow.Type = types.StringNull()
		}
		r.InputNetflow.UDPSocketRxBufSize = types.Float64PointerValue(resp.InputNetflow.UDPSocketRxBufSize)
		r.InputNetflow.V5Enabled = types.BoolPointerValue(resp.InputNetflow.V5Enabled)
		r.InputNetflow.V9Enabled = types.BoolPointerValue(resp.InputNetflow.V9Enabled)
	}
	if resp.InputOffice365Mgmt != nil {
		r.InputOffice365Mgmt = &tfTypes.InputOffice365Mgmt{}
		r.InputOffice365Mgmt.AppID = types.StringValue(resp.InputOffice365Mgmt.AppID)
		if resp.InputOffice365Mgmt.AuthType != nil {
			r.InputOffice365Mgmt.AuthType = types.StringValue(string(*resp.InputOffice365Mgmt.AuthType))
		} else {
			r.InputOffice365Mgmt.AuthType = types.StringNull()
		}
		r.InputOffice365Mgmt.ClientSecret = types.StringPointerValue(resp.InputOffice365Mgmt.ClientSecret)
		r.InputOffice365Mgmt.Connections = []tfTypes.InputOffice365MgmtConnection{}
		if len(r.InputOffice365Mgmt.Connections) > len(resp.InputOffice365Mgmt.Connections) {
			r.InputOffice365Mgmt.Connections = r.InputOffice365Mgmt.Connections[:len(resp.InputOffice365Mgmt.Connections)]
		}
		for connectionsCount34, connectionsItem34 := range resp.InputOffice365Mgmt.Connections {
			var connections34 tfTypes.InputOffice365MgmtConnection
			connections34.Output = types.StringValue(connectionsItem34.Output)
			connections34.Pipeline = types.StringPointerValue(connectionsItem34.Pipeline)
			if connectionsCount34+1 > len(r.InputOffice365Mgmt.Connections) {
				r.InputOffice365Mgmt.Connections = append(r.InputOffice365Mgmt.Connections, connections34)
			} else {
				r.InputOffice365Mgmt.Connections[connectionsCount34].Output = connections34.Output
				r.InputOffice365Mgmt.Connections[connectionsCount34].Pipeline = connections34.Pipeline
			}
		}
		r.InputOffice365Mgmt.ContentConfig = []tfTypes.InputOffice365MgmtContentConfig{}
		if len(r.InputOffice365Mgmt.ContentConfig) > len(resp.InputOffice365Mgmt.ContentConfig) {
			r.InputOffice365Mgmt.ContentConfig = r.InputOffice365Mgmt.ContentConfig[:len(resp.InputOffice365Mgmt.ContentConfig)]
		}
		for contentConfigCount, contentConfigItem := range resp.InputOffice365Mgmt.ContentConfig {
			var contentConfig tfTypes.InputOffice365MgmtContentConfig
			contentConfig.ContentType = types.StringPointerValue(contentConfigItem.ContentType)
			contentConfig.Description = types.StringPointerValue(contentConfigItem.Description)
			contentConfig.Enabled = types.BoolPointerValue(contentConfigItem.Enabled)
			contentConfig.Interval = types.Float64PointerValue(contentConfigItem.Interval)
			if contentConfigItem.LogLevel != nil {
				contentConfig.LogLevel = types.StringValue(string(*contentConfigItem.LogLevel))
			} else {
				contentConfig.LogLevel = types.StringNull()
			}
			if contentConfigCount+1 > len(r.InputOffice365Mgmt.ContentConfig) {
				r.InputOffice365Mgmt.ContentConfig = append(r.InputOffice365Mgmt.ContentConfig, contentConfig)
			} else {
				r.InputOffice365Mgmt.ContentConfig[contentConfigCount].ContentType = contentConfig.ContentType
				r.InputOffice365Mgmt.ContentConfig[contentConfigCount].Description = contentConfig.Description
				r.InputOffice365Mgmt.ContentConfig[contentConfigCount].Enabled = contentConfig.Enabled
				r.InputOffice365Mgmt.ContentConfig[contentConfigCount].Interval = contentConfig.Interval
				r.InputOffice365Mgmt.ContentConfig[contentConfigCount].LogLevel = contentConfig.LogLevel
			}
		}
		r.InputOffice365Mgmt.Description = types.StringPointerValue(resp.InputOffice365Mgmt.Description)
		r.InputOffice365Mgmt.Disabled = types.BoolPointerValue(resp.InputOffice365Mgmt.Disabled)
		r.InputOffice365Mgmt.Environment = types.StringPointerValue(resp.InputOffice365Mgmt.Environment)
		r.InputOffice365Mgmt.ID = types.StringPointerValue(resp.InputOffice365Mgmt.ID)
		r.InputOffice365Mgmt.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.InputOffice365Mgmt.IgnoreGroupJobsLimit)
		r.InputOffice365Mgmt.IngestionLag = types.Float64PointerValue(resp.InputOffice365Mgmt.IngestionLag)
		r.InputOffice365Mgmt.JobTimeout = types.StringPointerValue(resp.InputOffice365Mgmt.JobTimeout)
		r.InputOffice365Mgmt.KeepAliveTime = types.Float64PointerValue(resp.InputOffice365Mgmt.KeepAliveTime)
		r.InputOffice365Mgmt.MaxMissedKeepAlives = types.Float64PointerValue(resp.InputOffice365Mgmt.MaxMissedKeepAlives)
		r.InputOffice365Mgmt.Metadata = []tfTypes.InputOffice365MgmtMetadatum{}
		if len(r.InputOffice365Mgmt.Metadata) > len(resp.InputOffice365Mgmt.Metadata) {
			r.InputOffice365Mgmt.Metadata = r.InputOffice365Mgmt.Metadata[:len(resp.InputOffice365Mgmt.Metadata)]
		}
		for metadataCount36, metadataItem36 := range resp.InputOffice365Mgmt.Metadata {
			var metadata36 tfTypes.InputOffice365MgmtMetadatum
			metadata36.Name = types.StringValue(metadataItem36.Name)
			metadata36.Value = types.StringValue(metadataItem36.Value)
			if metadataCount36+1 > len(r.InputOffice365Mgmt.Metadata) {
				r.InputOffice365Mgmt.Metadata = append(r.InputOffice365Mgmt.Metadata, metadata36)
			} else {
				r.InputOffice365Mgmt.Metadata[metadataCount36].Name = metadata36.Name
				r.InputOffice365Mgmt.Metadata[metadataCount36].Value = metadata36.Value
			}
		}
		r.InputOffice365Mgmt.Pipeline = types.StringPointerValue(resp.InputOffice365Mgmt.Pipeline)
		if resp.InputOffice365Mgmt.PlanType != nil {
			r.InputOffice365Mgmt.PlanType = types.StringValue(string(*resp.InputOffice365Mgmt.PlanType))
		} else {
			r.InputOffice365Mgmt.PlanType = types.StringNull()
		}
		if resp.InputOffice365Mgmt.Pq == nil {
			r.InputOffice365Mgmt.Pq = nil
		} else {
			r.InputOffice365Mgmt.Pq = &tfTypes.InputOffice365MgmtPq{}
			r.InputOffice365Mgmt.Pq.CommitFrequency = types.Float64PointerValue(resp.InputOffice365Mgmt.Pq.CommitFrequency)
			if resp.InputOffice365Mgmt.Pq.Compress != nil {
				r.InputOffice365Mgmt.Pq.Compress = types.StringValue(string(*resp.InputOffice365Mgmt.Pq.Compress))
			} else {
				r.InputOffice365Mgmt.Pq.Compress = types.StringNull()
			}
			r.InputOffice365Mgmt.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputOffice365Mgmt.Pq.MaxBufferSize)
			r.InputOffice365Mgmt.Pq.MaxFileSize = types.StringPointerValue(resp.InputOffice365Mgmt.Pq.MaxFileSize)
			r.InputOffice365Mgmt.Pq.MaxSize = types.StringPointerValue(resp.InputOffice365Mgmt.Pq.MaxSize)
			if resp.InputOffice365Mgmt.Pq.Mode != nil {
				r.InputOffice365Mgmt.Pq.Mode = types.StringValue(string(*resp.InputOffice365Mgmt.Pq.Mode))
			} else {
				r.InputOffice365Mgmt.Pq.Mode = types.StringNull()
			}
			r.InputOffice365Mgmt.Pq.Path = types.StringPointerValue(resp.InputOffice365Mgmt.Pq.Path)
		}
		r.InputOffice365Mgmt.PqEnabled = types.BoolPointerValue(resp.InputOffice365Mgmt.PqEnabled)
		r.InputOffice365Mgmt.PublisherIdentifier = types.StringPointerValue(resp.InputOffice365Mgmt.PublisherIdentifier)
		if resp.InputOffice365Mgmt.RetryRules == nil {
			r.InputOffice365Mgmt.RetryRules = nil
		} else {
			r.InputOffice365Mgmt.RetryRules = &tfTypes.InputOffice365MgmtRetryRules{}
			r.InputOffice365Mgmt.RetryRules.Codes = make([]types.Float64, 0, len(resp.InputOffice365Mgmt.RetryRules.Codes))
			for _, v := range resp.InputOffice365Mgmt.RetryRules.Codes {
				r.InputOffice365Mgmt.RetryRules.Codes = append(r.InputOffice365Mgmt.RetryRules.Codes, types.Float64Value(v))
			}
			r.InputOffice365Mgmt.RetryRules.EnableHeader = types.BoolPointerValue(resp.InputOffice365Mgmt.RetryRules.EnableHeader)
			r.InputOffice365Mgmt.RetryRules.Interval = types.Float64PointerValue(resp.InputOffice365Mgmt.RetryRules.Interval)
			r.InputOffice365Mgmt.RetryRules.Limit = types.Float64PointerValue(resp.InputOffice365Mgmt.RetryRules.Limit)
			r.InputOffice365Mgmt.RetryRules.Multiplier = types.Float64PointerValue(resp.InputOffice365Mgmt.RetryRules.Multiplier)
			r.InputOffice365Mgmt.RetryRules.RetryConnectReset = types.BoolPointerValue(resp.InputOffice365Mgmt.RetryRules.RetryConnectReset)
			r.InputOffice365Mgmt.RetryRules.RetryConnectTimeout = types.BoolPointerValue(resp.InputOffice365Mgmt.RetryRules.RetryConnectTimeout)
			if resp.InputOffice365Mgmt.RetryRules.Type != nil {
				r.InputOffice365Mgmt.RetryRules.Type = types.StringValue(string(*resp.InputOffice365Mgmt.RetryRules.Type))
			} else {
				r.InputOffice365Mgmt.RetryRules.Type = types.StringNull()
			}
		}
		r.InputOffice365Mgmt.SendToRoutes = types.BoolPointerValue(resp.InputOffice365Mgmt.SendToRoutes)
		r.InputOffice365Mgmt.Streamtags = make([]types.String, 0, len(resp.InputOffice365Mgmt.Streamtags))
		for _, v := range resp.InputOffice365Mgmt.Streamtags {
			r.InputOffice365Mgmt.Streamtags = append(r.InputOffice365Mgmt.Streamtags, types.StringValue(v))
		}
		r.InputOffice365Mgmt.TenantID = types.StringValue(resp.InputOffice365Mgmt.TenantID)
		r.InputOffice365Mgmt.TextSecret = types.StringPointerValue(resp.InputOffice365Mgmt.TextSecret)
		r.InputOffice365Mgmt.Timeout = types.Float64PointerValue(resp.InputOffice365Mgmt.Timeout)
		r.InputOffice365Mgmt.TTL = types.StringPointerValue(resp.InputOffice365Mgmt.TTL)
		if resp.InputOffice365Mgmt.Type != nil {
			r.InputOffice365Mgmt.Type = types.StringValue(string(*resp.InputOffice365Mgmt.Type))
		} else {
			r.InputOffice365Mgmt.Type = types.StringNull()
		}
	}
	if resp.InputOffice365MsgTrace != nil {
		r.InputOffice365MsgTrace = &tfTypes.InputOffice365MsgTrace{}
		if resp.InputOffice365MsgTrace.AuthType != nil {
			r.InputOffice365MsgTrace.AuthType = types.StringValue(string(*resp.InputOffice365MsgTrace.AuthType))
		} else {
			r.InputOffice365MsgTrace.AuthType = types.StringNull()
		}
		if resp.InputOffice365MsgTrace.CertOptions == nil {
			r.InputOffice365MsgTrace.CertOptions = nil
		} else {
			r.InputOffice365MsgTrace.CertOptions = &tfTypes.CertOptions{}
			r.InputOffice365MsgTrace.CertOptions.CertificateName = types.StringPointerValue(resp.InputOffice365MsgTrace.CertOptions.CertificateName)
			r.InputOffice365MsgTrace.CertOptions.CertPath = types.StringValue(resp.InputOffice365MsgTrace.CertOptions.CertPath)
			r.InputOffice365MsgTrace.CertOptions.Passphrase = types.StringPointerValue(resp.InputOffice365MsgTrace.CertOptions.Passphrase)
			r.InputOffice365MsgTrace.CertOptions.PrivKeyPath = types.StringValue(resp.InputOffice365MsgTrace.CertOptions.PrivKeyPath)
		}
		r.InputOffice365MsgTrace.ClientID = types.StringPointerValue(resp.InputOffice365MsgTrace.ClientID)
		r.InputOffice365MsgTrace.ClientSecret = types.StringPointerValue(resp.InputOffice365MsgTrace.ClientSecret)
		r.InputOffice365MsgTrace.Connections = []tfTypes.InputOffice365MsgTraceConnection{}
		if len(r.InputOffice365MsgTrace.Connections) > len(resp.InputOffice365MsgTrace.Connections) {
			r.InputOffice365MsgTrace.Connections = r.InputOffice365MsgTrace.Connections[:len(resp.InputOffice365MsgTrace.Connections)]
		}
		for connectionsCount35, connectionsItem35 := range resp.InputOffice365MsgTrace.Connections {
			var connections35 tfTypes.InputOffice365MsgTraceConnection
			connections35.Output = types.StringValue(connectionsItem35.Output)
			connections35.Pipeline = types.StringPointerValue(connectionsItem35.Pipeline)
			if connectionsCount35+1 > len(r.InputOffice365MsgTrace.Connections) {
				r.InputOffice365MsgTrace.Connections = append(r.InputOffice365MsgTrace.Connections, connections35)
			} else {
				r.InputOffice365MsgTrace.Connections[connectionsCount35].Output = connections35.Output
				r.InputOffice365MsgTrace.Connections[connectionsCount35].Pipeline = connections35.Pipeline
			}
		}
		r.InputOffice365MsgTrace.CredentialsSecret = types.StringPointerValue(resp.InputOffice365MsgTrace.CredentialsSecret)
		r.InputOffice365MsgTrace.Description = types.StringPointerValue(resp.InputOffice365MsgTrace.Description)
		r.InputOffice365MsgTrace.Disabled = types.BoolPointerValue(resp.InputOffice365MsgTrace.Disabled)
		r.InputOffice365MsgTrace.DisableTimeFilter = types.BoolPointerValue(resp.InputOffice365MsgTrace.DisableTimeFilter)
		r.InputOffice365MsgTrace.EndDate = types.StringPointerValue(resp.InputOffice365MsgTrace.EndDate)
		r.InputOffice365MsgTrace.Environment = types.StringPointerValue(resp.InputOffice365MsgTrace.Environment)
		r.InputOffice365MsgTrace.ID = types.StringPointerValue(resp.InputOffice365MsgTrace.ID)
		r.InputOffice365MsgTrace.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.InputOffice365MsgTrace.IgnoreGroupJobsLimit)
		r.InputOffice365MsgTrace.Interval = types.Float64PointerValue(resp.InputOffice365MsgTrace.Interval)
		r.InputOffice365MsgTrace.JobTimeout = types.StringPointerValue(resp.InputOffice365MsgTrace.JobTimeout)
		r.InputOffice365MsgTrace.KeepAliveTime = types.Float64PointerValue(resp.InputOffice365MsgTrace.KeepAliveTime)
		if resp.InputOffice365MsgTrace.LogLevel != nil {
			r.InputOffice365MsgTrace.LogLevel = types.StringValue(string(*resp.InputOffice365MsgTrace.LogLevel))
		} else {
			r.InputOffice365MsgTrace.LogLevel = types.StringNull()
		}
		r.InputOffice365MsgTrace.MaxMissedKeepAlives = types.Float64PointerValue(resp.InputOffice365MsgTrace.MaxMissedKeepAlives)
		r.InputOffice365MsgTrace.MaxTaskReschedule = types.Float64PointerValue(resp.InputOffice365MsgTrace.MaxTaskReschedule)
		r.InputOffice365MsgTrace.Metadata = []tfTypes.InputOffice365MsgTraceMetadatum{}
		if len(r.InputOffice365MsgTrace.Metadata) > len(resp.InputOffice365MsgTrace.Metadata) {
			r.InputOffice365MsgTrace.Metadata = r.InputOffice365MsgTrace.Metadata[:len(resp.InputOffice365MsgTrace.Metadata)]
		}
		for metadataCount37, metadataItem37 := range resp.InputOffice365MsgTrace.Metadata {
			var metadata37 tfTypes.InputOffice365MsgTraceMetadatum
			metadata37.Name = types.StringValue(metadataItem37.Name)
			metadata37.Value = types.StringValue(metadataItem37.Value)
			if metadataCount37+1 > len(r.InputOffice365MsgTrace.Metadata) {
				r.InputOffice365MsgTrace.Metadata = append(r.InputOffice365MsgTrace.Metadata, metadata37)
			} else {
				r.InputOffice365MsgTrace.Metadata[metadataCount37].Name = metadata37.Name
				r.InputOffice365MsgTrace.Metadata[metadataCount37].Value = metadata37.Value
			}
		}
		r.InputOffice365MsgTrace.Password = types.StringPointerValue(resp.InputOffice365MsgTrace.Password)
		r.InputOffice365MsgTrace.Pipeline = types.StringPointerValue(resp.InputOffice365MsgTrace.Pipeline)
		if resp.InputOffice365MsgTrace.PlanType != nil {
			r.InputOffice365MsgTrace.PlanType = types.StringValue(string(*resp.InputOffice365MsgTrace.PlanType))
		} else {
			r.InputOffice365MsgTrace.PlanType = types.StringNull()
		}
		if resp.InputOffice365MsgTrace.Pq == nil {
			r.InputOffice365MsgTrace.Pq = nil
		} else {
			r.InputOffice365MsgTrace.Pq = &tfTypes.InputOffice365MsgTracePq{}
			r.InputOffice365MsgTrace.Pq.CommitFrequency = types.Float64PointerValue(resp.InputOffice365MsgTrace.Pq.CommitFrequency)
			if resp.InputOffice365MsgTrace.Pq.Compress != nil {
				r.InputOffice365MsgTrace.Pq.Compress = types.StringValue(string(*resp.InputOffice365MsgTrace.Pq.Compress))
			} else {
				r.InputOffice365MsgTrace.Pq.Compress = types.StringNull()
			}
			r.InputOffice365MsgTrace.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputOffice365MsgTrace.Pq.MaxBufferSize)
			r.InputOffice365MsgTrace.Pq.MaxFileSize = types.StringPointerValue(resp.InputOffice365MsgTrace.Pq.MaxFileSize)
			r.InputOffice365MsgTrace.Pq.MaxSize = types.StringPointerValue(resp.InputOffice365MsgTrace.Pq.MaxSize)
			if resp.InputOffice365MsgTrace.Pq.Mode != nil {
				r.InputOffice365MsgTrace.Pq.Mode = types.StringValue(string(*resp.InputOffice365MsgTrace.Pq.Mode))
			} else {
				r.InputOffice365MsgTrace.Pq.Mode = types.StringNull()
			}
			r.InputOffice365MsgTrace.Pq.Path = types.StringPointerValue(resp.InputOffice365MsgTrace.Pq.Path)
		}
		r.InputOffice365MsgTrace.PqEnabled = types.BoolPointerValue(resp.InputOffice365MsgTrace.PqEnabled)
		r.InputOffice365MsgTrace.RescheduleDroppedTasks = types.BoolPointerValue(resp.InputOffice365MsgTrace.RescheduleDroppedTasks)
		r.InputOffice365MsgTrace.Resource = types.StringPointerValue(resp.InputOffice365MsgTrace.Resource)
		if resp.InputOffice365MsgTrace.RetryRules == nil {
			r.InputOffice365MsgTrace.RetryRules = nil
		} else {
			r.InputOffice365MsgTrace.RetryRules = &tfTypes.InputOffice365MsgTraceRetryRules{}
			r.InputOffice365MsgTrace.RetryRules.Codes = make([]types.Float64, 0, len(resp.InputOffice365MsgTrace.RetryRules.Codes))
			for _, v := range resp.InputOffice365MsgTrace.RetryRules.Codes {
				r.InputOffice365MsgTrace.RetryRules.Codes = append(r.InputOffice365MsgTrace.RetryRules.Codes, types.Float64Value(v))
			}
			r.InputOffice365MsgTrace.RetryRules.EnableHeader = types.BoolPointerValue(resp.InputOffice365MsgTrace.RetryRules.EnableHeader)
			r.InputOffice365MsgTrace.RetryRules.Interval = types.Float64PointerValue(resp.InputOffice365MsgTrace.RetryRules.Interval)
			r.InputOffice365MsgTrace.RetryRules.Limit = types.Float64PointerValue(resp.InputOffice365MsgTrace.RetryRules.Limit)
			r.InputOffice365MsgTrace.RetryRules.Multiplier = types.Float64PointerValue(resp.InputOffice365MsgTrace.RetryRules.Multiplier)
			r.InputOffice365MsgTrace.RetryRules.RetryConnectReset = types.BoolPointerValue(resp.InputOffice365MsgTrace.RetryRules.RetryConnectReset)
			r.InputOffice365MsgTrace.RetryRules.RetryConnectTimeout = types.BoolPointerValue(resp.InputOffice365MsgTrace.RetryRules.RetryConnectTimeout)
			if resp.InputOffice365MsgTrace.RetryRules.Type != nil {
				r.InputOffice365MsgTrace.RetryRules.Type = types.StringValue(string(*resp.InputOffice365MsgTrace.RetryRules.Type))
			} else {
				r.InputOffice365MsgTrace.RetryRules.Type = types.StringNull()
			}
		}
		r.InputOffice365MsgTrace.SendToRoutes = types.BoolPointerValue(resp.InputOffice365MsgTrace.SendToRoutes)
		r.InputOffice365MsgTrace.StartDate = types.StringPointerValue(resp.InputOffice365MsgTrace.StartDate)
		r.InputOffice365MsgTrace.Streamtags = make([]types.String, 0, len(resp.InputOffice365MsgTrace.Streamtags))
		for _, v := range resp.InputOffice365MsgTrace.Streamtags {
			r.InputOffice365MsgTrace.Streamtags = append(r.InputOffice365MsgTrace.Streamtags, types.StringValue(v))
		}
		r.InputOffice365MsgTrace.TenantID = types.StringPointerValue(resp.InputOffice365MsgTrace.TenantID)
		r.InputOffice365MsgTrace.TextSecret = types.StringPointerValue(resp.InputOffice365MsgTrace.TextSecret)
		r.InputOffice365MsgTrace.Timeout = types.Float64PointerValue(resp.InputOffice365MsgTrace.Timeout)
		r.InputOffice365MsgTrace.TTL = types.StringPointerValue(resp.InputOffice365MsgTrace.TTL)
		if resp.InputOffice365MsgTrace.Type != nil {
			r.InputOffice365MsgTrace.Type = types.StringValue(string(*resp.InputOffice365MsgTrace.Type))
		} else {
			r.InputOffice365MsgTrace.Type = types.StringNull()
		}
		r.InputOffice365MsgTrace.URL = types.StringPointerValue(resp.InputOffice365MsgTrace.URL)
		r.InputOffice365MsgTrace.Username = types.StringPointerValue(resp.InputOffice365MsgTrace.Username)
	}
	if resp.InputOffice365Service != nil {
		r.InputOffice365Service = &tfTypes.InputOffice365Service{}
		r.InputOffice365Service.AppID = types.StringValue(resp.InputOffice365Service.AppID)
		if resp.InputOffice365Service.AuthType != nil {
			r.InputOffice365Service.AuthType = types.StringValue(string(*resp.InputOffice365Service.AuthType))
		} else {
			r.InputOffice365Service.AuthType = types.StringNull()
		}
		r.InputOffice365Service.ClientSecret = types.StringPointerValue(resp.InputOffice365Service.ClientSecret)
		r.InputOffice365Service.Connections = []tfTypes.InputOffice365ServiceConnection{}
		if len(r.InputOffice365Service.Connections) > len(resp.InputOffice365Service.Connections) {
			r.InputOffice365Service.Connections = r.InputOffice365Service.Connections[:len(resp.InputOffice365Service.Connections)]
		}
		for connectionsCount36, connectionsItem36 := range resp.InputOffice365Service.Connections {
			var connections36 tfTypes.InputOffice365ServiceConnection
			connections36.Output = types.StringValue(connectionsItem36.Output)
			connections36.Pipeline = types.StringPointerValue(connectionsItem36.Pipeline)
			if connectionsCount36+1 > len(r.InputOffice365Service.Connections) {
				r.InputOffice365Service.Connections = append(r.InputOffice365Service.Connections, connections36)
			} else {
				r.InputOffice365Service.Connections[connectionsCount36].Output = connections36.Output
				r.InputOffice365Service.Connections[connectionsCount36].Pipeline = connections36.Pipeline
			}
		}
		r.InputOffice365Service.ContentConfig = []tfTypes.InputOffice365ServiceContentConfig{}
		if len(r.InputOffice365Service.ContentConfig) > len(resp.InputOffice365Service.ContentConfig) {
			r.InputOffice365Service.ContentConfig = r.InputOffice365Service.ContentConfig[:len(resp.InputOffice365Service.ContentConfig)]
		}
		for contentConfigCount1, contentConfigItem1 := range resp.InputOffice365Service.ContentConfig {
			var contentConfig1 tfTypes.InputOffice365ServiceContentConfig
			contentConfig1.ContentType = types.StringPointerValue(contentConfigItem1.ContentType)
			contentConfig1.Description = types.StringPointerValue(contentConfigItem1.Description)
			contentConfig1.Enabled = types.BoolPointerValue(contentConfigItem1.Enabled)
			contentConfig1.Interval = types.Float64PointerValue(contentConfigItem1.Interval)
			if contentConfigItem1.LogLevel != nil {
				contentConfig1.LogLevel = types.StringValue(string(*contentConfigItem1.LogLevel))
			} else {
				contentConfig1.LogLevel = types.StringNull()
			}
			if contentConfigCount1+1 > len(r.InputOffice365Service.ContentConfig) {
				r.InputOffice365Service.ContentConfig = append(r.InputOffice365Service.ContentConfig, contentConfig1)
			} else {
				r.InputOffice365Service.ContentConfig[contentConfigCount1].ContentType = contentConfig1.ContentType
				r.InputOffice365Service.ContentConfig[contentConfigCount1].Description = contentConfig1.Description
				r.InputOffice365Service.ContentConfig[contentConfigCount1].Enabled = contentConfig1.Enabled
				r.InputOffice365Service.ContentConfig[contentConfigCount1].Interval = contentConfig1.Interval
				r.InputOffice365Service.ContentConfig[contentConfigCount1].LogLevel = contentConfig1.LogLevel
			}
		}
		r.InputOffice365Service.Description = types.StringPointerValue(resp.InputOffice365Service.Description)
		r.InputOffice365Service.Disabled = types.BoolPointerValue(resp.InputOffice365Service.Disabled)
		r.InputOffice365Service.Environment = types.StringPointerValue(resp.InputOffice365Service.Environment)
		r.InputOffice365Service.ID = types.StringPointerValue(resp.InputOffice365Service.ID)
		r.InputOffice365Service.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.InputOffice365Service.IgnoreGroupJobsLimit)
		r.InputOffice365Service.JobTimeout = types.StringPointerValue(resp.InputOffice365Service.JobTimeout)
		r.InputOffice365Service.KeepAliveTime = types.Float64PointerValue(resp.InputOffice365Service.KeepAliveTime)
		r.InputOffice365Service.MaxMissedKeepAlives = types.Float64PointerValue(resp.InputOffice365Service.MaxMissedKeepAlives)
		r.InputOffice365Service.Metadata = []tfTypes.InputOffice365ServiceMetadatum{}
		if len(r.InputOffice365Service.Metadata) > len(resp.InputOffice365Service.Metadata) {
			r.InputOffice365Service.Metadata = r.InputOffice365Service.Metadata[:len(resp.InputOffice365Service.Metadata)]
		}
		for metadataCount38, metadataItem38 := range resp.InputOffice365Service.Metadata {
			var metadata38 tfTypes.InputOffice365ServiceMetadatum
			metadata38.Name = types.StringValue(metadataItem38.Name)
			metadata38.Value = types.StringValue(metadataItem38.Value)
			if metadataCount38+1 > len(r.InputOffice365Service.Metadata) {
				r.InputOffice365Service.Metadata = append(r.InputOffice365Service.Metadata, metadata38)
			} else {
				r.InputOffice365Service.Metadata[metadataCount38].Name = metadata38.Name
				r.InputOffice365Service.Metadata[metadataCount38].Value = metadata38.Value
			}
		}
		r.InputOffice365Service.Pipeline = types.StringPointerValue(resp.InputOffice365Service.Pipeline)
		if resp.InputOffice365Service.PlanType != nil {
			r.InputOffice365Service.PlanType = types.StringValue(string(*resp.InputOffice365Service.PlanType))
		} else {
			r.InputOffice365Service.PlanType = types.StringNull()
		}
		if resp.InputOffice365Service.Pq == nil {
			r.InputOffice365Service.Pq = nil
		} else {
			r.InputOffice365Service.Pq = &tfTypes.InputOffice365ServicePq{}
			r.InputOffice365Service.Pq.CommitFrequency = types.Float64PointerValue(resp.InputOffice365Service.Pq.CommitFrequency)
			if resp.InputOffice365Service.Pq.Compress != nil {
				r.InputOffice365Service.Pq.Compress = types.StringValue(string(*resp.InputOffice365Service.Pq.Compress))
			} else {
				r.InputOffice365Service.Pq.Compress = types.StringNull()
			}
			r.InputOffice365Service.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputOffice365Service.Pq.MaxBufferSize)
			r.InputOffice365Service.Pq.MaxFileSize = types.StringPointerValue(resp.InputOffice365Service.Pq.MaxFileSize)
			r.InputOffice365Service.Pq.MaxSize = types.StringPointerValue(resp.InputOffice365Service.Pq.MaxSize)
			if resp.InputOffice365Service.Pq.Mode != nil {
				r.InputOffice365Service.Pq.Mode = types.StringValue(string(*resp.InputOffice365Service.Pq.Mode))
			} else {
				r.InputOffice365Service.Pq.Mode = types.StringNull()
			}
			r.InputOffice365Service.Pq.Path = types.StringPointerValue(resp.InputOffice365Service.Pq.Path)
		}
		r.InputOffice365Service.PqEnabled = types.BoolPointerValue(resp.InputOffice365Service.PqEnabled)
		if resp.InputOffice365Service.RetryRules == nil {
			r.InputOffice365Service.RetryRules = nil
		} else {
			r.InputOffice365Service.RetryRules = &tfTypes.InputOffice365ServiceRetryRules{}
			r.InputOffice365Service.RetryRules.Codes = make([]types.Float64, 0, len(resp.InputOffice365Service.RetryRules.Codes))
			for _, v := range resp.InputOffice365Service.RetryRules.Codes {
				r.InputOffice365Service.RetryRules.Codes = append(r.InputOffice365Service.RetryRules.Codes, types.Float64Value(v))
			}
			r.InputOffice365Service.RetryRules.EnableHeader = types.BoolPointerValue(resp.InputOffice365Service.RetryRules.EnableHeader)
			r.InputOffice365Service.RetryRules.Interval = types.Float64PointerValue(resp.InputOffice365Service.RetryRules.Interval)
			r.InputOffice365Service.RetryRules.Limit = types.Float64PointerValue(resp.InputOffice365Service.RetryRules.Limit)
			r.InputOffice365Service.RetryRules.Multiplier = types.Float64PointerValue(resp.InputOffice365Service.RetryRules.Multiplier)
			r.InputOffice365Service.RetryRules.RetryConnectReset = types.BoolPointerValue(resp.InputOffice365Service.RetryRules.RetryConnectReset)
			r.InputOffice365Service.RetryRules.RetryConnectTimeout = types.BoolPointerValue(resp.InputOffice365Service.RetryRules.RetryConnectTimeout)
			if resp.InputOffice365Service.RetryRules.Type != nil {
				r.InputOffice365Service.RetryRules.Type = types.StringValue(string(*resp.InputOffice365Service.RetryRules.Type))
			} else {
				r.InputOffice365Service.RetryRules.Type = types.StringNull()
			}
		}
		r.InputOffice365Service.SendToRoutes = types.BoolPointerValue(resp.InputOffice365Service.SendToRoutes)
		r.InputOffice365Service.Streamtags = make([]types.String, 0, len(resp.InputOffice365Service.Streamtags))
		for _, v := range resp.InputOffice365Service.Streamtags {
			r.InputOffice365Service.Streamtags = append(r.InputOffice365Service.Streamtags, types.StringValue(v))
		}
		r.InputOffice365Service.TenantID = types.StringValue(resp.InputOffice365Service.TenantID)
		r.InputOffice365Service.TextSecret = types.StringPointerValue(resp.InputOffice365Service.TextSecret)
		r.InputOffice365Service.Timeout = types.Float64PointerValue(resp.InputOffice365Service.Timeout)
		r.InputOffice365Service.TTL = types.StringPointerValue(resp.InputOffice365Service.TTL)
		if resp.InputOffice365Service.Type != nil {
			r.InputOffice365Service.Type = types.StringValue(string(*resp.InputOffice365Service.Type))
		} else {
			r.InputOffice365Service.Type = types.StringNull()
		}
	}
	if resp.InputOpenTelemetry != nil {
		r.InputOpenTelemetry = &tfTypes.InputOpenTelemetry{}
		if resp.InputOpenTelemetry.ActivityLogSampleRate == nil {
			r.InputOpenTelemetry.ActivityLogSampleRate = types.StringNull()
		} else {
			activityLogSampleRateResult, _ := json.Marshal(resp.InputOpenTelemetry.ActivityLogSampleRate)
			r.InputOpenTelemetry.ActivityLogSampleRate = types.StringValue(string(activityLogSampleRateResult))
		}
		r.InputOpenTelemetry.AuthHeaderExpr = types.StringPointerValue(resp.InputOpenTelemetry.AuthHeaderExpr)
		if resp.InputOpenTelemetry.AuthType != nil {
			r.InputOpenTelemetry.AuthType = types.StringValue(string(*resp.InputOpenTelemetry.AuthType))
		} else {
			r.InputOpenTelemetry.AuthType = types.StringNull()
		}
		if resp.InputOpenTelemetry.CaptureHeaders == nil {
			r.InputOpenTelemetry.CaptureHeaders = types.StringNull()
		} else {
			captureHeadersResult, _ := json.Marshal(resp.InputOpenTelemetry.CaptureHeaders)
			r.InputOpenTelemetry.CaptureHeaders = types.StringValue(string(captureHeadersResult))
		}
		r.InputOpenTelemetry.Connections = []tfTypes.InputOpenTelemetryConnection{}
		if len(r.InputOpenTelemetry.Connections) > len(resp.InputOpenTelemetry.Connections) {
			r.InputOpenTelemetry.Connections = r.InputOpenTelemetry.Connections[:len(resp.InputOpenTelemetry.Connections)]
		}
		for connectionsCount37, connectionsItem37 := range resp.InputOpenTelemetry.Connections {
			var connections37 tfTypes.InputOpenTelemetryConnection
			connections37.Output = types.StringValue(connectionsItem37.Output)
			connections37.Pipeline = types.StringPointerValue(connectionsItem37.Pipeline)
			if connectionsCount37+1 > len(r.InputOpenTelemetry.Connections) {
				r.InputOpenTelemetry.Connections = append(r.InputOpenTelemetry.Connections, connections37)
			} else {
				r.InputOpenTelemetry.Connections[connectionsCount37].Output = connections37.Output
				r.InputOpenTelemetry.Connections[connectionsCount37].Pipeline = connections37.Pipeline
			}
		}
		r.InputOpenTelemetry.CredentialsSecret = types.StringPointerValue(resp.InputOpenTelemetry.CredentialsSecret)
		r.InputOpenTelemetry.Description = types.StringPointerValue(resp.InputOpenTelemetry.Description)
		r.InputOpenTelemetry.Disabled = types.BoolPointerValue(resp.InputOpenTelemetry.Disabled)
		r.InputOpenTelemetry.EnableHealthCheck = types.BoolPointerValue(resp.InputOpenTelemetry.EnableHealthCheck)
		if resp.InputOpenTelemetry.EnableProxyHeader == nil {
			r.InputOpenTelemetry.EnableProxyHeader = types.StringNull()
		} else {
			enableProxyHeaderResult, _ := json.Marshal(resp.InputOpenTelemetry.EnableProxyHeader)
			r.InputOpenTelemetry.EnableProxyHeader = types.StringValue(string(enableProxyHeaderResult))
		}
		r.InputOpenTelemetry.Environment = types.StringPointerValue(resp.InputOpenTelemetry.Environment)
		r.InputOpenTelemetry.ExtractLogs = types.BoolPointerValue(resp.InputOpenTelemetry.ExtractLogs)
		r.InputOpenTelemetry.ExtractMetrics = types.BoolPointerValue(resp.InputOpenTelemetry.ExtractMetrics)
		r.InputOpenTelemetry.ExtractSpans = types.BoolPointerValue(resp.InputOpenTelemetry.ExtractSpans)
		r.InputOpenTelemetry.Host = types.StringPointerValue(resp.InputOpenTelemetry.Host)
		r.InputOpenTelemetry.ID = types.StringPointerValue(resp.InputOpenTelemetry.ID)
		r.InputOpenTelemetry.IPAllowlistRegex = types.StringPointerValue(resp.InputOpenTelemetry.IPAllowlistRegex)
		r.InputOpenTelemetry.IPDenylistRegex = types.StringPointerValue(resp.InputOpenTelemetry.IPDenylistRegex)
		r.InputOpenTelemetry.KeepAliveTimeout = types.Float64PointerValue(resp.InputOpenTelemetry.KeepAliveTimeout)
		r.InputOpenTelemetry.LoginURL = types.StringPointerValue(resp.InputOpenTelemetry.LoginURL)
		r.InputOpenTelemetry.MaxActiveCxn = types.Float64PointerValue(resp.InputOpenTelemetry.MaxActiveCxn)
		r.InputOpenTelemetry.MaxActiveReq = types.Float64PointerValue(resp.InputOpenTelemetry.MaxActiveReq)
		r.InputOpenTelemetry.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputOpenTelemetry.MaxRequestsPerSocket)
		r.InputOpenTelemetry.Metadata = []tfTypes.InputOpenTelemetryMetadatum{}
		if len(r.InputOpenTelemetry.Metadata) > len(resp.InputOpenTelemetry.Metadata) {
			r.InputOpenTelemetry.Metadata = r.InputOpenTelemetry.Metadata[:len(resp.InputOpenTelemetry.Metadata)]
		}
		for metadataCount39, metadataItem39 := range resp.InputOpenTelemetry.Metadata {
			var metadata39 tfTypes.InputOpenTelemetryMetadatum
			metadata39.Name = types.StringValue(metadataItem39.Name)
			metadata39.Value = types.StringValue(metadataItem39.Value)
			if metadataCount39+1 > len(r.InputOpenTelemetry.Metadata) {
				r.InputOpenTelemetry.Metadata = append(r.InputOpenTelemetry.Metadata, metadata39)
			} else {
				r.InputOpenTelemetry.Metadata[metadataCount39].Name = metadata39.Name
				r.InputOpenTelemetry.Metadata[metadataCount39].Value = metadata39.Value
			}
		}
		r.InputOpenTelemetry.OauthHeaders = []tfTypes.InputOpenTelemetryOauthHeader{}
		if len(r.InputOpenTelemetry.OauthHeaders) > len(resp.InputOpenTelemetry.OauthHeaders) {
			r.InputOpenTelemetry.OauthHeaders = r.InputOpenTelemetry.OauthHeaders[:len(resp.InputOpenTelemetry.OauthHeaders)]
		}
		for oauthHeadersCount5, oauthHeadersItem5 := range resp.InputOpenTelemetry.OauthHeaders {
			var oauthHeaders5 tfTypes.InputOpenTelemetryOauthHeader
			oauthHeaders5.Name = types.StringValue(oauthHeadersItem5.Name)
			oauthHeaders5.Value = types.StringValue(oauthHeadersItem5.Value)
			if oauthHeadersCount5+1 > len(r.InputOpenTelemetry.OauthHeaders) {
				r.InputOpenTelemetry.OauthHeaders = append(r.InputOpenTelemetry.OauthHeaders, oauthHeaders5)
			} else {
				r.InputOpenTelemetry.OauthHeaders[oauthHeadersCount5].Name = oauthHeaders5.Name
				r.InputOpenTelemetry.OauthHeaders[oauthHeadersCount5].Value = oauthHeaders5.Value
			}
		}
		r.InputOpenTelemetry.OauthParams = []tfTypes.InputOpenTelemetryOauthParam{}
		if len(r.InputOpenTelemetry.OauthParams) > len(resp.InputOpenTelemetry.OauthParams) {
			r.InputOpenTelemetry.OauthParams = r.InputOpenTelemetry.OauthParams[:len(resp.InputOpenTelemetry.OauthParams)]
		}
		for oauthParamsCount5, oauthParamsItem5 := range resp.InputOpenTelemetry.OauthParams {
			var oauthParams5 tfTypes.InputOpenTelemetryOauthParam
			oauthParams5.Name = types.StringValue(oauthParamsItem5.Name)
			oauthParams5.Value = types.StringValue(oauthParamsItem5.Value)
			if oauthParamsCount5+1 > len(r.InputOpenTelemetry.OauthParams) {
				r.InputOpenTelemetry.OauthParams = append(r.InputOpenTelemetry.OauthParams, oauthParams5)
			} else {
				r.InputOpenTelemetry.OauthParams[oauthParamsCount5].Name = oauthParams5.Name
				r.InputOpenTelemetry.OauthParams[oauthParamsCount5].Value = oauthParams5.Value
			}
		}
		if resp.InputOpenTelemetry.OtlpVersion != nil {
			r.InputOpenTelemetry.OtlpVersion = types.StringValue(string(*resp.InputOpenTelemetry.OtlpVersion))
		} else {
			r.InputOpenTelemetry.OtlpVersion = types.StringNull()
		}
		r.InputOpenTelemetry.Password = types.StringPointerValue(resp.InputOpenTelemetry.Password)
		r.InputOpenTelemetry.Pipeline = types.StringPointerValue(resp.InputOpenTelemetry.Pipeline)
		r.InputOpenTelemetry.Port = types.Float64PointerValue(resp.InputOpenTelemetry.Port)
		if resp.InputOpenTelemetry.Pq == nil {
			r.InputOpenTelemetry.Pq = nil
		} else {
			r.InputOpenTelemetry.Pq = &tfTypes.InputOpenTelemetryPq{}
			r.InputOpenTelemetry.Pq.CommitFrequency = types.Float64PointerValue(resp.InputOpenTelemetry.Pq.CommitFrequency)
			if resp.InputOpenTelemetry.Pq.Compress != nil {
				r.InputOpenTelemetry.Pq.Compress = types.StringValue(string(*resp.InputOpenTelemetry.Pq.Compress))
			} else {
				r.InputOpenTelemetry.Pq.Compress = types.StringNull()
			}
			r.InputOpenTelemetry.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputOpenTelemetry.Pq.MaxBufferSize)
			r.InputOpenTelemetry.Pq.MaxFileSize = types.StringPointerValue(resp.InputOpenTelemetry.Pq.MaxFileSize)
			r.InputOpenTelemetry.Pq.MaxSize = types.StringPointerValue(resp.InputOpenTelemetry.Pq.MaxSize)
			if resp.InputOpenTelemetry.Pq.Mode != nil {
				r.InputOpenTelemetry.Pq.Mode = types.StringValue(string(*resp.InputOpenTelemetry.Pq.Mode))
			} else {
				r.InputOpenTelemetry.Pq.Mode = types.StringNull()
			}
			r.InputOpenTelemetry.Pq.Path = types.StringPointerValue(resp.InputOpenTelemetry.Pq.Path)
		}
		r.InputOpenTelemetry.PqEnabled = types.BoolPointerValue(resp.InputOpenTelemetry.PqEnabled)
		if resp.InputOpenTelemetry.Protocol != nil {
			r.InputOpenTelemetry.Protocol = types.StringValue(string(*resp.InputOpenTelemetry.Protocol))
		} else {
			r.InputOpenTelemetry.Protocol = types.StringNull()
		}
		r.InputOpenTelemetry.RequestTimeout = types.Float64PointerValue(resp.InputOpenTelemetry.RequestTimeout)
		r.InputOpenTelemetry.Secret = types.StringPointerValue(resp.InputOpenTelemetry.Secret)
		r.InputOpenTelemetry.SecretParamName = types.StringPointerValue(resp.InputOpenTelemetry.SecretParamName)
		r.InputOpenTelemetry.SendToRoutes = types.BoolPointerValue(resp.InputOpenTelemetry.SendToRoutes)
		r.InputOpenTelemetry.SocketTimeout = types.Float64PointerValue(resp.InputOpenTelemetry.SocketTimeout)
		r.InputOpenTelemetry.Streamtags = make([]types.String, 0, len(resp.InputOpenTelemetry.Streamtags))
		for _, v := range resp.InputOpenTelemetry.Streamtags {
			r.InputOpenTelemetry.Streamtags = append(r.InputOpenTelemetry.Streamtags, types.StringValue(v))
		}
		r.InputOpenTelemetry.TextSecret = types.StringPointerValue(resp.InputOpenTelemetry.TextSecret)
		if resp.InputOpenTelemetry.TLS == nil {
			r.InputOpenTelemetry.TLS = nil
		} else {
			r.InputOpenTelemetry.TLS = &tfTypes.InputOpenTelemetryTLSSettingsServerSide{}
			r.InputOpenTelemetry.TLS.CaPath = types.StringPointerValue(resp.InputOpenTelemetry.TLS.CaPath)
			r.InputOpenTelemetry.TLS.CertificateName = types.StringPointerValue(resp.InputOpenTelemetry.TLS.CertificateName)
			r.InputOpenTelemetry.TLS.CertPath = types.StringPointerValue(resp.InputOpenTelemetry.TLS.CertPath)
			if resp.InputOpenTelemetry.TLS.CommonNameRegex == nil {
				r.InputOpenTelemetry.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult14, _ := json.Marshal(resp.InputOpenTelemetry.TLS.CommonNameRegex)
				r.InputOpenTelemetry.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult14))
			}
			r.InputOpenTelemetry.TLS.Disabled = types.BoolPointerValue(resp.InputOpenTelemetry.TLS.Disabled)
			if resp.InputOpenTelemetry.TLS.MaxVersion != nil {
				r.InputOpenTelemetry.TLS.MaxVersion = types.StringValue(string(*resp.InputOpenTelemetry.TLS.MaxVersion))
			} else {
				r.InputOpenTelemetry.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputOpenTelemetry.TLS.MinVersion != nil {
				r.InputOpenTelemetry.TLS.MinVersion = types.StringValue(string(*resp.InputOpenTelemetry.TLS.MinVersion))
			} else {
				r.InputOpenTelemetry.TLS.MinVersion = types.StringNull()
			}
			r.InputOpenTelemetry.TLS.Passphrase = types.StringPointerValue(resp.InputOpenTelemetry.TLS.Passphrase)
			r.InputOpenTelemetry.TLS.PrivKeyPath = types.StringPointerValue(resp.InputOpenTelemetry.TLS.PrivKeyPath)
			if resp.InputOpenTelemetry.TLS.RejectUnauthorized == nil {
				r.InputOpenTelemetry.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult14, _ := json.Marshal(resp.InputOpenTelemetry.TLS.RejectUnauthorized)
				r.InputOpenTelemetry.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult14))
			}
			r.InputOpenTelemetry.TLS.RequestCert = types.BoolPointerValue(resp.InputOpenTelemetry.TLS.RequestCert)
		}
		r.InputOpenTelemetry.Token = types.StringPointerValue(resp.InputOpenTelemetry.Token)
		r.InputOpenTelemetry.TokenAttributeName = types.StringPointerValue(resp.InputOpenTelemetry.TokenAttributeName)
		r.InputOpenTelemetry.TokenTimeoutSecs = types.Float64PointerValue(resp.InputOpenTelemetry.TokenTimeoutSecs)
		if resp.InputOpenTelemetry.Type != nil {
			r.InputOpenTelemetry.Type = types.StringValue(string(*resp.InputOpenTelemetry.Type))
		} else {
			r.InputOpenTelemetry.Type = types.StringNull()
		}
		r.InputOpenTelemetry.Username = types.StringPointerValue(resp.InputOpenTelemetry.Username)
	}
	if resp.InputPrometheus != nil {
		r.InputPrometheus = &tfTypes.InputPrometheus{}
		r.InputPrometheus.AssumeRoleArn = types.StringPointerValue(resp.InputPrometheus.AssumeRoleArn)
		r.InputPrometheus.AssumeRoleExternalID = types.StringPointerValue(resp.InputPrometheus.AssumeRoleExternalID)
		if resp.InputPrometheus.AuthType != nil {
			r.InputPrometheus.AuthType = types.StringValue(string(*resp.InputPrometheus.AuthType))
		} else {
			r.InputPrometheus.AuthType = types.StringNull()
		}
		if resp.InputPrometheus.AwsAuthenticationMethod != nil {
			r.InputPrometheus.AwsAuthenticationMethod = types.StringValue(string(*resp.InputPrometheus.AwsAuthenticationMethod))
		} else {
			r.InputPrometheus.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputPrometheus.AwsSecretKey = types.StringPointerValue(resp.InputPrometheus.AwsSecretKey)
		r.InputPrometheus.Connections = []tfTypes.InputPrometheusConnection{}
		if len(r.InputPrometheus.Connections) > len(resp.InputPrometheus.Connections) {
			r.InputPrometheus.Connections = r.InputPrometheus.Connections[:len(resp.InputPrometheus.Connections)]
		}
		for connectionsCount38, connectionsItem38 := range resp.InputPrometheus.Connections {
			var connections38 tfTypes.InputPrometheusConnection
			connections38.Output = types.StringValue(connectionsItem38.Output)
			connections38.Pipeline = types.StringPointerValue(connectionsItem38.Pipeline)
			if connectionsCount38+1 > len(r.InputPrometheus.Connections) {
				r.InputPrometheus.Connections = append(r.InputPrometheus.Connections, connections38)
			} else {
				r.InputPrometheus.Connections[connectionsCount38].Output = connections38.Output
				r.InputPrometheus.Connections[connectionsCount38].Pipeline = connections38.Pipeline
			}
		}
		r.InputPrometheus.CredentialsSecret = types.StringPointerValue(resp.InputPrometheus.CredentialsSecret)
		r.InputPrometheus.Description = types.StringPointerValue(resp.InputPrometheus.Description)
		r.InputPrometheus.DimensionList = make([]types.String, 0, len(resp.InputPrometheus.DimensionList))
		for _, v := range resp.InputPrometheus.DimensionList {
			r.InputPrometheus.DimensionList = append(r.InputPrometheus.DimensionList, types.StringValue(v))
		}
		r.InputPrometheus.Disabled = types.BoolPointerValue(resp.InputPrometheus.Disabled)
		if resp.InputPrometheus.DiscoveryType != nil {
			r.InputPrometheus.DiscoveryType = types.StringValue(string(*resp.InputPrometheus.DiscoveryType))
		} else {
			r.InputPrometheus.DiscoveryType = types.StringNull()
		}
		r.InputPrometheus.DurationSeconds = types.Float64PointerValue(resp.InputPrometheus.DurationSeconds)
		r.InputPrometheus.EnableAssumeRole = types.BoolPointerValue(resp.InputPrometheus.EnableAssumeRole)
		r.InputPrometheus.Endpoint = types.StringPointerValue(resp.InputPrometheus.Endpoint)
		r.InputPrometheus.Environment = types.StringPointerValue(resp.InputPrometheus.Environment)
		r.InputPrometheus.ID = types.StringPointerValue(resp.InputPrometheus.ID)
		r.InputPrometheus.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.InputPrometheus.IgnoreGroupJobsLimit)
		r.InputPrometheus.Interval = types.Float64PointerValue(resp.InputPrometheus.Interval)
		r.InputPrometheus.JobTimeout = types.StringPointerValue(resp.InputPrometheus.JobTimeout)
		r.InputPrometheus.KeepAliveTime = types.Float64PointerValue(resp.InputPrometheus.KeepAliveTime)
		if resp.InputPrometheus.LogLevel != nil {
			r.InputPrometheus.LogLevel = types.StringValue(string(*resp.InputPrometheus.LogLevel))
		} else {
			r.InputPrometheus.LogLevel = types.StringNull()
		}
		r.InputPrometheus.MaxMissedKeepAlives = types.Float64PointerValue(resp.InputPrometheus.MaxMissedKeepAlives)
		r.InputPrometheus.Metadata = []tfTypes.InputPrometheusMetadatum{}
		if len(r.InputPrometheus.Metadata) > len(resp.InputPrometheus.Metadata) {
			r.InputPrometheus.Metadata = r.InputPrometheus.Metadata[:len(resp.InputPrometheus.Metadata)]
		}
		for metadataCount40, metadataItem40 := range resp.InputPrometheus.Metadata {
			var metadata40 tfTypes.InputPrometheusMetadatum
			metadata40.Name = types.StringValue(metadataItem40.Name)
			metadata40.Value = types.StringValue(metadataItem40.Value)
			if metadataCount40+1 > len(r.InputPrometheus.Metadata) {
				r.InputPrometheus.Metadata = append(r.InputPrometheus.Metadata, metadata40)
			} else {
				r.InputPrometheus.Metadata[metadataCount40].Name = metadata40.Name
				r.InputPrometheus.Metadata[metadataCount40].Value = metadata40.Value
			}
		}
		r.InputPrometheus.NameList = make([]types.String, 0, len(resp.InputPrometheus.NameList))
		for _, v := range resp.InputPrometheus.NameList {
			r.InputPrometheus.NameList = append(r.InputPrometheus.NameList, types.StringValue(v))
		}
		r.InputPrometheus.Password = types.StringPointerValue(resp.InputPrometheus.Password)
		r.InputPrometheus.Pipeline = types.StringPointerValue(resp.InputPrometheus.Pipeline)
		if resp.InputPrometheus.Pq == nil {
			r.InputPrometheus.Pq = nil
		} else {
			r.InputPrometheus.Pq = &tfTypes.InputPrometheusPq{}
			r.InputPrometheus.Pq.CommitFrequency = types.Float64PointerValue(resp.InputPrometheus.Pq.CommitFrequency)
			if resp.InputPrometheus.Pq.Compress != nil {
				r.InputPrometheus.Pq.Compress = types.StringValue(string(*resp.InputPrometheus.Pq.Compress))
			} else {
				r.InputPrometheus.Pq.Compress = types.StringNull()
			}
			r.InputPrometheus.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputPrometheus.Pq.MaxBufferSize)
			r.InputPrometheus.Pq.MaxFileSize = types.StringPointerValue(resp.InputPrometheus.Pq.MaxFileSize)
			r.InputPrometheus.Pq.MaxSize = types.StringPointerValue(resp.InputPrometheus.Pq.MaxSize)
			if resp.InputPrometheus.Pq.Mode != nil {
				r.InputPrometheus.Pq.Mode = types.StringValue(string(*resp.InputPrometheus.Pq.Mode))
			} else {
				r.InputPrometheus.Pq.Mode = types.StringNull()
			}
			r.InputPrometheus.Pq.Path = types.StringPointerValue(resp.InputPrometheus.Pq.Path)
		}
		r.InputPrometheus.PqEnabled = types.BoolPointerValue(resp.InputPrometheus.PqEnabled)
		if resp.InputPrometheus.RecordType != nil {
			r.InputPrometheus.RecordType = types.StringValue(string(*resp.InputPrometheus.RecordType))
		} else {
			r.InputPrometheus.RecordType = types.StringNull()
		}
		r.InputPrometheus.Region = types.StringPointerValue(resp.InputPrometheus.Region)
		r.InputPrometheus.RejectUnauthorized = types.BoolPointerValue(resp.InputPrometheus.RejectUnauthorized)
		r.InputPrometheus.ReuseConnections = types.BoolPointerValue(resp.InputPrometheus.ReuseConnections)
		r.InputPrometheus.ScrapePath = types.StringPointerValue(resp.InputPrometheus.ScrapePath)
		r.InputPrometheus.ScrapePort = types.Float64PointerValue(resp.InputPrometheus.ScrapePort)
		if resp.InputPrometheus.ScrapeProtocol != nil {
			r.InputPrometheus.ScrapeProtocol = types.StringValue(string(*resp.InputPrometheus.ScrapeProtocol))
		} else {
			r.InputPrometheus.ScrapeProtocol = types.StringNull()
		}
		r.InputPrometheus.SearchFilter = []tfTypes.InputPrometheusSearchFilter{}
		if len(r.InputPrometheus.SearchFilter) > len(resp.InputPrometheus.SearchFilter) {
			r.InputPrometheus.SearchFilter = r.InputPrometheus.SearchFilter[:len(resp.InputPrometheus.SearchFilter)]
		}
		for searchFilterCount1, searchFilterItem1 := range resp.InputPrometheus.SearchFilter {
			var searchFilter1 tfTypes.InputPrometheusSearchFilter
			searchFilter1.Name = types.StringValue(searchFilterItem1.Name)
			searchFilter1.Values = make([]types.String, 0, len(searchFilterItem1.Values))
			for _, v := range searchFilterItem1.Values {
				searchFilter1.Values = append(searchFilter1.Values, types.StringValue(v))
			}
			if searchFilterCount1+1 > len(r.InputPrometheus.SearchFilter) {
				r.InputPrometheus.SearchFilter = append(r.InputPrometheus.SearchFilter, searchFilter1)
			} else {
				r.InputPrometheus.SearchFilter[searchFilterCount1].Name = searchFilter1.Name
				r.InputPrometheus.SearchFilter[searchFilterCount1].Values = searchFilter1.Values
			}
		}
		r.InputPrometheus.SendToRoutes = types.BoolPointerValue(resp.InputPrometheus.SendToRoutes)
		if resp.InputPrometheus.SignatureVersion != nil {
			r.InputPrometheus.SignatureVersion = types.StringValue(string(*resp.InputPrometheus.SignatureVersion))
		} else {
			r.InputPrometheus.SignatureVersion = types.StringNull()
		}
		r.InputPrometheus.Streamtags = make([]types.String, 0, len(resp.InputPrometheus.Streamtags))
		for _, v := range resp.InputPrometheus.Streamtags {
			r.InputPrometheus.Streamtags = append(r.InputPrometheus.Streamtags, types.StringValue(v))
		}
		r.InputPrometheus.TargetList = make([]types.String, 0, len(resp.InputPrometheus.TargetList))
		for _, v := range resp.InputPrometheus.TargetList {
			r.InputPrometheus.TargetList = append(r.InputPrometheus.TargetList, types.StringValue(v))
		}
		r.InputPrometheus.TTL = types.StringPointerValue(resp.InputPrometheus.TTL)
		if resp.InputPrometheus.Type != nil {
			r.InputPrometheus.Type = types.StringValue(string(*resp.InputPrometheus.Type))
		} else {
			r.InputPrometheus.Type = types.StringNull()
		}
		r.InputPrometheus.UsePublicIP = types.BoolPointerValue(resp.InputPrometheus.UsePublicIP)
		r.InputPrometheus.Username = types.StringPointerValue(resp.InputPrometheus.Username)
	}
	if resp.InputPrometheusRw != nil {
		r.InputPrometheusRw = &tfTypes.InputPrometheusRw{}
		r.InputPrometheusRw.ActivityLogSampleRate = types.Float64PointerValue(resp.InputPrometheusRw.ActivityLogSampleRate)
		r.InputPrometheusRw.AuthHeaderExpr = types.StringPointerValue(resp.InputPrometheusRw.AuthHeaderExpr)
		if resp.InputPrometheusRw.AuthType != nil {
			r.InputPrometheusRw.AuthType = types.StringValue(string(*resp.InputPrometheusRw.AuthType))
		} else {
			r.InputPrometheusRw.AuthType = types.StringNull()
		}
		r.InputPrometheusRw.CaptureHeaders = types.BoolPointerValue(resp.InputPrometheusRw.CaptureHeaders)
		r.InputPrometheusRw.Connections = []tfTypes.InputPrometheusRwConnection{}
		if len(r.InputPrometheusRw.Connections) > len(resp.InputPrometheusRw.Connections) {
			r.InputPrometheusRw.Connections = r.InputPrometheusRw.Connections[:len(resp.InputPrometheusRw.Connections)]
		}
		for connectionsCount39, connectionsItem39 := range resp.InputPrometheusRw.Connections {
			var connections39 tfTypes.InputPrometheusRwConnection
			connections39.Output = types.StringValue(connectionsItem39.Output)
			connections39.Pipeline = types.StringPointerValue(connectionsItem39.Pipeline)
			if connectionsCount39+1 > len(r.InputPrometheusRw.Connections) {
				r.InputPrometheusRw.Connections = append(r.InputPrometheusRw.Connections, connections39)
			} else {
				r.InputPrometheusRw.Connections[connectionsCount39].Output = connections39.Output
				r.InputPrometheusRw.Connections[connectionsCount39].Pipeline = connections39.Pipeline
			}
		}
		r.InputPrometheusRw.CredentialsSecret = types.StringPointerValue(resp.InputPrometheusRw.CredentialsSecret)
		r.InputPrometheusRw.Description = types.StringPointerValue(resp.InputPrometheusRw.Description)
		r.InputPrometheusRw.Disabled = types.BoolPointerValue(resp.InputPrometheusRw.Disabled)
		r.InputPrometheusRw.EnableHealthCheck = types.BoolPointerValue(resp.InputPrometheusRw.EnableHealthCheck)
		r.InputPrometheusRw.EnableProxyHeader = types.BoolPointerValue(resp.InputPrometheusRw.EnableProxyHeader)
		r.InputPrometheusRw.Environment = types.StringPointerValue(resp.InputPrometheusRw.Environment)
		r.InputPrometheusRw.Host = types.StringPointerValue(resp.InputPrometheusRw.Host)
		r.InputPrometheusRw.ID = types.StringPointerValue(resp.InputPrometheusRw.ID)
		r.InputPrometheusRw.IPAllowlistRegex = types.StringPointerValue(resp.InputPrometheusRw.IPAllowlistRegex)
		r.InputPrometheusRw.IPDenylistRegex = types.StringPointerValue(resp.InputPrometheusRw.IPDenylistRegex)
		r.InputPrometheusRw.KeepAliveTimeout = types.Float64PointerValue(resp.InputPrometheusRw.KeepAliveTimeout)
		r.InputPrometheusRw.LoginURL = types.StringPointerValue(resp.InputPrometheusRw.LoginURL)
		r.InputPrometheusRw.MaxActiveReq = types.Float64PointerValue(resp.InputPrometheusRw.MaxActiveReq)
		r.InputPrometheusRw.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputPrometheusRw.MaxRequestsPerSocket)
		r.InputPrometheusRw.Metadata = []tfTypes.InputPrometheusRwMetadatum{}
		if len(r.InputPrometheusRw.Metadata) > len(resp.InputPrometheusRw.Metadata) {
			r.InputPrometheusRw.Metadata = r.InputPrometheusRw.Metadata[:len(resp.InputPrometheusRw.Metadata)]
		}
		for metadataCount41, metadataItem41 := range resp.InputPrometheusRw.Metadata {
			var metadata41 tfTypes.InputPrometheusRwMetadatum
			metadata41.Name = types.StringValue(metadataItem41.Name)
			metadata41.Value = types.StringValue(metadataItem41.Value)
			if metadataCount41+1 > len(r.InputPrometheusRw.Metadata) {
				r.InputPrometheusRw.Metadata = append(r.InputPrometheusRw.Metadata, metadata41)
			} else {
				r.InputPrometheusRw.Metadata[metadataCount41].Name = metadata41.Name
				r.InputPrometheusRw.Metadata[metadataCount41].Value = metadata41.Value
			}
		}
		r.InputPrometheusRw.OauthHeaders = []tfTypes.InputPrometheusRwOauthHeader{}
		if len(r.InputPrometheusRw.OauthHeaders) > len(resp.InputPrometheusRw.OauthHeaders) {
			r.InputPrometheusRw.OauthHeaders = r.InputPrometheusRw.OauthHeaders[:len(resp.InputPrometheusRw.OauthHeaders)]
		}
		for oauthHeadersCount6, oauthHeadersItem6 := range resp.InputPrometheusRw.OauthHeaders {
			var oauthHeaders6 tfTypes.InputPrometheusRwOauthHeader
			oauthHeaders6.Name = types.StringValue(oauthHeadersItem6.Name)
			oauthHeaders6.Value = types.StringValue(oauthHeadersItem6.Value)
			if oauthHeadersCount6+1 > len(r.InputPrometheusRw.OauthHeaders) {
				r.InputPrometheusRw.OauthHeaders = append(r.InputPrometheusRw.OauthHeaders, oauthHeaders6)
			} else {
				r.InputPrometheusRw.OauthHeaders[oauthHeadersCount6].Name = oauthHeaders6.Name
				r.InputPrometheusRw.OauthHeaders[oauthHeadersCount6].Value = oauthHeaders6.Value
			}
		}
		r.InputPrometheusRw.OauthParams = []tfTypes.InputPrometheusRwOauthParam{}
		if len(r.InputPrometheusRw.OauthParams) > len(resp.InputPrometheusRw.OauthParams) {
			r.InputPrometheusRw.OauthParams = r.InputPrometheusRw.OauthParams[:len(resp.InputPrometheusRw.OauthParams)]
		}
		for oauthParamsCount6, oauthParamsItem6 := range resp.InputPrometheusRw.OauthParams {
			var oauthParams6 tfTypes.InputPrometheusRwOauthParam
			oauthParams6.Name = types.StringValue(oauthParamsItem6.Name)
			oauthParams6.Value = types.StringValue(oauthParamsItem6.Value)
			if oauthParamsCount6+1 > len(r.InputPrometheusRw.OauthParams) {
				r.InputPrometheusRw.OauthParams = append(r.InputPrometheusRw.OauthParams, oauthParams6)
			} else {
				r.InputPrometheusRw.OauthParams[oauthParamsCount6].Name = oauthParams6.Name
				r.InputPrometheusRw.OauthParams[oauthParamsCount6].Value = oauthParams6.Value
			}
		}
		r.InputPrometheusRw.Password = types.StringPointerValue(resp.InputPrometheusRw.Password)
		r.InputPrometheusRw.Pipeline = types.StringPointerValue(resp.InputPrometheusRw.Pipeline)
		r.InputPrometheusRw.Port = types.Float64Value(resp.InputPrometheusRw.Port)
		if resp.InputPrometheusRw.Pq == nil {
			r.InputPrometheusRw.Pq = nil
		} else {
			r.InputPrometheusRw.Pq = &tfTypes.InputPrometheusRwPq{}
			r.InputPrometheusRw.Pq.CommitFrequency = types.Float64PointerValue(resp.InputPrometheusRw.Pq.CommitFrequency)
			if resp.InputPrometheusRw.Pq.Compress != nil {
				r.InputPrometheusRw.Pq.Compress = types.StringValue(string(*resp.InputPrometheusRw.Pq.Compress))
			} else {
				r.InputPrometheusRw.Pq.Compress = types.StringNull()
			}
			r.InputPrometheusRw.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputPrometheusRw.Pq.MaxBufferSize)
			r.InputPrometheusRw.Pq.MaxFileSize = types.StringPointerValue(resp.InputPrometheusRw.Pq.MaxFileSize)
			r.InputPrometheusRw.Pq.MaxSize = types.StringPointerValue(resp.InputPrometheusRw.Pq.MaxSize)
			if resp.InputPrometheusRw.Pq.Mode != nil {
				r.InputPrometheusRw.Pq.Mode = types.StringValue(string(*resp.InputPrometheusRw.Pq.Mode))
			} else {
				r.InputPrometheusRw.Pq.Mode = types.StringNull()
			}
			r.InputPrometheusRw.Pq.Path = types.StringPointerValue(resp.InputPrometheusRw.Pq.Path)
		}
		r.InputPrometheusRw.PqEnabled = types.BoolPointerValue(resp.InputPrometheusRw.PqEnabled)
		r.InputPrometheusRw.PrometheusAPI = types.StringPointerValue(resp.InputPrometheusRw.PrometheusAPI)
		r.InputPrometheusRw.RequestTimeout = types.Float64PointerValue(resp.InputPrometheusRw.RequestTimeout)
		r.InputPrometheusRw.Secret = types.StringPointerValue(resp.InputPrometheusRw.Secret)
		r.InputPrometheusRw.SecretParamName = types.StringPointerValue(resp.InputPrometheusRw.SecretParamName)
		r.InputPrometheusRw.SendToRoutes = types.BoolPointerValue(resp.InputPrometheusRw.SendToRoutes)
		r.InputPrometheusRw.SocketTimeout = types.Float64PointerValue(resp.InputPrometheusRw.SocketTimeout)
		r.InputPrometheusRw.Streamtags = make([]types.String, 0, len(resp.InputPrometheusRw.Streamtags))
		for _, v := range resp.InputPrometheusRw.Streamtags {
			r.InputPrometheusRw.Streamtags = append(r.InputPrometheusRw.Streamtags, types.StringValue(v))
		}
		r.InputPrometheusRw.TextSecret = types.StringPointerValue(resp.InputPrometheusRw.TextSecret)
		if resp.InputPrometheusRw.TLS == nil {
			r.InputPrometheusRw.TLS = nil
		} else {
			r.InputPrometheusRw.TLS = &tfTypes.InputPrometheusRwTLSSettingsServerSide{}
			r.InputPrometheusRw.TLS.CaPath = types.StringPointerValue(resp.InputPrometheusRw.TLS.CaPath)
			r.InputPrometheusRw.TLS.CertificateName = types.StringPointerValue(resp.InputPrometheusRw.TLS.CertificateName)
			r.InputPrometheusRw.TLS.CertPath = types.StringPointerValue(resp.InputPrometheusRw.TLS.CertPath)
			if resp.InputPrometheusRw.TLS.CommonNameRegex == nil {
				r.InputPrometheusRw.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult15, _ := json.Marshal(resp.InputPrometheusRw.TLS.CommonNameRegex)
				r.InputPrometheusRw.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult15))
			}
			r.InputPrometheusRw.TLS.Disabled = types.BoolPointerValue(resp.InputPrometheusRw.TLS.Disabled)
			if resp.InputPrometheusRw.TLS.MaxVersion != nil {
				r.InputPrometheusRw.TLS.MaxVersion = types.StringValue(string(*resp.InputPrometheusRw.TLS.MaxVersion))
			} else {
				r.InputPrometheusRw.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputPrometheusRw.TLS.MinVersion != nil {
				r.InputPrometheusRw.TLS.MinVersion = types.StringValue(string(*resp.InputPrometheusRw.TLS.MinVersion))
			} else {
				r.InputPrometheusRw.TLS.MinVersion = types.StringNull()
			}
			r.InputPrometheusRw.TLS.Passphrase = types.StringPointerValue(resp.InputPrometheusRw.TLS.Passphrase)
			r.InputPrometheusRw.TLS.PrivKeyPath = types.StringPointerValue(resp.InputPrometheusRw.TLS.PrivKeyPath)
			if resp.InputPrometheusRw.TLS.RejectUnauthorized == nil {
				r.InputPrometheusRw.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult15, _ := json.Marshal(resp.InputPrometheusRw.TLS.RejectUnauthorized)
				r.InputPrometheusRw.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult15))
			}
			r.InputPrometheusRw.TLS.RequestCert = types.BoolPointerValue(resp.InputPrometheusRw.TLS.RequestCert)
		}
		r.InputPrometheusRw.Token = types.StringPointerValue(resp.InputPrometheusRw.Token)
		r.InputPrometheusRw.TokenAttributeName = types.StringPointerValue(resp.InputPrometheusRw.TokenAttributeName)
		r.InputPrometheusRw.TokenTimeoutSecs = types.Float64PointerValue(resp.InputPrometheusRw.TokenTimeoutSecs)
		if resp.InputPrometheusRw.Type != nil {
			r.InputPrometheusRw.Type = types.StringValue(string(*resp.InputPrometheusRw.Type))
		} else {
			r.InputPrometheusRw.Type = types.StringNull()
		}
		r.InputPrometheusRw.Username = types.StringPointerValue(resp.InputPrometheusRw.Username)
	}
	if resp.InputRawUDP != nil {
		r.InputRawUDP = &tfTypes.InputRawUDP{}
		r.InputRawUDP.Connections = []tfTypes.InputRawUDPConnection{}
		if len(r.InputRawUDP.Connections) > len(resp.InputRawUDP.Connections) {
			r.InputRawUDP.Connections = r.InputRawUDP.Connections[:len(resp.InputRawUDP.Connections)]
		}
		for connectionsCount40, connectionsItem40 := range resp.InputRawUDP.Connections {
			var connections40 tfTypes.InputRawUDPConnection
			connections40.Output = types.StringValue(connectionsItem40.Output)
			connections40.Pipeline = types.StringPointerValue(connectionsItem40.Pipeline)
			if connectionsCount40+1 > len(r.InputRawUDP.Connections) {
				r.InputRawUDP.Connections = append(r.InputRawUDP.Connections, connections40)
			} else {
				r.InputRawUDP.Connections[connectionsCount40].Output = connections40.Output
				r.InputRawUDP.Connections[connectionsCount40].Pipeline = connections40.Pipeline
			}
		}
		r.InputRawUDP.Description = types.StringPointerValue(resp.InputRawUDP.Description)
		r.InputRawUDP.Disabled = types.BoolPointerValue(resp.InputRawUDP.Disabled)
		r.InputRawUDP.Environment = types.StringPointerValue(resp.InputRawUDP.Environment)
		r.InputRawUDP.Host = types.StringPointerValue(resp.InputRawUDP.Host)
		r.InputRawUDP.ID = types.StringPointerValue(resp.InputRawUDP.ID)
		r.InputRawUDP.IngestRawBytes = types.BoolPointerValue(resp.InputRawUDP.IngestRawBytes)
		r.InputRawUDP.IPWhitelistRegex = types.StringPointerValue(resp.InputRawUDP.IPWhitelistRegex)
		r.InputRawUDP.MaxBufferSize = types.Float64PointerValue(resp.InputRawUDP.MaxBufferSize)
		r.InputRawUDP.Metadata = []tfTypes.InputRawUDPMetadatum{}
		if len(r.InputRawUDP.Metadata) > len(resp.InputRawUDP.Metadata) {
			r.InputRawUDP.Metadata = r.InputRawUDP.Metadata[:len(resp.InputRawUDP.Metadata)]
		}
		for metadataCount42, metadataItem42 := range resp.InputRawUDP.Metadata {
			var metadata42 tfTypes.InputRawUDPMetadatum
			metadata42.Name = types.StringValue(metadataItem42.Name)
			metadata42.Value = types.StringValue(metadataItem42.Value)
			if metadataCount42+1 > len(r.InputRawUDP.Metadata) {
				r.InputRawUDP.Metadata = append(r.InputRawUDP.Metadata, metadata42)
			} else {
				r.InputRawUDP.Metadata[metadataCount42].Name = metadata42.Name
				r.InputRawUDP.Metadata[metadataCount42].Value = metadata42.Value
			}
		}
		r.InputRawUDP.Pipeline = types.StringPointerValue(resp.InputRawUDP.Pipeline)
		r.InputRawUDP.Port = types.Float64Value(resp.InputRawUDP.Port)
		if resp.InputRawUDP.Pq == nil {
			r.InputRawUDP.Pq = nil
		} else {
			r.InputRawUDP.Pq = &tfTypes.InputRawUDPPq{}
			r.InputRawUDP.Pq.CommitFrequency = types.Float64PointerValue(resp.InputRawUDP.Pq.CommitFrequency)
			if resp.InputRawUDP.Pq.Compress != nil {
				r.InputRawUDP.Pq.Compress = types.StringValue(string(*resp.InputRawUDP.Pq.Compress))
			} else {
				r.InputRawUDP.Pq.Compress = types.StringNull()
			}
			r.InputRawUDP.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputRawUDP.Pq.MaxBufferSize)
			r.InputRawUDP.Pq.MaxFileSize = types.StringPointerValue(resp.InputRawUDP.Pq.MaxFileSize)
			r.InputRawUDP.Pq.MaxSize = types.StringPointerValue(resp.InputRawUDP.Pq.MaxSize)
			if resp.InputRawUDP.Pq.Mode != nil {
				r.InputRawUDP.Pq.Mode = types.StringValue(string(*resp.InputRawUDP.Pq.Mode))
			} else {
				r.InputRawUDP.Pq.Mode = types.StringNull()
			}
			r.InputRawUDP.Pq.Path = types.StringPointerValue(resp.InputRawUDP.Pq.Path)
		}
		r.InputRawUDP.PqEnabled = types.BoolPointerValue(resp.InputRawUDP.PqEnabled)
		r.InputRawUDP.SendToRoutes = types.BoolPointerValue(resp.InputRawUDP.SendToRoutes)
		r.InputRawUDP.SingleMsgUDPPackets = types.BoolPointerValue(resp.InputRawUDP.SingleMsgUDPPackets)
		r.InputRawUDP.Streamtags = make([]types.String, 0, len(resp.InputRawUDP.Streamtags))
		for _, v := range resp.InputRawUDP.Streamtags {
			r.InputRawUDP.Streamtags = append(r.InputRawUDP.Streamtags, types.StringValue(v))
		}
		if resp.InputRawUDP.Type != nil {
			r.InputRawUDP.Type = types.StringValue(string(*resp.InputRawUDP.Type))
		} else {
			r.InputRawUDP.Type = types.StringNull()
		}
		r.InputRawUDP.UDPSocketRxBufSize = types.Float64PointerValue(resp.InputRawUDP.UDPSocketRxBufSize)
	}
	if resp.InputS3 != nil {
		r.InputS3 = &tfTypes.InputS3{}
		r.InputS3.AssumeRoleArn = types.StringPointerValue(resp.InputS3.AssumeRoleArn)
		r.InputS3.AssumeRoleExternalID = types.StringPointerValue(resp.InputS3.AssumeRoleExternalID)
		r.InputS3.AwsAccountID = types.StringPointerValue(resp.InputS3.AwsAccountID)
		r.InputS3.AwsAPIKey = types.StringPointerValue(resp.InputS3.AwsAPIKey)
		if resp.InputS3.AwsAuthenticationMethod != nil {
			r.InputS3.AwsAuthenticationMethod = types.StringValue(string(*resp.InputS3.AwsAuthenticationMethod))
		} else {
			r.InputS3.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputS3.AwsSecret = types.StringPointerValue(resp.InputS3.AwsSecret)
		r.InputS3.AwsSecretKey = types.StringPointerValue(resp.InputS3.AwsSecretKey)
		r.InputS3.BreakerRulesets = make([]types.String, 0, len(resp.InputS3.BreakerRulesets))
		for _, v := range resp.InputS3.BreakerRulesets {
			r.InputS3.BreakerRulesets = append(r.InputS3.BreakerRulesets, types.StringValue(v))
		}
		if resp.InputS3.Checkpointing == nil {
			r.InputS3.Checkpointing = nil
		} else {
			r.InputS3.Checkpointing = &tfTypes.InputS3Checkpointing{}
			r.InputS3.Checkpointing.Enabled = types.BoolPointerValue(resp.InputS3.Checkpointing.Enabled)
			r.InputS3.Checkpointing.Retries = types.Float64PointerValue(resp.InputS3.Checkpointing.Retries)
		}
		r.InputS3.Connections = []tfTypes.InputS3Connection{}
		if len(r.InputS3.Connections) > len(resp.InputS3.Connections) {
			r.InputS3.Connections = r.InputS3.Connections[:len(resp.InputS3.Connections)]
		}
		for connectionsCount41, connectionsItem41 := range resp.InputS3.Connections {
			var connections41 tfTypes.InputS3Connection
			connections41.Output = types.StringValue(connectionsItem41.Output)
			connections41.Pipeline = types.StringPointerValue(connectionsItem41.Pipeline)
			if connectionsCount41+1 > len(r.InputS3.Connections) {
				r.InputS3.Connections = append(r.InputS3.Connections, connections41)
			} else {
				r.InputS3.Connections[connectionsCount41].Output = connections41.Output
				r.InputS3.Connections[connectionsCount41].Pipeline = connections41.Pipeline
			}
		}
		r.InputS3.Description = types.StringPointerValue(resp.InputS3.Description)
		r.InputS3.Disabled = types.BoolPointerValue(resp.InputS3.Disabled)
		r.InputS3.DurationSeconds = types.Float64PointerValue(resp.InputS3.DurationSeconds)
		r.InputS3.EnableAssumeRole = types.BoolPointerValue(resp.InputS3.EnableAssumeRole)
		r.InputS3.EnableSQSAssumeRole = types.BoolPointerValue(resp.InputS3.EnableSQSAssumeRole)
		r.InputS3.Encoding = types.StringPointerValue(resp.InputS3.Encoding)
		r.InputS3.Endpoint = types.StringPointerValue(resp.InputS3.Endpoint)
		r.InputS3.Environment = types.StringPointerValue(resp.InputS3.Environment)
		r.InputS3.FileFilter = types.StringPointerValue(resp.InputS3.FileFilter)
		r.InputS3.ID = types.StringPointerValue(resp.InputS3.ID)
		r.InputS3.MaxMessages = types.Float64PointerValue(resp.InputS3.MaxMessages)
		r.InputS3.Metadata = []tfTypes.InputS3Metadatum{}
		if len(r.InputS3.Metadata) > len(resp.InputS3.Metadata) {
			r.InputS3.Metadata = r.InputS3.Metadata[:len(resp.InputS3.Metadata)]
		}
		for metadataCount43, metadataItem43 := range resp.InputS3.Metadata {
			var metadata43 tfTypes.InputS3Metadatum
			metadata43.Name = types.StringValue(metadataItem43.Name)
			metadata43.Value = types.StringValue(metadataItem43.Value)
			if metadataCount43+1 > len(r.InputS3.Metadata) {
				r.InputS3.Metadata = append(r.InputS3.Metadata, metadata43)
			} else {
				r.InputS3.Metadata[metadataCount43].Name = metadata43.Name
				r.InputS3.Metadata[metadataCount43].Value = metadata43.Value
			}
		}
		r.InputS3.NumReceivers = types.Float64PointerValue(resp.InputS3.NumReceivers)
		r.InputS3.ParquetChunkDownloadTimeout = types.Float64PointerValue(resp.InputS3.ParquetChunkDownloadTimeout)
		r.InputS3.ParquetChunkSizeMB = types.Float64PointerValue(resp.InputS3.ParquetChunkSizeMB)
		r.InputS3.Pipeline = types.StringPointerValue(resp.InputS3.Pipeline)
		r.InputS3.PollTimeout = types.Float64PointerValue(resp.InputS3.PollTimeout)
		if resp.InputS3.Pq == nil {
			r.InputS3.Pq = nil
		} else {
			r.InputS3.Pq = &tfTypes.InputS3Pq{}
			r.InputS3.Pq.CommitFrequency = types.Float64PointerValue(resp.InputS3.Pq.CommitFrequency)
			if resp.InputS3.Pq.Compress != nil {
				r.InputS3.Pq.Compress = types.StringValue(string(*resp.InputS3.Pq.Compress))
			} else {
				r.InputS3.Pq.Compress = types.StringNull()
			}
			r.InputS3.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputS3.Pq.MaxBufferSize)
			r.InputS3.Pq.MaxFileSize = types.StringPointerValue(resp.InputS3.Pq.MaxFileSize)
			r.InputS3.Pq.MaxSize = types.StringPointerValue(resp.InputS3.Pq.MaxSize)
			if resp.InputS3.Pq.Mode != nil {
				r.InputS3.Pq.Mode = types.StringValue(string(*resp.InputS3.Pq.Mode))
			} else {
				r.InputS3.Pq.Mode = types.StringNull()
			}
			r.InputS3.Pq.Path = types.StringPointerValue(resp.InputS3.Pq.Path)
		}
		r.InputS3.PqEnabled = types.BoolPointerValue(resp.InputS3.PqEnabled)
		if resp.InputS3.Preprocess == nil {
			r.InputS3.Preprocess = nil
		} else {
			r.InputS3.Preprocess = &tfTypes.InputS3Preprocess{}
			r.InputS3.Preprocess.Args = make([]types.String, 0, len(resp.InputS3.Preprocess.Args))
			for _, v := range resp.InputS3.Preprocess.Args {
				r.InputS3.Preprocess.Args = append(r.InputS3.Preprocess.Args, types.StringValue(v))
			}
			r.InputS3.Preprocess.Command = types.StringPointerValue(resp.InputS3.Preprocess.Command)
			r.InputS3.Preprocess.Disabled = types.BoolPointerValue(resp.InputS3.Preprocess.Disabled)
		}
		r.InputS3.ProcessedTagKey = types.StringPointerValue(resp.InputS3.ProcessedTagKey)
		r.InputS3.ProcessedTagValue = types.StringPointerValue(resp.InputS3.ProcessedTagValue)
		r.InputS3.QueueName = types.StringValue(resp.InputS3.QueueName)
		r.InputS3.Region = types.StringPointerValue(resp.InputS3.Region)
		r.InputS3.RejectUnauthorized = types.BoolPointerValue(resp.InputS3.RejectUnauthorized)
		r.InputS3.ReuseConnections = types.BoolPointerValue(resp.InputS3.ReuseConnections)
		r.InputS3.SendToRoutes = types.BoolPointerValue(resp.InputS3.SendToRoutes)
		if resp.InputS3.SignatureVersion != nil {
			r.InputS3.SignatureVersion = types.StringValue(string(*resp.InputS3.SignatureVersion))
		} else {
			r.InputS3.SignatureVersion = types.StringNull()
		}
		r.InputS3.SkipOnError = types.BoolPointerValue(resp.InputS3.SkipOnError)
		r.InputS3.SocketTimeout = types.Float64PointerValue(resp.InputS3.SocketTimeout)
		r.InputS3.StaleChannelFlushMs = types.Float64PointerValue(resp.InputS3.StaleChannelFlushMs)
		r.InputS3.Streamtags = make([]types.String, 0, len(resp.InputS3.Streamtags))
		for _, v := range resp.InputS3.Streamtags {
			r.InputS3.Streamtags = append(r.InputS3.Streamtags, types.StringValue(v))
		}
		r.InputS3.TagAfterProcessing = types.BoolPointerValue(resp.InputS3.TagAfterProcessing)
		r.InputS3.Type = types.StringValue(string(resp.InputS3.Type))
		r.InputS3.VisibilityTimeout = types.Float64PointerValue(resp.InputS3.VisibilityTimeout)
	}
	if resp.InputS3Inventory != nil {
		r.InputS3Inventory = &tfTypes.InputS3Inventory{}
		r.InputS3Inventory.AssumeRoleArn = types.StringPointerValue(resp.InputS3Inventory.AssumeRoleArn)
		r.InputS3Inventory.AssumeRoleExternalID = types.StringPointerValue(resp.InputS3Inventory.AssumeRoleExternalID)
		r.InputS3Inventory.AwsAccountID = types.StringPointerValue(resp.InputS3Inventory.AwsAccountID)
		r.InputS3Inventory.AwsAPIKey = types.StringPointerValue(resp.InputS3Inventory.AwsAPIKey)
		if resp.InputS3Inventory.AwsAuthenticationMethod != nil {
			r.InputS3Inventory.AwsAuthenticationMethod = types.StringValue(string(*resp.InputS3Inventory.AwsAuthenticationMethod))
		} else {
			r.InputS3Inventory.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputS3Inventory.AwsSecret = types.StringPointerValue(resp.InputS3Inventory.AwsSecret)
		r.InputS3Inventory.AwsSecretKey = types.StringPointerValue(resp.InputS3Inventory.AwsSecretKey)
		r.InputS3Inventory.BreakerRulesets = make([]types.String, 0, len(resp.InputS3Inventory.BreakerRulesets))
		for _, v := range resp.InputS3Inventory.BreakerRulesets {
			r.InputS3Inventory.BreakerRulesets = append(r.InputS3Inventory.BreakerRulesets, types.StringValue(v))
		}
		if resp.InputS3Inventory.Checkpointing == nil {
			r.InputS3Inventory.Checkpointing = nil
		} else {
			r.InputS3Inventory.Checkpointing = &tfTypes.InputS3InventoryCheckpointing{}
			r.InputS3Inventory.Checkpointing.Enabled = types.BoolPointerValue(resp.InputS3Inventory.Checkpointing.Enabled)
			r.InputS3Inventory.Checkpointing.Retries = types.Float64PointerValue(resp.InputS3Inventory.Checkpointing.Retries)
		}
		r.InputS3Inventory.ChecksumSuffix = types.StringPointerValue(resp.InputS3Inventory.ChecksumSuffix)
		r.InputS3Inventory.Connections = []tfTypes.InputS3InventoryConnection{}
		if len(r.InputS3Inventory.Connections) > len(resp.InputS3Inventory.Connections) {
			r.InputS3Inventory.Connections = r.InputS3Inventory.Connections[:len(resp.InputS3Inventory.Connections)]
		}
		for connectionsCount42, connectionsItem42 := range resp.InputS3Inventory.Connections {
			var connections42 tfTypes.InputS3InventoryConnection
			connections42.Output = types.StringValue(connectionsItem42.Output)
			connections42.Pipeline = types.StringPointerValue(connectionsItem42.Pipeline)
			if connectionsCount42+1 > len(r.InputS3Inventory.Connections) {
				r.InputS3Inventory.Connections = append(r.InputS3Inventory.Connections, connections42)
			} else {
				r.InputS3Inventory.Connections[connectionsCount42].Output = connections42.Output
				r.InputS3Inventory.Connections[connectionsCount42].Pipeline = connections42.Pipeline
			}
		}
		r.InputS3Inventory.Description = types.StringPointerValue(resp.InputS3Inventory.Description)
		r.InputS3Inventory.Disabled = types.BoolPointerValue(resp.InputS3Inventory.Disabled)
		r.InputS3Inventory.DurationSeconds = types.Float64PointerValue(resp.InputS3Inventory.DurationSeconds)
		r.InputS3Inventory.EnableAssumeRole = types.BoolPointerValue(resp.InputS3Inventory.EnableAssumeRole)
		r.InputS3Inventory.EnableSQSAssumeRole = types.BoolPointerValue(resp.InputS3Inventory.EnableSQSAssumeRole)
		r.InputS3Inventory.Endpoint = types.StringPointerValue(resp.InputS3Inventory.Endpoint)
		r.InputS3Inventory.Environment = types.StringPointerValue(resp.InputS3Inventory.Environment)
		r.InputS3Inventory.FileFilter = types.StringPointerValue(resp.InputS3Inventory.FileFilter)
		r.InputS3Inventory.ID = types.StringPointerValue(resp.InputS3Inventory.ID)
		r.InputS3Inventory.MaxManifestSizeKB = types.Int64PointerValue(resp.InputS3Inventory.MaxManifestSizeKB)
		r.InputS3Inventory.MaxMessages = types.Float64PointerValue(resp.InputS3Inventory.MaxMessages)
		r.InputS3Inventory.Metadata = []tfTypes.InputS3InventoryMetadatum{}
		if len(r.InputS3Inventory.Metadata) > len(resp.InputS3Inventory.Metadata) {
			r.InputS3Inventory.Metadata = r.InputS3Inventory.Metadata[:len(resp.InputS3Inventory.Metadata)]
		}
		for metadataCount44, metadataItem44 := range resp.InputS3Inventory.Metadata {
			var metadata44 tfTypes.InputS3InventoryMetadatum
			metadata44.Name = types.StringValue(metadataItem44.Name)
			metadata44.Value = types.StringValue(metadataItem44.Value)
			if metadataCount44+1 > len(r.InputS3Inventory.Metadata) {
				r.InputS3Inventory.Metadata = append(r.InputS3Inventory.Metadata, metadata44)
			} else {
				r.InputS3Inventory.Metadata[metadataCount44].Name = metadata44.Name
				r.InputS3Inventory.Metadata[metadataCount44].Value = metadata44.Value
			}
		}
		r.InputS3Inventory.NumReceivers = types.Float64PointerValue(resp.InputS3Inventory.NumReceivers)
		r.InputS3Inventory.ParquetChunkDownloadTimeout = types.Float64PointerValue(resp.InputS3Inventory.ParquetChunkDownloadTimeout)
		r.InputS3Inventory.ParquetChunkSizeMB = types.Float64PointerValue(resp.InputS3Inventory.ParquetChunkSizeMB)
		r.InputS3Inventory.Pipeline = types.StringPointerValue(resp.InputS3Inventory.Pipeline)
		r.InputS3Inventory.PollTimeout = types.Float64PointerValue(resp.InputS3Inventory.PollTimeout)
		if resp.InputS3Inventory.Pq == nil {
			r.InputS3Inventory.Pq = nil
		} else {
			r.InputS3Inventory.Pq = &tfTypes.InputS3InventoryPq{}
			r.InputS3Inventory.Pq.CommitFrequency = types.Float64PointerValue(resp.InputS3Inventory.Pq.CommitFrequency)
			if resp.InputS3Inventory.Pq.Compress != nil {
				r.InputS3Inventory.Pq.Compress = types.StringValue(string(*resp.InputS3Inventory.Pq.Compress))
			} else {
				r.InputS3Inventory.Pq.Compress = types.StringNull()
			}
			r.InputS3Inventory.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputS3Inventory.Pq.MaxBufferSize)
			r.InputS3Inventory.Pq.MaxFileSize = types.StringPointerValue(resp.InputS3Inventory.Pq.MaxFileSize)
			r.InputS3Inventory.Pq.MaxSize = types.StringPointerValue(resp.InputS3Inventory.Pq.MaxSize)
			if resp.InputS3Inventory.Pq.Mode != nil {
				r.InputS3Inventory.Pq.Mode = types.StringValue(string(*resp.InputS3Inventory.Pq.Mode))
			} else {
				r.InputS3Inventory.Pq.Mode = types.StringNull()
			}
			r.InputS3Inventory.Pq.Path = types.StringPointerValue(resp.InputS3Inventory.Pq.Path)
		}
		r.InputS3Inventory.PqEnabled = types.BoolPointerValue(resp.InputS3Inventory.PqEnabled)
		if resp.InputS3Inventory.Preprocess == nil {
			r.InputS3Inventory.Preprocess = nil
		} else {
			r.InputS3Inventory.Preprocess = &tfTypes.InputS3InventoryPreprocess{}
			r.InputS3Inventory.Preprocess.Args = make([]types.String, 0, len(resp.InputS3Inventory.Preprocess.Args))
			for _, v := range resp.InputS3Inventory.Preprocess.Args {
				r.InputS3Inventory.Preprocess.Args = append(r.InputS3Inventory.Preprocess.Args, types.StringValue(v))
			}
			r.InputS3Inventory.Preprocess.Command = types.StringPointerValue(resp.InputS3Inventory.Preprocess.Command)
			r.InputS3Inventory.Preprocess.Disabled = types.BoolPointerValue(resp.InputS3Inventory.Preprocess.Disabled)
		}
		r.InputS3Inventory.ProcessedTagKey = types.StringPointerValue(resp.InputS3Inventory.ProcessedTagKey)
		r.InputS3Inventory.ProcessedTagValue = types.StringPointerValue(resp.InputS3Inventory.ProcessedTagValue)
		r.InputS3Inventory.QueueName = types.StringValue(resp.InputS3Inventory.QueueName)
		r.InputS3Inventory.Region = types.StringPointerValue(resp.InputS3Inventory.Region)
		r.InputS3Inventory.RejectUnauthorized = types.BoolPointerValue(resp.InputS3Inventory.RejectUnauthorized)
		r.InputS3Inventory.ReuseConnections = types.BoolPointerValue(resp.InputS3Inventory.ReuseConnections)
		r.InputS3Inventory.SendToRoutes = types.BoolPointerValue(resp.InputS3Inventory.SendToRoutes)
		if resp.InputS3Inventory.SignatureVersion != nil {
			r.InputS3Inventory.SignatureVersion = types.StringValue(string(*resp.InputS3Inventory.SignatureVersion))
		} else {
			r.InputS3Inventory.SignatureVersion = types.StringNull()
		}
		r.InputS3Inventory.SkipOnError = types.BoolPointerValue(resp.InputS3Inventory.SkipOnError)
		r.InputS3Inventory.SocketTimeout = types.Float64PointerValue(resp.InputS3Inventory.SocketTimeout)
		r.InputS3Inventory.StaleChannelFlushMs = types.Float64PointerValue(resp.InputS3Inventory.StaleChannelFlushMs)
		r.InputS3Inventory.Streamtags = make([]types.String, 0, len(resp.InputS3Inventory.Streamtags))
		for _, v := range resp.InputS3Inventory.Streamtags {
			r.InputS3Inventory.Streamtags = append(r.InputS3Inventory.Streamtags, types.StringValue(v))
		}
		if resp.InputS3Inventory.TagAfterProcessing != nil {
			r.InputS3Inventory.TagAfterProcessing = types.StringValue(string(*resp.InputS3Inventory.TagAfterProcessing))
		} else {
			r.InputS3Inventory.TagAfterProcessing = types.StringNull()
		}
		r.InputS3Inventory.Type = types.StringValue(string(resp.InputS3Inventory.Type))
		r.InputS3Inventory.ValidateInventoryFiles = types.BoolPointerValue(resp.InputS3Inventory.ValidateInventoryFiles)
		r.InputS3Inventory.VisibilityTimeout = types.Float64PointerValue(resp.InputS3Inventory.VisibilityTimeout)
	}
	if resp.InputSecurityLake != nil {
		r.InputSecurityLake = &tfTypes.InputSecurityLake{}
		r.InputSecurityLake.AssumeRoleArn = types.StringPointerValue(resp.InputSecurityLake.AssumeRoleArn)
		r.InputSecurityLake.AssumeRoleExternalID = types.StringPointerValue(resp.InputSecurityLake.AssumeRoleExternalID)
		r.InputSecurityLake.AwsAccountID = types.StringPointerValue(resp.InputSecurityLake.AwsAccountID)
		r.InputSecurityLake.AwsAPIKey = types.StringPointerValue(resp.InputSecurityLake.AwsAPIKey)
		if resp.InputSecurityLake.AwsAuthenticationMethod != nil {
			r.InputSecurityLake.AwsAuthenticationMethod = types.StringValue(string(*resp.InputSecurityLake.AwsAuthenticationMethod))
		} else {
			r.InputSecurityLake.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputSecurityLake.AwsSecret = types.StringPointerValue(resp.InputSecurityLake.AwsSecret)
		r.InputSecurityLake.AwsSecretKey = types.StringPointerValue(resp.InputSecurityLake.AwsSecretKey)
		r.InputSecurityLake.BreakerRulesets = make([]types.String, 0, len(resp.InputSecurityLake.BreakerRulesets))
		for _, v := range resp.InputSecurityLake.BreakerRulesets {
			r.InputSecurityLake.BreakerRulesets = append(r.InputSecurityLake.BreakerRulesets, types.StringValue(v))
		}
		if resp.InputSecurityLake.Checkpointing == nil {
			r.InputSecurityLake.Checkpointing = nil
		} else {
			r.InputSecurityLake.Checkpointing = &tfTypes.InputSecurityLakeCheckpointing{}
			r.InputSecurityLake.Checkpointing.Enabled = types.BoolPointerValue(resp.InputSecurityLake.Checkpointing.Enabled)
			r.InputSecurityLake.Checkpointing.Retries = types.Float64PointerValue(resp.InputSecurityLake.Checkpointing.Retries)
		}
		r.InputSecurityLake.Connections = []tfTypes.InputSecurityLakeConnection{}
		if len(r.InputSecurityLake.Connections) > len(resp.InputSecurityLake.Connections) {
			r.InputSecurityLake.Connections = r.InputSecurityLake.Connections[:len(resp.InputSecurityLake.Connections)]
		}
		for connectionsCount43, connectionsItem43 := range resp.InputSecurityLake.Connections {
			var connections43 tfTypes.InputSecurityLakeConnection
			connections43.Output = types.StringValue(connectionsItem43.Output)
			connections43.Pipeline = types.StringPointerValue(connectionsItem43.Pipeline)
			if connectionsCount43+1 > len(r.InputSecurityLake.Connections) {
				r.InputSecurityLake.Connections = append(r.InputSecurityLake.Connections, connections43)
			} else {
				r.InputSecurityLake.Connections[connectionsCount43].Output = connections43.Output
				r.InputSecurityLake.Connections[connectionsCount43].Pipeline = connections43.Pipeline
			}
		}
		r.InputSecurityLake.Description = types.StringPointerValue(resp.InputSecurityLake.Description)
		r.InputSecurityLake.Disabled = types.BoolPointerValue(resp.InputSecurityLake.Disabled)
		r.InputSecurityLake.DurationSeconds = types.Float64PointerValue(resp.InputSecurityLake.DurationSeconds)
		r.InputSecurityLake.EnableAssumeRole = types.BoolPointerValue(resp.InputSecurityLake.EnableAssumeRole)
		r.InputSecurityLake.EnableSQSAssumeRole = types.BoolPointerValue(resp.InputSecurityLake.EnableSQSAssumeRole)
		r.InputSecurityLake.Encoding = types.StringPointerValue(resp.InputSecurityLake.Encoding)
		r.InputSecurityLake.Endpoint = types.StringPointerValue(resp.InputSecurityLake.Endpoint)
		r.InputSecurityLake.Environment = types.StringPointerValue(resp.InputSecurityLake.Environment)
		r.InputSecurityLake.FileFilter = types.StringPointerValue(resp.InputSecurityLake.FileFilter)
		r.InputSecurityLake.ID = types.StringPointerValue(resp.InputSecurityLake.ID)
		r.InputSecurityLake.MaxMessages = types.Float64PointerValue(resp.InputSecurityLake.MaxMessages)
		r.InputSecurityLake.Metadata = []tfTypes.InputSecurityLakeMetadatum{}
		if len(r.InputSecurityLake.Metadata) > len(resp.InputSecurityLake.Metadata) {
			r.InputSecurityLake.Metadata = r.InputSecurityLake.Metadata[:len(resp.InputSecurityLake.Metadata)]
		}
		for metadataCount45, metadataItem45 := range resp.InputSecurityLake.Metadata {
			var metadata45 tfTypes.InputSecurityLakeMetadatum
			metadata45.Name = types.StringValue(metadataItem45.Name)
			metadata45.Value = types.StringValue(metadataItem45.Value)
			if metadataCount45+1 > len(r.InputSecurityLake.Metadata) {
				r.InputSecurityLake.Metadata = append(r.InputSecurityLake.Metadata, metadata45)
			} else {
				r.InputSecurityLake.Metadata[metadataCount45].Name = metadata45.Name
				r.InputSecurityLake.Metadata[metadataCount45].Value = metadata45.Value
			}
		}
		r.InputSecurityLake.NumReceivers = types.Float64PointerValue(resp.InputSecurityLake.NumReceivers)
		r.InputSecurityLake.ParquetChunkDownloadTimeout = types.Float64PointerValue(resp.InputSecurityLake.ParquetChunkDownloadTimeout)
		r.InputSecurityLake.ParquetChunkSizeMB = types.Float64PointerValue(resp.InputSecurityLake.ParquetChunkSizeMB)
		r.InputSecurityLake.Pipeline = types.StringPointerValue(resp.InputSecurityLake.Pipeline)
		r.InputSecurityLake.PollTimeout = types.Float64PointerValue(resp.InputSecurityLake.PollTimeout)
		if resp.InputSecurityLake.Pq == nil {
			r.InputSecurityLake.Pq = nil
		} else {
			r.InputSecurityLake.Pq = &tfTypes.InputSecurityLakePq{}
			r.InputSecurityLake.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSecurityLake.Pq.CommitFrequency)
			if resp.InputSecurityLake.Pq.Compress != nil {
				r.InputSecurityLake.Pq.Compress = types.StringValue(string(*resp.InputSecurityLake.Pq.Compress))
			} else {
				r.InputSecurityLake.Pq.Compress = types.StringNull()
			}
			r.InputSecurityLake.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSecurityLake.Pq.MaxBufferSize)
			r.InputSecurityLake.Pq.MaxFileSize = types.StringPointerValue(resp.InputSecurityLake.Pq.MaxFileSize)
			r.InputSecurityLake.Pq.MaxSize = types.StringPointerValue(resp.InputSecurityLake.Pq.MaxSize)
			if resp.InputSecurityLake.Pq.Mode != nil {
				r.InputSecurityLake.Pq.Mode = types.StringValue(string(*resp.InputSecurityLake.Pq.Mode))
			} else {
				r.InputSecurityLake.Pq.Mode = types.StringNull()
			}
			r.InputSecurityLake.Pq.Path = types.StringPointerValue(resp.InputSecurityLake.Pq.Path)
		}
		r.InputSecurityLake.PqEnabled = types.BoolPointerValue(resp.InputSecurityLake.PqEnabled)
		if resp.InputSecurityLake.Preprocess == nil {
			r.InputSecurityLake.Preprocess = nil
		} else {
			r.InputSecurityLake.Preprocess = &tfTypes.InputSecurityLakePreprocess{}
			r.InputSecurityLake.Preprocess.Args = make([]types.String, 0, len(resp.InputSecurityLake.Preprocess.Args))
			for _, v := range resp.InputSecurityLake.Preprocess.Args {
				r.InputSecurityLake.Preprocess.Args = append(r.InputSecurityLake.Preprocess.Args, types.StringValue(v))
			}
			r.InputSecurityLake.Preprocess.Command = types.StringPointerValue(resp.InputSecurityLake.Preprocess.Command)
			r.InputSecurityLake.Preprocess.Disabled = types.BoolPointerValue(resp.InputSecurityLake.Preprocess.Disabled)
		}
		r.InputSecurityLake.ProcessedTagKey = types.StringPointerValue(resp.InputSecurityLake.ProcessedTagKey)
		r.InputSecurityLake.ProcessedTagValue = types.StringPointerValue(resp.InputSecurityLake.ProcessedTagValue)
		r.InputSecurityLake.QueueName = types.StringValue(resp.InputSecurityLake.QueueName)
		r.InputSecurityLake.Region = types.StringPointerValue(resp.InputSecurityLake.Region)
		r.InputSecurityLake.RejectUnauthorized = types.BoolPointerValue(resp.InputSecurityLake.RejectUnauthorized)
		r.InputSecurityLake.ReuseConnections = types.BoolPointerValue(resp.InputSecurityLake.ReuseConnections)
		r.InputSecurityLake.SendToRoutes = types.BoolPointerValue(resp.InputSecurityLake.SendToRoutes)
		if resp.InputSecurityLake.SignatureVersion != nil {
			r.InputSecurityLake.SignatureVersion = types.StringValue(string(*resp.InputSecurityLake.SignatureVersion))
		} else {
			r.InputSecurityLake.SignatureVersion = types.StringNull()
		}
		r.InputSecurityLake.SkipOnError = types.BoolPointerValue(resp.InputSecurityLake.SkipOnError)
		r.InputSecurityLake.SocketTimeout = types.Float64PointerValue(resp.InputSecurityLake.SocketTimeout)
		r.InputSecurityLake.StaleChannelFlushMs = types.Float64PointerValue(resp.InputSecurityLake.StaleChannelFlushMs)
		r.InputSecurityLake.Streamtags = make([]types.String, 0, len(resp.InputSecurityLake.Streamtags))
		for _, v := range resp.InputSecurityLake.Streamtags {
			r.InputSecurityLake.Streamtags = append(r.InputSecurityLake.Streamtags, types.StringValue(v))
		}
		if resp.InputSecurityLake.TagAfterProcessing != nil {
			r.InputSecurityLake.TagAfterProcessing = types.StringValue(string(*resp.InputSecurityLake.TagAfterProcessing))
		} else {
			r.InputSecurityLake.TagAfterProcessing = types.StringNull()
		}
		r.InputSecurityLake.Type = types.StringValue(string(resp.InputSecurityLake.Type))
		r.InputSecurityLake.VisibilityTimeout = types.Float64PointerValue(resp.InputSecurityLake.VisibilityTimeout)
	}
	if resp.InputSnmp != nil {
		r.InputSnmp = &tfTypes.InputSnmp{}
		r.InputSnmp.BestEffortParsing = types.BoolPointerValue(resp.InputSnmp.BestEffortParsing)
		r.InputSnmp.Connections = []tfTypes.InputSnmpConnection{}
		if len(r.InputSnmp.Connections) > len(resp.InputSnmp.Connections) {
			r.InputSnmp.Connections = r.InputSnmp.Connections[:len(resp.InputSnmp.Connections)]
		}
		for connectionsCount44, connectionsItem44 := range resp.InputSnmp.Connections {
			var connections44 tfTypes.InputSnmpConnection
			connections44.Output = types.StringValue(connectionsItem44.Output)
			connections44.Pipeline = types.StringPointerValue(connectionsItem44.Pipeline)
			if connectionsCount44+1 > len(r.InputSnmp.Connections) {
				r.InputSnmp.Connections = append(r.InputSnmp.Connections, connections44)
			} else {
				r.InputSnmp.Connections[connectionsCount44].Output = connections44.Output
				r.InputSnmp.Connections[connectionsCount44].Pipeline = connections44.Pipeline
			}
		}
		r.InputSnmp.Description = types.StringPointerValue(resp.InputSnmp.Description)
		r.InputSnmp.Disabled = types.BoolPointerValue(resp.InputSnmp.Disabled)
		r.InputSnmp.Environment = types.StringPointerValue(resp.InputSnmp.Environment)
		r.InputSnmp.Host = types.StringPointerValue(resp.InputSnmp.Host)
		r.InputSnmp.ID = types.StringPointerValue(resp.InputSnmp.ID)
		r.InputSnmp.IPWhitelistRegex = types.StringPointerValue(resp.InputSnmp.IPWhitelistRegex)
		r.InputSnmp.MaxBufferSize = types.Float64PointerValue(resp.InputSnmp.MaxBufferSize)
		r.InputSnmp.Metadata = []tfTypes.InputSnmpMetadatum{}
		if len(r.InputSnmp.Metadata) > len(resp.InputSnmp.Metadata) {
			r.InputSnmp.Metadata = r.InputSnmp.Metadata[:len(resp.InputSnmp.Metadata)]
		}
		for metadataCount46, metadataItem46 := range resp.InputSnmp.Metadata {
			var metadata46 tfTypes.InputSnmpMetadatum
			metadata46.Name = types.StringValue(metadataItem46.Name)
			metadata46.Value = types.StringValue(metadataItem46.Value)
			if metadataCount46+1 > len(r.InputSnmp.Metadata) {
				r.InputSnmp.Metadata = append(r.InputSnmp.Metadata, metadata46)
			} else {
				r.InputSnmp.Metadata[metadataCount46].Name = metadata46.Name
				r.InputSnmp.Metadata[metadataCount46].Value = metadata46.Value
			}
		}
		r.InputSnmp.Pipeline = types.StringPointerValue(resp.InputSnmp.Pipeline)
		r.InputSnmp.Port = types.Float64PointerValue(resp.InputSnmp.Port)
		if resp.InputSnmp.Pq == nil {
			r.InputSnmp.Pq = nil
		} else {
			r.InputSnmp.Pq = &tfTypes.InputSnmpPq{}
			r.InputSnmp.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSnmp.Pq.CommitFrequency)
			if resp.InputSnmp.Pq.Compress != nil {
				r.InputSnmp.Pq.Compress = types.StringValue(string(*resp.InputSnmp.Pq.Compress))
			} else {
				r.InputSnmp.Pq.Compress = types.StringNull()
			}
			r.InputSnmp.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSnmp.Pq.MaxBufferSize)
			r.InputSnmp.Pq.MaxFileSize = types.StringPointerValue(resp.InputSnmp.Pq.MaxFileSize)
			r.InputSnmp.Pq.MaxSize = types.StringPointerValue(resp.InputSnmp.Pq.MaxSize)
			if resp.InputSnmp.Pq.Mode != nil {
				r.InputSnmp.Pq.Mode = types.StringValue(string(*resp.InputSnmp.Pq.Mode))
			} else {
				r.InputSnmp.Pq.Mode = types.StringNull()
			}
			r.InputSnmp.Pq.Path = types.StringPointerValue(resp.InputSnmp.Pq.Path)
		}
		r.InputSnmp.PqEnabled = types.BoolPointerValue(resp.InputSnmp.PqEnabled)
		r.InputSnmp.SendToRoutes = types.BoolPointerValue(resp.InputSnmp.SendToRoutes)
		if resp.InputSnmp.SnmpV3Auth == nil {
			r.InputSnmp.SnmpV3Auth = nil
		} else {
			r.InputSnmp.SnmpV3Auth = &tfTypes.SNMPv3Authentication{}
			r.InputSnmp.SnmpV3Auth.AllowUnmatchedTrap = types.BoolPointerValue(resp.InputSnmp.SnmpV3Auth.AllowUnmatchedTrap)
			r.InputSnmp.SnmpV3Auth.V3AuthEnabled = types.BoolPointerValue(resp.InputSnmp.SnmpV3Auth.V3AuthEnabled)
			r.InputSnmp.SnmpV3Auth.V3Users = []tfTypes.V3User{}
			if len(r.InputSnmp.SnmpV3Auth.V3Users) > len(resp.InputSnmp.SnmpV3Auth.V3Users) {
				r.InputSnmp.SnmpV3Auth.V3Users = r.InputSnmp.SnmpV3Auth.V3Users[:len(resp.InputSnmp.SnmpV3Auth.V3Users)]
			}
			for v3UsersCount, v3UsersItem := range resp.InputSnmp.SnmpV3Auth.V3Users {
				var v3Users tfTypes.V3User
				if v3UsersItem.AuthKey == nil {
					v3Users.AuthKey = types.StringNull()
				} else {
					authKeyResult, _ := json.Marshal(v3UsersItem.AuthKey)
					v3Users.AuthKey = types.StringValue(string(authKeyResult))
				}
				if v3UsersItem.AuthProtocol != nil {
					v3Users.AuthProtocol = types.StringValue(string(*v3UsersItem.AuthProtocol))
				} else {
					v3Users.AuthProtocol = types.StringNull()
				}
				v3Users.Name = types.StringValue(v3UsersItem.Name)
				if v3UsersItem.PrivProtocol == nil {
					v3Users.PrivProtocol = types.StringNull()
				} else {
					privProtocolResult, _ := json.Marshal(v3UsersItem.PrivProtocol)
					v3Users.PrivProtocol = types.StringValue(string(privProtocolResult))
				}
				if v3UsersCount+1 > len(r.InputSnmp.SnmpV3Auth.V3Users) {
					r.InputSnmp.SnmpV3Auth.V3Users = append(r.InputSnmp.SnmpV3Auth.V3Users, v3Users)
				} else {
					r.InputSnmp.SnmpV3Auth.V3Users[v3UsersCount].AuthKey = v3Users.AuthKey
					r.InputSnmp.SnmpV3Auth.V3Users[v3UsersCount].AuthProtocol = v3Users.AuthProtocol
					r.InputSnmp.SnmpV3Auth.V3Users[v3UsersCount].Name = v3Users.Name
					r.InputSnmp.SnmpV3Auth.V3Users[v3UsersCount].PrivProtocol = v3Users.PrivProtocol
				}
			}
		}
		r.InputSnmp.Streamtags = make([]types.String, 0, len(resp.InputSnmp.Streamtags))
		for _, v := range resp.InputSnmp.Streamtags {
			r.InputSnmp.Streamtags = append(r.InputSnmp.Streamtags, types.StringValue(v))
		}
		if resp.InputSnmp.Type != nil {
			r.InputSnmp.Type = types.StringValue(string(*resp.InputSnmp.Type))
		} else {
			r.InputSnmp.Type = types.StringNull()
		}
		r.InputSnmp.UDPSocketRxBufSize = types.Float64PointerValue(resp.InputSnmp.UDPSocketRxBufSize)
		r.InputSnmp.VarbindsWithTypes = types.BoolPointerValue(resp.InputSnmp.VarbindsWithTypes)
	}
	if resp.InputSplunk != nil {
		r.InputSplunk = &tfTypes.InputSplunk{}
		r.InputSplunk.AuthTokens = []tfTypes.InputSplunkAuthToken{}
		if len(r.InputSplunk.AuthTokens) > len(resp.InputSplunk.AuthTokens) {
			r.InputSplunk.AuthTokens = r.InputSplunk.AuthTokens[:len(resp.InputSplunk.AuthTokens)]
		}
		for authTokensCount, authTokensItem := range resp.InputSplunk.AuthTokens {
			var authTokens tfTypes.InputSplunkAuthToken
			authTokens.Description = types.StringPointerValue(authTokensItem.Description)
			authTokens.Token = types.StringValue(authTokensItem.Token)
			if authTokensCount+1 > len(r.InputSplunk.AuthTokens) {
				r.InputSplunk.AuthTokens = append(r.InputSplunk.AuthTokens, authTokens)
			} else {
				r.InputSplunk.AuthTokens[authTokensCount].Description = authTokens.Description
				r.InputSplunk.AuthTokens[authTokensCount].Token = authTokens.Token
			}
		}
		r.InputSplunk.BreakerRulesets = make([]types.String, 0, len(resp.InputSplunk.BreakerRulesets))
		for _, v := range resp.InputSplunk.BreakerRulesets {
			r.InputSplunk.BreakerRulesets = append(r.InputSplunk.BreakerRulesets, types.StringValue(v))
		}
		if resp.InputSplunk.Compress != nil {
			r.InputSplunk.Compress = types.StringValue(string(*resp.InputSplunk.Compress))
		} else {
			r.InputSplunk.Compress = types.StringNull()
		}
		r.InputSplunk.Connections = []tfTypes.InputSplunkConnection{}
		if len(r.InputSplunk.Connections) > len(resp.InputSplunk.Connections) {
			r.InputSplunk.Connections = r.InputSplunk.Connections[:len(resp.InputSplunk.Connections)]
		}
		for connectionsCount45, connectionsItem45 := range resp.InputSplunk.Connections {
			var connections45 tfTypes.InputSplunkConnection
			connections45.Output = types.StringValue(connectionsItem45.Output)
			connections45.Pipeline = types.StringPointerValue(connectionsItem45.Pipeline)
			if connectionsCount45+1 > len(r.InputSplunk.Connections) {
				r.InputSplunk.Connections = append(r.InputSplunk.Connections, connections45)
			} else {
				r.InputSplunk.Connections[connectionsCount45].Output = connections45.Output
				r.InputSplunk.Connections[connectionsCount45].Pipeline = connections45.Pipeline
			}
		}
		r.InputSplunk.Description = types.StringPointerValue(resp.InputSplunk.Description)
		r.InputSplunk.Disabled = types.BoolPointerValue(resp.InputSplunk.Disabled)
		r.InputSplunk.DropControlFields = types.BoolPointerValue(resp.InputSplunk.DropControlFields)
		r.InputSplunk.EnableProxyHeader = types.BoolPointerValue(resp.InputSplunk.EnableProxyHeader)
		r.InputSplunk.Environment = types.StringPointerValue(resp.InputSplunk.Environment)
		r.InputSplunk.ExtractMetrics = types.BoolPointerValue(resp.InputSplunk.ExtractMetrics)
		r.InputSplunk.Host = types.StringPointerValue(resp.InputSplunk.Host)
		r.InputSplunk.ID = types.StringPointerValue(resp.InputSplunk.ID)
		r.InputSplunk.IPWhitelistRegex = types.StringPointerValue(resp.InputSplunk.IPWhitelistRegex)
		r.InputSplunk.MaxActiveCxn = types.Float64PointerValue(resp.InputSplunk.MaxActiveCxn)
		if resp.InputSplunk.MaxS2Sversion != nil {
			r.InputSplunk.MaxS2Sversion = types.StringValue(string(*resp.InputSplunk.MaxS2Sversion))
		} else {
			r.InputSplunk.MaxS2Sversion = types.StringNull()
		}
		r.InputSplunk.Metadata = []tfTypes.InputSplunkMetadatum{}
		if len(r.InputSplunk.Metadata) > len(resp.InputSplunk.Metadata) {
			r.InputSplunk.Metadata = r.InputSplunk.Metadata[:len(resp.InputSplunk.Metadata)]
		}
		for metadataCount47, metadataItem47 := range resp.InputSplunk.Metadata {
			var metadata47 tfTypes.InputSplunkMetadatum
			metadata47.Name = types.StringValue(metadataItem47.Name)
			metadata47.Value = types.StringValue(metadataItem47.Value)
			if metadataCount47+1 > len(r.InputSplunk.Metadata) {
				r.InputSplunk.Metadata = append(r.InputSplunk.Metadata, metadata47)
			} else {
				r.InputSplunk.Metadata[metadataCount47].Name = metadata47.Name
				r.InputSplunk.Metadata[metadataCount47].Value = metadata47.Value
			}
		}
		r.InputSplunk.Pipeline = types.StringPointerValue(resp.InputSplunk.Pipeline)
		r.InputSplunk.Port = types.Float64Value(resp.InputSplunk.Port)
		if resp.InputSplunk.Pq == nil {
			r.InputSplunk.Pq = nil
		} else {
			r.InputSplunk.Pq = &tfTypes.InputSplunkPq{}
			r.InputSplunk.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSplunk.Pq.CommitFrequency)
			if resp.InputSplunk.Pq.Compress != nil {
				r.InputSplunk.Pq.Compress = types.StringValue(string(*resp.InputSplunk.Pq.Compress))
			} else {
				r.InputSplunk.Pq.Compress = types.StringNull()
			}
			r.InputSplunk.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSplunk.Pq.MaxBufferSize)
			r.InputSplunk.Pq.MaxFileSize = types.StringPointerValue(resp.InputSplunk.Pq.MaxFileSize)
			r.InputSplunk.Pq.MaxSize = types.StringPointerValue(resp.InputSplunk.Pq.MaxSize)
			if resp.InputSplunk.Pq.Mode != nil {
				r.InputSplunk.Pq.Mode = types.StringValue(string(*resp.InputSplunk.Pq.Mode))
			} else {
				r.InputSplunk.Pq.Mode = types.StringNull()
			}
			r.InputSplunk.Pq.Path = types.StringPointerValue(resp.InputSplunk.Pq.Path)
		}
		r.InputSplunk.PqEnabled = types.BoolPointerValue(resp.InputSplunk.PqEnabled)
		r.InputSplunk.SendToRoutes = types.BoolPointerValue(resp.InputSplunk.SendToRoutes)
		r.InputSplunk.SocketEndingMaxWait = types.Float64PointerValue(resp.InputSplunk.SocketEndingMaxWait)
		r.InputSplunk.SocketIdleTimeout = types.Float64PointerValue(resp.InputSplunk.SocketIdleTimeout)
		r.InputSplunk.SocketMaxLifespan = types.Float64PointerValue(resp.InputSplunk.SocketMaxLifespan)
		r.InputSplunk.StaleChannelFlushMs = types.Float64PointerValue(resp.InputSplunk.StaleChannelFlushMs)
		r.InputSplunk.Streamtags = make([]types.String, 0, len(resp.InputSplunk.Streamtags))
		for _, v := range resp.InputSplunk.Streamtags {
			r.InputSplunk.Streamtags = append(r.InputSplunk.Streamtags, types.StringValue(v))
		}
		if resp.InputSplunk.TLS == nil {
			r.InputSplunk.TLS = nil
		} else {
			r.InputSplunk.TLS = &tfTypes.InputSplunkTLSSettingsServerSide{}
			r.InputSplunk.TLS.CaPath = types.StringPointerValue(resp.InputSplunk.TLS.CaPath)
			r.InputSplunk.TLS.CertificateName = types.StringPointerValue(resp.InputSplunk.TLS.CertificateName)
			r.InputSplunk.TLS.CertPath = types.StringPointerValue(resp.InputSplunk.TLS.CertPath)
			if resp.InputSplunk.TLS.CommonNameRegex == nil {
				r.InputSplunk.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult16, _ := json.Marshal(resp.InputSplunk.TLS.CommonNameRegex)
				r.InputSplunk.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult16))
			}
			r.InputSplunk.TLS.Disabled = types.BoolPointerValue(resp.InputSplunk.TLS.Disabled)
			if resp.InputSplunk.TLS.MaxVersion != nil {
				r.InputSplunk.TLS.MaxVersion = types.StringValue(string(*resp.InputSplunk.TLS.MaxVersion))
			} else {
				r.InputSplunk.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputSplunk.TLS.MinVersion != nil {
				r.InputSplunk.TLS.MinVersion = types.StringValue(string(*resp.InputSplunk.TLS.MinVersion))
			} else {
				r.InputSplunk.TLS.MinVersion = types.StringNull()
			}
			r.InputSplunk.TLS.Passphrase = types.StringPointerValue(resp.InputSplunk.TLS.Passphrase)
			r.InputSplunk.TLS.PrivKeyPath = types.StringPointerValue(resp.InputSplunk.TLS.PrivKeyPath)
			if resp.InputSplunk.TLS.RejectUnauthorized == nil {
				r.InputSplunk.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult16, _ := json.Marshal(resp.InputSplunk.TLS.RejectUnauthorized)
				r.InputSplunk.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult16))
			}
			r.InputSplunk.TLS.RequestCert = types.BoolPointerValue(resp.InputSplunk.TLS.RequestCert)
		}
		if resp.InputSplunk.Type != nil {
			r.InputSplunk.Type = types.StringValue(string(*resp.InputSplunk.Type))
		} else {
			r.InputSplunk.Type = types.StringNull()
		}
		r.InputSplunk.UseFwdTimezone = types.BoolPointerValue(resp.InputSplunk.UseFwdTimezone)
	}
	if resp.InputSplunkHec != nil {
		r.InputSplunkHec = &tfTypes.InputSplunkHec{}
		r.InputSplunkHec.AccessControlAllowHeaders = make([]types.String, 0, len(resp.InputSplunkHec.AccessControlAllowHeaders))
		for _, v := range resp.InputSplunkHec.AccessControlAllowHeaders {
			r.InputSplunkHec.AccessControlAllowHeaders = append(r.InputSplunkHec.AccessControlAllowHeaders, types.StringValue(v))
		}
		r.InputSplunkHec.AccessControlAllowOrigin = make([]types.String, 0, len(resp.InputSplunkHec.AccessControlAllowOrigin))
		for _, v := range resp.InputSplunkHec.AccessControlAllowOrigin {
			r.InputSplunkHec.AccessControlAllowOrigin = append(r.InputSplunkHec.AccessControlAllowOrigin, types.StringValue(v))
		}
		r.InputSplunkHec.ActivityLogSampleRate = types.Float64PointerValue(resp.InputSplunkHec.ActivityLogSampleRate)
		r.InputSplunkHec.AllowedIndexes = make([]types.String, 0, len(resp.InputSplunkHec.AllowedIndexes))
		for _, v := range resp.InputSplunkHec.AllowedIndexes {
			r.InputSplunkHec.AllowedIndexes = append(r.InputSplunkHec.AllowedIndexes, types.StringValue(v))
		}
		r.InputSplunkHec.AuthTokens = []tfTypes.InputSplunkHecAuthToken{}
		if len(r.InputSplunkHec.AuthTokens) > len(resp.InputSplunkHec.AuthTokens) {
			r.InputSplunkHec.AuthTokens = r.InputSplunkHec.AuthTokens[:len(resp.InputSplunkHec.AuthTokens)]
		}
		for authTokensCount1, authTokensItem1 := range resp.InputSplunkHec.AuthTokens {
			var authTokens1 tfTypes.InputSplunkHecAuthToken
			authTokens1.AllowedIndexesAtToken = make([]types.String, 0, len(authTokensItem1.AllowedIndexesAtToken))
			for _, v := range authTokensItem1.AllowedIndexesAtToken {
				authTokens1.AllowedIndexesAtToken = append(authTokens1.AllowedIndexesAtToken, types.StringValue(v))
			}
			if authTokensItem1.AuthType != nil {
				authTokens1.AuthType = types.StringValue(string(*authTokensItem1.AuthType))
			} else {
				authTokens1.AuthType = types.StringNull()
			}
			authTokens1.Description = types.StringPointerValue(authTokensItem1.Description)
			authTokens1.Enabled = types.BoolPointerValue(authTokensItem1.Enabled)
			authTokens1.Metadata = []tfTypes.InputSplunkHecAuthTokenMetadatum{}
			for metadataCount48, metadataItem48 := range authTokensItem1.Metadata {
				var metadata48 tfTypes.InputSplunkHecAuthTokenMetadatum
				metadata48.Name = types.StringValue(metadataItem48.Name)
				metadata48.Value = types.StringValue(metadataItem48.Value)
				if metadataCount48+1 > len(authTokens1.Metadata) {
					authTokens1.Metadata = append(authTokens1.Metadata, metadata48)
				} else {
					authTokens1.Metadata[metadataCount48].Name = metadata48.Name
					authTokens1.Metadata[metadataCount48].Value = metadata48.Value
				}
			}
			tokenResult, _ := json.Marshal(authTokensItem1.Token)
			authTokens1.Token = types.StringValue(string(tokenResult))
			if authTokensItem1.TokenSecret == nil {
				authTokens1.TokenSecret = types.StringNull()
			} else {
				tokenSecretResult, _ := json.Marshal(authTokensItem1.TokenSecret)
				authTokens1.TokenSecret = types.StringValue(string(tokenSecretResult))
			}
			if authTokensCount1+1 > len(r.InputSplunkHec.AuthTokens) {
				r.InputSplunkHec.AuthTokens = append(r.InputSplunkHec.AuthTokens, authTokens1)
			} else {
				r.InputSplunkHec.AuthTokens[authTokensCount1].AllowedIndexesAtToken = authTokens1.AllowedIndexesAtToken
				r.InputSplunkHec.AuthTokens[authTokensCount1].AuthType = authTokens1.AuthType
				r.InputSplunkHec.AuthTokens[authTokensCount1].Description = authTokens1.Description
				r.InputSplunkHec.AuthTokens[authTokensCount1].Enabled = authTokens1.Enabled
				r.InputSplunkHec.AuthTokens[authTokensCount1].Metadata = authTokens1.Metadata
				r.InputSplunkHec.AuthTokens[authTokensCount1].Token = authTokens1.Token
				r.InputSplunkHec.AuthTokens[authTokensCount1].TokenSecret = authTokens1.TokenSecret
			}
		}
		r.InputSplunkHec.BreakerRulesets = make([]types.String, 0, len(resp.InputSplunkHec.BreakerRulesets))
		for _, v := range resp.InputSplunkHec.BreakerRulesets {
			r.InputSplunkHec.BreakerRulesets = append(r.InputSplunkHec.BreakerRulesets, types.StringValue(v))
		}
		r.InputSplunkHec.CaptureHeaders = types.BoolPointerValue(resp.InputSplunkHec.CaptureHeaders)
		r.InputSplunkHec.Connections = []tfTypes.InputSplunkHecConnection{}
		if len(r.InputSplunkHec.Connections) > len(resp.InputSplunkHec.Connections) {
			r.InputSplunkHec.Connections = r.InputSplunkHec.Connections[:len(resp.InputSplunkHec.Connections)]
		}
		for connectionsCount46, connectionsItem46 := range resp.InputSplunkHec.Connections {
			var connections46 tfTypes.InputSplunkHecConnection
			connections46.Output = types.StringValue(connectionsItem46.Output)
			connections46.Pipeline = types.StringPointerValue(connectionsItem46.Pipeline)
			if connectionsCount46+1 > len(r.InputSplunkHec.Connections) {
				r.InputSplunkHec.Connections = append(r.InputSplunkHec.Connections, connections46)
			} else {
				r.InputSplunkHec.Connections[connectionsCount46].Output = connections46.Output
				r.InputSplunkHec.Connections[connectionsCount46].Pipeline = connections46.Pipeline
			}
		}
		r.InputSplunkHec.Description = types.StringPointerValue(resp.InputSplunkHec.Description)
		r.InputSplunkHec.Disabled = types.BoolPointerValue(resp.InputSplunkHec.Disabled)
		r.InputSplunkHec.DropControlFields = types.BoolPointerValue(resp.InputSplunkHec.DropControlFields)
		r.InputSplunkHec.EmitTokenMetrics = types.BoolPointerValue(resp.InputSplunkHec.EmitTokenMetrics)
		if resp.InputSplunkHec.EnableHealthCheck == nil {
			r.InputSplunkHec.EnableHealthCheck = types.StringNull()
		} else {
			enableHealthCheckResult, _ := json.Marshal(resp.InputSplunkHec.EnableHealthCheck)
			r.InputSplunkHec.EnableHealthCheck = types.StringValue(string(enableHealthCheckResult))
		}
		r.InputSplunkHec.EnableProxyHeader = types.BoolPointerValue(resp.InputSplunkHec.EnableProxyHeader)
		r.InputSplunkHec.Environment = types.StringPointerValue(resp.InputSplunkHec.Environment)
		r.InputSplunkHec.ExtractMetrics = types.BoolPointerValue(resp.InputSplunkHec.ExtractMetrics)
		r.InputSplunkHec.Host = types.StringPointerValue(resp.InputSplunkHec.Host)
		r.InputSplunkHec.ID = types.StringPointerValue(resp.InputSplunkHec.ID)
		r.InputSplunkHec.IPAllowlistRegex = types.StringPointerValue(resp.InputSplunkHec.IPAllowlistRegex)
		r.InputSplunkHec.IPDenylistRegex = types.StringPointerValue(resp.InputSplunkHec.IPDenylistRegex)
		r.InputSplunkHec.KeepAliveTimeout = types.Float64PointerValue(resp.InputSplunkHec.KeepAliveTimeout)
		r.InputSplunkHec.MaxActiveReq = types.Float64PointerValue(resp.InputSplunkHec.MaxActiveReq)
		r.InputSplunkHec.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputSplunkHec.MaxRequestsPerSocket)
		r.InputSplunkHec.Metadata = []tfTypes.InputSplunkHecMetadatum{}
		if len(r.InputSplunkHec.Metadata) > len(resp.InputSplunkHec.Metadata) {
			r.InputSplunkHec.Metadata = r.InputSplunkHec.Metadata[:len(resp.InputSplunkHec.Metadata)]
		}
		for metadataCount49, metadataItem49 := range resp.InputSplunkHec.Metadata {
			var metadata49 tfTypes.InputSplunkHecMetadatum
			metadata49.Name = types.StringValue(metadataItem49.Name)
			metadata49.Value = types.StringValue(metadataItem49.Value)
			if metadataCount49+1 > len(r.InputSplunkHec.Metadata) {
				r.InputSplunkHec.Metadata = append(r.InputSplunkHec.Metadata, metadata49)
			} else {
				r.InputSplunkHec.Metadata[metadataCount49].Name = metadata49.Name
				r.InputSplunkHec.Metadata[metadataCount49].Value = metadata49.Value
			}
		}
		r.InputSplunkHec.Pipeline = types.StringPointerValue(resp.InputSplunkHec.Pipeline)
		r.InputSplunkHec.Port = types.Float64Value(resp.InputSplunkHec.Port)
		if resp.InputSplunkHec.Pq == nil {
			r.InputSplunkHec.Pq = nil
		} else {
			r.InputSplunkHec.Pq = &tfTypes.InputSplunkHecPq{}
			r.InputSplunkHec.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSplunkHec.Pq.CommitFrequency)
			if resp.InputSplunkHec.Pq.Compress != nil {
				r.InputSplunkHec.Pq.Compress = types.StringValue(string(*resp.InputSplunkHec.Pq.Compress))
			} else {
				r.InputSplunkHec.Pq.Compress = types.StringNull()
			}
			r.InputSplunkHec.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSplunkHec.Pq.MaxBufferSize)
			r.InputSplunkHec.Pq.MaxFileSize = types.StringPointerValue(resp.InputSplunkHec.Pq.MaxFileSize)
			r.InputSplunkHec.Pq.MaxSize = types.StringPointerValue(resp.InputSplunkHec.Pq.MaxSize)
			if resp.InputSplunkHec.Pq.Mode != nil {
				r.InputSplunkHec.Pq.Mode = types.StringValue(string(*resp.InputSplunkHec.Pq.Mode))
			} else {
				r.InputSplunkHec.Pq.Mode = types.StringNull()
			}
			r.InputSplunkHec.Pq.Path = types.StringPointerValue(resp.InputSplunkHec.Pq.Path)
		}
		r.InputSplunkHec.PqEnabled = types.BoolPointerValue(resp.InputSplunkHec.PqEnabled)
		r.InputSplunkHec.RequestTimeout = types.Float64PointerValue(resp.InputSplunkHec.RequestTimeout)
		r.InputSplunkHec.SendToRoutes = types.BoolPointerValue(resp.InputSplunkHec.SendToRoutes)
		r.InputSplunkHec.SocketTimeout = types.Float64PointerValue(resp.InputSplunkHec.SocketTimeout)
		r.InputSplunkHec.SplunkHecAcks = types.BoolPointerValue(resp.InputSplunkHec.SplunkHecAcks)
		r.InputSplunkHec.SplunkHecAPI = types.StringPointerValue(resp.InputSplunkHec.SplunkHecAPI)
		r.InputSplunkHec.StaleChannelFlushMs = types.Float64PointerValue(resp.InputSplunkHec.StaleChannelFlushMs)
		r.InputSplunkHec.Streamtags = make([]types.String, 0, len(resp.InputSplunkHec.Streamtags))
		for _, v := range resp.InputSplunkHec.Streamtags {
			r.InputSplunkHec.Streamtags = append(r.InputSplunkHec.Streamtags, types.StringValue(v))
		}
		if resp.InputSplunkHec.TLS == nil {
			r.InputSplunkHec.TLS = nil
		} else {
			r.InputSplunkHec.TLS = &tfTypes.InputSplunkHecTLSSettingsServerSide{}
			r.InputSplunkHec.TLS.CaPath = types.StringPointerValue(resp.InputSplunkHec.TLS.CaPath)
			r.InputSplunkHec.TLS.CertificateName = types.StringPointerValue(resp.InputSplunkHec.TLS.CertificateName)
			r.InputSplunkHec.TLS.CertPath = types.StringPointerValue(resp.InputSplunkHec.TLS.CertPath)
			if resp.InputSplunkHec.TLS.CommonNameRegex == nil {
				r.InputSplunkHec.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult17, _ := json.Marshal(resp.InputSplunkHec.TLS.CommonNameRegex)
				r.InputSplunkHec.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult17))
			}
			r.InputSplunkHec.TLS.Disabled = types.BoolPointerValue(resp.InputSplunkHec.TLS.Disabled)
			if resp.InputSplunkHec.TLS.MaxVersion != nil {
				r.InputSplunkHec.TLS.MaxVersion = types.StringValue(string(*resp.InputSplunkHec.TLS.MaxVersion))
			} else {
				r.InputSplunkHec.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputSplunkHec.TLS.MinVersion != nil {
				r.InputSplunkHec.TLS.MinVersion = types.StringValue(string(*resp.InputSplunkHec.TLS.MinVersion))
			} else {
				r.InputSplunkHec.TLS.MinVersion = types.StringNull()
			}
			r.InputSplunkHec.TLS.Passphrase = types.StringPointerValue(resp.InputSplunkHec.TLS.Passphrase)
			r.InputSplunkHec.TLS.PrivKeyPath = types.StringPointerValue(resp.InputSplunkHec.TLS.PrivKeyPath)
			if resp.InputSplunkHec.TLS.RejectUnauthorized == nil {
				r.InputSplunkHec.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult17, _ := json.Marshal(resp.InputSplunkHec.TLS.RejectUnauthorized)
				r.InputSplunkHec.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult17))
			}
			r.InputSplunkHec.TLS.RequestCert = types.BoolPointerValue(resp.InputSplunkHec.TLS.RequestCert)
		}
		if resp.InputSplunkHec.Type != nil {
			r.InputSplunkHec.Type = types.StringValue(string(*resp.InputSplunkHec.Type))
		} else {
			r.InputSplunkHec.Type = types.StringNull()
		}
		r.InputSplunkHec.UseFwdTimezone = types.BoolPointerValue(resp.InputSplunkHec.UseFwdTimezone)
	}
	if resp.InputSplunkSearch != nil {
		r.InputSplunkSearch = &tfTypes.InputSplunkSearch{}
		r.InputSplunkSearch.AuthHeaderExpr = types.StringPointerValue(resp.InputSplunkSearch.AuthHeaderExpr)
		if resp.InputSplunkSearch.AuthType != nil {
			r.InputSplunkSearch.AuthType = types.StringValue(string(*resp.InputSplunkSearch.AuthType))
		} else {
			r.InputSplunkSearch.AuthType = types.StringNull()
		}
		r.InputSplunkSearch.BreakerRulesets = make([]types.String, 0, len(resp.InputSplunkSearch.BreakerRulesets))
		for _, v := range resp.InputSplunkSearch.BreakerRulesets {
			r.InputSplunkSearch.BreakerRulesets = append(r.InputSplunkSearch.BreakerRulesets, types.StringValue(v))
		}
		r.InputSplunkSearch.Connections = []tfTypes.InputSplunkSearchConnection{}
		if len(r.InputSplunkSearch.Connections) > len(resp.InputSplunkSearch.Connections) {
			r.InputSplunkSearch.Connections = r.InputSplunkSearch.Connections[:len(resp.InputSplunkSearch.Connections)]
		}
		for connectionsCount47, connectionsItem47 := range resp.InputSplunkSearch.Connections {
			var connections47 tfTypes.InputSplunkSearchConnection
			connections47.Output = types.StringValue(connectionsItem47.Output)
			connections47.Pipeline = types.StringPointerValue(connectionsItem47.Pipeline)
			if connectionsCount47+1 > len(r.InputSplunkSearch.Connections) {
				r.InputSplunkSearch.Connections = append(r.InputSplunkSearch.Connections, connections47)
			} else {
				r.InputSplunkSearch.Connections[connectionsCount47].Output = connections47.Output
				r.InputSplunkSearch.Connections[connectionsCount47].Pipeline = connections47.Pipeline
			}
		}
		r.InputSplunkSearch.CredentialsSecret = types.StringPointerValue(resp.InputSplunkSearch.CredentialsSecret)
		r.InputSplunkSearch.CronSchedule = types.StringPointerValue(resp.InputSplunkSearch.CronSchedule)
		r.InputSplunkSearch.Description = types.StringPointerValue(resp.InputSplunkSearch.Description)
		r.InputSplunkSearch.Disabled = types.BoolPointerValue(resp.InputSplunkSearch.Disabled)
		r.InputSplunkSearch.Earliest = types.StringPointerValue(resp.InputSplunkSearch.Earliest)
		r.InputSplunkSearch.Encoding = types.StringPointerValue(resp.InputSplunkSearch.Encoding)
		r.InputSplunkSearch.Endpoint = types.StringPointerValue(resp.InputSplunkSearch.Endpoint)
		r.InputSplunkSearch.EndpointHeaders = []tfTypes.EndpointHeader{}
		if len(r.InputSplunkSearch.EndpointHeaders) > len(resp.InputSplunkSearch.EndpointHeaders) {
			r.InputSplunkSearch.EndpointHeaders = r.InputSplunkSearch.EndpointHeaders[:len(resp.InputSplunkSearch.EndpointHeaders)]
		}
		for endpointHeadersCount, endpointHeadersItem := range resp.InputSplunkSearch.EndpointHeaders {
			var endpointHeaders tfTypes.EndpointHeader
			endpointHeaders.Name = types.StringValue(endpointHeadersItem.Name)
			endpointHeaders.Value = types.StringValue(endpointHeadersItem.Value)
			if endpointHeadersCount+1 > len(r.InputSplunkSearch.EndpointHeaders) {
				r.InputSplunkSearch.EndpointHeaders = append(r.InputSplunkSearch.EndpointHeaders, endpointHeaders)
			} else {
				r.InputSplunkSearch.EndpointHeaders[endpointHeadersCount].Name = endpointHeaders.Name
				r.InputSplunkSearch.EndpointHeaders[endpointHeadersCount].Value = endpointHeaders.Value
			}
		}
		r.InputSplunkSearch.EndpointParams = []tfTypes.EndpointParam{}
		if len(r.InputSplunkSearch.EndpointParams) > len(resp.InputSplunkSearch.EndpointParams) {
			r.InputSplunkSearch.EndpointParams = r.InputSplunkSearch.EndpointParams[:len(resp.InputSplunkSearch.EndpointParams)]
		}
		for endpointParamsCount, endpointParamsItem := range resp.InputSplunkSearch.EndpointParams {
			var endpointParams tfTypes.EndpointParam
			endpointParams.Name = types.StringValue(endpointParamsItem.Name)
			endpointParams.Value = types.StringValue(endpointParamsItem.Value)
			if endpointParamsCount+1 > len(r.InputSplunkSearch.EndpointParams) {
				r.InputSplunkSearch.EndpointParams = append(r.InputSplunkSearch.EndpointParams, endpointParams)
			} else {
				r.InputSplunkSearch.EndpointParams[endpointParamsCount].Name = endpointParams.Name
				r.InputSplunkSearch.EndpointParams[endpointParamsCount].Value = endpointParams.Value
			}
		}
		r.InputSplunkSearch.Environment = types.StringPointerValue(resp.InputSplunkSearch.Environment)
		r.InputSplunkSearch.ID = types.StringPointerValue(resp.InputSplunkSearch.ID)
		r.InputSplunkSearch.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.InputSplunkSearch.IgnoreGroupJobsLimit)
		r.InputSplunkSearch.JobTimeout = types.StringPointerValue(resp.InputSplunkSearch.JobTimeout)
		r.InputSplunkSearch.KeepAliveTime = types.Float64PointerValue(resp.InputSplunkSearch.KeepAliveTime)
		r.InputSplunkSearch.Latest = types.StringPointerValue(resp.InputSplunkSearch.Latest)
		r.InputSplunkSearch.LoginURL = types.StringPointerValue(resp.InputSplunkSearch.LoginURL)
		if resp.InputSplunkSearch.LogLevel != nil {
			r.InputSplunkSearch.LogLevel = types.StringValue(string(*resp.InputSplunkSearch.LogLevel))
		} else {
			r.InputSplunkSearch.LogLevel = types.StringNull()
		}
		r.InputSplunkSearch.MaxMissedKeepAlives = types.Float64PointerValue(resp.InputSplunkSearch.MaxMissedKeepAlives)
		r.InputSplunkSearch.Metadata = []tfTypes.InputSplunkSearchMetadatum{}
		if len(r.InputSplunkSearch.Metadata) > len(resp.InputSplunkSearch.Metadata) {
			r.InputSplunkSearch.Metadata = r.InputSplunkSearch.Metadata[:len(resp.InputSplunkSearch.Metadata)]
		}
		for metadataCount50, metadataItem50 := range resp.InputSplunkSearch.Metadata {
			var metadata50 tfTypes.InputSplunkSearchMetadatum
			metadata50.Name = types.StringValue(metadataItem50.Name)
			metadata50.Value = types.StringValue(metadataItem50.Value)
			if metadataCount50+1 > len(r.InputSplunkSearch.Metadata) {
				r.InputSplunkSearch.Metadata = append(r.InputSplunkSearch.Metadata, metadata50)
			} else {
				r.InputSplunkSearch.Metadata[metadataCount50].Name = metadata50.Name
				r.InputSplunkSearch.Metadata[metadataCount50].Value = metadata50.Value
			}
		}
		r.InputSplunkSearch.OauthHeaders = []tfTypes.InputSplunkSearchOauthHeader{}
		if len(r.InputSplunkSearch.OauthHeaders) > len(resp.InputSplunkSearch.OauthHeaders) {
			r.InputSplunkSearch.OauthHeaders = r.InputSplunkSearch.OauthHeaders[:len(resp.InputSplunkSearch.OauthHeaders)]
		}
		for oauthHeadersCount7, oauthHeadersItem7 := range resp.InputSplunkSearch.OauthHeaders {
			var oauthHeaders7 tfTypes.InputSplunkSearchOauthHeader
			oauthHeaders7.Name = types.StringValue(oauthHeadersItem7.Name)
			oauthHeaders7.Value = types.StringValue(oauthHeadersItem7.Value)
			if oauthHeadersCount7+1 > len(r.InputSplunkSearch.OauthHeaders) {
				r.InputSplunkSearch.OauthHeaders = append(r.InputSplunkSearch.OauthHeaders, oauthHeaders7)
			} else {
				r.InputSplunkSearch.OauthHeaders[oauthHeadersCount7].Name = oauthHeaders7.Name
				r.InputSplunkSearch.OauthHeaders[oauthHeadersCount7].Value = oauthHeaders7.Value
			}
		}
		r.InputSplunkSearch.OauthParams = []tfTypes.InputSplunkSearchOauthParam{}
		if len(r.InputSplunkSearch.OauthParams) > len(resp.InputSplunkSearch.OauthParams) {
			r.InputSplunkSearch.OauthParams = r.InputSplunkSearch.OauthParams[:len(resp.InputSplunkSearch.OauthParams)]
		}
		for oauthParamsCount7, oauthParamsItem7 := range resp.InputSplunkSearch.OauthParams {
			var oauthParams7 tfTypes.InputSplunkSearchOauthParam
			oauthParams7.Name = types.StringValue(oauthParamsItem7.Name)
			oauthParams7.Value = types.StringValue(oauthParamsItem7.Value)
			if oauthParamsCount7+1 > len(r.InputSplunkSearch.OauthParams) {
				r.InputSplunkSearch.OauthParams = append(r.InputSplunkSearch.OauthParams, oauthParams7)
			} else {
				r.InputSplunkSearch.OauthParams[oauthParamsCount7].Name = oauthParams7.Name
				r.InputSplunkSearch.OauthParams[oauthParamsCount7].Value = oauthParams7.Value
			}
		}
		if resp.InputSplunkSearch.OutputMode != nil {
			r.InputSplunkSearch.OutputMode = types.StringValue(string(*resp.InputSplunkSearch.OutputMode))
		} else {
			r.InputSplunkSearch.OutputMode = types.StringNull()
		}
		r.InputSplunkSearch.Password = types.StringPointerValue(resp.InputSplunkSearch.Password)
		r.InputSplunkSearch.Pipeline = types.StringPointerValue(resp.InputSplunkSearch.Pipeline)
		if resp.InputSplunkSearch.Pq == nil {
			r.InputSplunkSearch.Pq = nil
		} else {
			r.InputSplunkSearch.Pq = &tfTypes.InputSplunkSearchPq{}
			r.InputSplunkSearch.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSplunkSearch.Pq.CommitFrequency)
			if resp.InputSplunkSearch.Pq.Compress != nil {
				r.InputSplunkSearch.Pq.Compress = types.StringValue(string(*resp.InputSplunkSearch.Pq.Compress))
			} else {
				r.InputSplunkSearch.Pq.Compress = types.StringNull()
			}
			r.InputSplunkSearch.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSplunkSearch.Pq.MaxBufferSize)
			r.InputSplunkSearch.Pq.MaxFileSize = types.StringPointerValue(resp.InputSplunkSearch.Pq.MaxFileSize)
			r.InputSplunkSearch.Pq.MaxSize = types.StringPointerValue(resp.InputSplunkSearch.Pq.MaxSize)
			if resp.InputSplunkSearch.Pq.Mode != nil {
				r.InputSplunkSearch.Pq.Mode = types.StringValue(string(*resp.InputSplunkSearch.Pq.Mode))
			} else {
				r.InputSplunkSearch.Pq.Mode = types.StringNull()
			}
			r.InputSplunkSearch.Pq.Path = types.StringPointerValue(resp.InputSplunkSearch.Pq.Path)
		}
		r.InputSplunkSearch.PqEnabled = types.BoolPointerValue(resp.InputSplunkSearch.PqEnabled)
		r.InputSplunkSearch.RejectUnauthorized = types.BoolPointerValue(resp.InputSplunkSearch.RejectUnauthorized)
		r.InputSplunkSearch.RequestTimeout = types.Float64PointerValue(resp.InputSplunkSearch.RequestTimeout)
		if resp.InputSplunkSearch.RetryRules == nil {
			r.InputSplunkSearch.RetryRules = nil
		} else {
			r.InputSplunkSearch.RetryRules = &tfTypes.InputSplunkSearchRetryRules{}
			r.InputSplunkSearch.RetryRules.Codes = make([]types.Float64, 0, len(resp.InputSplunkSearch.RetryRules.Codes))
			for _, v := range resp.InputSplunkSearch.RetryRules.Codes {
				r.InputSplunkSearch.RetryRules.Codes = append(r.InputSplunkSearch.RetryRules.Codes, types.Float64Value(v))
			}
			r.InputSplunkSearch.RetryRules.EnableHeader = types.BoolPointerValue(resp.InputSplunkSearch.RetryRules.EnableHeader)
			r.InputSplunkSearch.RetryRules.Interval = types.Float64PointerValue(resp.InputSplunkSearch.RetryRules.Interval)
			r.InputSplunkSearch.RetryRules.Limit = types.Float64PointerValue(resp.InputSplunkSearch.RetryRules.Limit)
			r.InputSplunkSearch.RetryRules.Multiplier = types.Float64PointerValue(resp.InputSplunkSearch.RetryRules.Multiplier)
			r.InputSplunkSearch.RetryRules.RetryConnectReset = types.BoolPointerValue(resp.InputSplunkSearch.RetryRules.RetryConnectReset)
			r.InputSplunkSearch.RetryRules.RetryConnectTimeout = types.BoolPointerValue(resp.InputSplunkSearch.RetryRules.RetryConnectTimeout)
			if resp.InputSplunkSearch.RetryRules.Type != nil {
				r.InputSplunkSearch.RetryRules.Type = types.StringValue(string(*resp.InputSplunkSearch.RetryRules.Type))
			} else {
				r.InputSplunkSearch.RetryRules.Type = types.StringNull()
			}
		}
		r.InputSplunkSearch.Search = types.StringValue(resp.InputSplunkSearch.Search)
		r.InputSplunkSearch.SearchHead = types.StringPointerValue(resp.InputSplunkSearch.SearchHead)
		r.InputSplunkSearch.Secret = types.StringPointerValue(resp.InputSplunkSearch.Secret)
		r.InputSplunkSearch.SecretParamName = types.StringPointerValue(resp.InputSplunkSearch.SecretParamName)
		r.InputSplunkSearch.SendToRoutes = types.BoolPointerValue(resp.InputSplunkSearch.SendToRoutes)
		r.InputSplunkSearch.StaleChannelFlushMs = types.Float64PointerValue(resp.InputSplunkSearch.StaleChannelFlushMs)
		r.InputSplunkSearch.Streamtags = make([]types.String, 0, len(resp.InputSplunkSearch.Streamtags))
		for _, v := range resp.InputSplunkSearch.Streamtags {
			r.InputSplunkSearch.Streamtags = append(r.InputSplunkSearch.Streamtags, types.StringValue(v))
		}
		r.InputSplunkSearch.TextSecret = types.StringPointerValue(resp.InputSplunkSearch.TextSecret)
		r.InputSplunkSearch.Token = types.StringPointerValue(resp.InputSplunkSearch.Token)
		r.InputSplunkSearch.TokenAttributeName = types.StringPointerValue(resp.InputSplunkSearch.TokenAttributeName)
		r.InputSplunkSearch.TokenTimeoutSecs = types.Float64PointerValue(resp.InputSplunkSearch.TokenTimeoutSecs)
		r.InputSplunkSearch.TTL = types.StringPointerValue(resp.InputSplunkSearch.TTL)
		if resp.InputSplunkSearch.Type != nil {
			r.InputSplunkSearch.Type = types.StringValue(string(*resp.InputSplunkSearch.Type))
		} else {
			r.InputSplunkSearch.Type = types.StringNull()
		}
		r.InputSplunkSearch.Username = types.StringPointerValue(resp.InputSplunkSearch.Username)
		r.InputSplunkSearch.UseRoundRobinDNS = types.BoolPointerValue(resp.InputSplunkSearch.UseRoundRobinDNS)
	}
	if resp.InputSqs != nil {
		r.InputSqs = &tfTypes.InputSqs{}
		r.InputSqs.AssumeRoleArn = types.StringPointerValue(resp.InputSqs.AssumeRoleArn)
		r.InputSqs.AssumeRoleExternalID = types.StringPointerValue(resp.InputSqs.AssumeRoleExternalID)
		r.InputSqs.AwsAccountID = types.StringPointerValue(resp.InputSqs.AwsAccountID)
		r.InputSqs.AwsAPIKey = types.StringPointerValue(resp.InputSqs.AwsAPIKey)
		if resp.InputSqs.AwsAuthenticationMethod != nil {
			r.InputSqs.AwsAuthenticationMethod = types.StringValue(string(*resp.InputSqs.AwsAuthenticationMethod))
		} else {
			r.InputSqs.AwsAuthenticationMethod = types.StringNull()
		}
		r.InputSqs.AwsSecret = types.StringPointerValue(resp.InputSqs.AwsSecret)
		r.InputSqs.AwsSecretKey = types.StringPointerValue(resp.InputSqs.AwsSecretKey)
		r.InputSqs.Connections = []tfTypes.InputSqsConnection{}
		if len(r.InputSqs.Connections) > len(resp.InputSqs.Connections) {
			r.InputSqs.Connections = r.InputSqs.Connections[:len(resp.InputSqs.Connections)]
		}
		for connectionsCount48, connectionsItem48 := range resp.InputSqs.Connections {
			var connections48 tfTypes.InputSqsConnection
			connections48.Output = types.StringValue(connectionsItem48.Output)
			connections48.Pipeline = types.StringPointerValue(connectionsItem48.Pipeline)
			if connectionsCount48+1 > len(r.InputSqs.Connections) {
				r.InputSqs.Connections = append(r.InputSqs.Connections, connections48)
			} else {
				r.InputSqs.Connections[connectionsCount48].Output = connections48.Output
				r.InputSqs.Connections[connectionsCount48].Pipeline = connections48.Pipeline
			}
		}
		r.InputSqs.CreateQueue = types.BoolPointerValue(resp.InputSqs.CreateQueue)
		r.InputSqs.Description = types.StringPointerValue(resp.InputSqs.Description)
		r.InputSqs.Disabled = types.BoolPointerValue(resp.InputSqs.Disabled)
		r.InputSqs.DurationSeconds = types.Float64PointerValue(resp.InputSqs.DurationSeconds)
		r.InputSqs.EnableAssumeRole = types.BoolPointerValue(resp.InputSqs.EnableAssumeRole)
		r.InputSqs.Endpoint = types.StringPointerValue(resp.InputSqs.Endpoint)
		r.InputSqs.Environment = types.StringPointerValue(resp.InputSqs.Environment)
		r.InputSqs.ID = types.StringPointerValue(resp.InputSqs.ID)
		r.InputSqs.MaxMessages = types.Float64PointerValue(resp.InputSqs.MaxMessages)
		r.InputSqs.Metadata = []tfTypes.InputSqsMetadatum{}
		if len(r.InputSqs.Metadata) > len(resp.InputSqs.Metadata) {
			r.InputSqs.Metadata = r.InputSqs.Metadata[:len(resp.InputSqs.Metadata)]
		}
		for metadataCount51, metadataItem51 := range resp.InputSqs.Metadata {
			var metadata51 tfTypes.InputSqsMetadatum
			metadata51.Name = types.StringValue(metadataItem51.Name)
			metadata51.Value = types.StringValue(metadataItem51.Value)
			if metadataCount51+1 > len(r.InputSqs.Metadata) {
				r.InputSqs.Metadata = append(r.InputSqs.Metadata, metadata51)
			} else {
				r.InputSqs.Metadata[metadataCount51].Name = metadata51.Name
				r.InputSqs.Metadata[metadataCount51].Value = metadata51.Value
			}
		}
		r.InputSqs.NumReceivers = types.Float64PointerValue(resp.InputSqs.NumReceivers)
		r.InputSqs.Pipeline = types.StringPointerValue(resp.InputSqs.Pipeline)
		r.InputSqs.PollTimeout = types.Float64PointerValue(resp.InputSqs.PollTimeout)
		if resp.InputSqs.Pq == nil {
			r.InputSqs.Pq = nil
		} else {
			r.InputSqs.Pq = &tfTypes.InputSqsPq{}
			r.InputSqs.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSqs.Pq.CommitFrequency)
			if resp.InputSqs.Pq.Compress != nil {
				r.InputSqs.Pq.Compress = types.StringValue(string(*resp.InputSqs.Pq.Compress))
			} else {
				r.InputSqs.Pq.Compress = types.StringNull()
			}
			r.InputSqs.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSqs.Pq.MaxBufferSize)
			r.InputSqs.Pq.MaxFileSize = types.StringPointerValue(resp.InputSqs.Pq.MaxFileSize)
			r.InputSqs.Pq.MaxSize = types.StringPointerValue(resp.InputSqs.Pq.MaxSize)
			if resp.InputSqs.Pq.Mode != nil {
				r.InputSqs.Pq.Mode = types.StringValue(string(*resp.InputSqs.Pq.Mode))
			} else {
				r.InputSqs.Pq.Mode = types.StringNull()
			}
			r.InputSqs.Pq.Path = types.StringPointerValue(resp.InputSqs.Pq.Path)
		}
		r.InputSqs.PqEnabled = types.BoolPointerValue(resp.InputSqs.PqEnabled)
		r.InputSqs.QueueName = types.StringValue(resp.InputSqs.QueueName)
		if resp.InputSqs.QueueType != nil {
			r.InputSqs.QueueType = types.StringValue(string(*resp.InputSqs.QueueType))
		} else {
			r.InputSqs.QueueType = types.StringNull()
		}
		r.InputSqs.Region = types.StringPointerValue(resp.InputSqs.Region)
		r.InputSqs.RejectUnauthorized = types.BoolPointerValue(resp.InputSqs.RejectUnauthorized)
		r.InputSqs.ReuseConnections = types.BoolPointerValue(resp.InputSqs.ReuseConnections)
		r.InputSqs.SendToRoutes = types.BoolPointerValue(resp.InputSqs.SendToRoutes)
		if resp.InputSqs.SignatureVersion != nil {
			r.InputSqs.SignatureVersion = types.StringValue(string(*resp.InputSqs.SignatureVersion))
		} else {
			r.InputSqs.SignatureVersion = types.StringNull()
		}
		r.InputSqs.Streamtags = make([]types.String, 0, len(resp.InputSqs.Streamtags))
		for _, v := range resp.InputSqs.Streamtags {
			r.InputSqs.Streamtags = append(r.InputSqs.Streamtags, types.StringValue(v))
		}
		if resp.InputSqs.Type != nil {
			r.InputSqs.Type = types.StringValue(string(*resp.InputSqs.Type))
		} else {
			r.InputSqs.Type = types.StringNull()
		}
		r.InputSqs.VisibilityTimeout = types.Float64PointerValue(resp.InputSqs.VisibilityTimeout)
	}
	if resp.InputSyslog != nil {
		r.InputSyslog = &tfTypes.InputSyslog{}
		if resp.InputSyslog.InputSyslogSyslog1 != nil {
			r.InputSyslog.InputSyslogSyslog1 = &tfTypes.InputSyslogSyslog1{}
			r.InputSyslog.InputSyslogSyslog1.AllowNonStandardAppName = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.AllowNonStandardAppName)
			r.InputSyslog.InputSyslogSyslog1.Connections = []tfTypes.InputSyslogConnection1{}
			if len(r.InputSyslog.InputSyslogSyslog1.Connections) > len(resp.InputSyslog.InputSyslogSyslog1.Connections) {
				r.InputSyslog.InputSyslogSyslog1.Connections = r.InputSyslog.InputSyslogSyslog1.Connections[:len(resp.InputSyslog.InputSyslogSyslog1.Connections)]
			}
			for connectionsCount49, connectionsItem49 := range resp.InputSyslog.InputSyslogSyslog1.Connections {
				var connections49 tfTypes.InputSyslogConnection1
				connections49.Output = types.StringValue(connectionsItem49.Output)
				connections49.Pipeline = types.StringPointerValue(connectionsItem49.Pipeline)
				if connectionsCount49+1 > len(r.InputSyslog.InputSyslogSyslog1.Connections) {
					r.InputSyslog.InputSyslogSyslog1.Connections = append(r.InputSyslog.InputSyslogSyslog1.Connections, connections49)
				} else {
					r.InputSyslog.InputSyslogSyslog1.Connections[connectionsCount49].Output = connections49.Output
					r.InputSyslog.InputSyslogSyslog1.Connections[connectionsCount49].Pipeline = connections49.Pipeline
				}
			}
			r.InputSyslog.InputSyslogSyslog1.Description = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.Description)
			r.InputSyslog.InputSyslogSyslog1.Disabled = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.Disabled)
			r.InputSyslog.InputSyslogSyslog1.EnableEnhancedProxyHeaderParsing = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.EnableEnhancedProxyHeaderParsing)
			r.InputSyslog.InputSyslogSyslog1.EnableLoadBalancing = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.EnableLoadBalancing)
			r.InputSyslog.InputSyslogSyslog1.EnableProxyHeader = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.EnableProxyHeader)
			r.InputSyslog.InputSyslogSyslog1.Environment = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.Environment)
			r.InputSyslog.InputSyslogSyslog1.Host = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.Host)
			r.InputSyslog.InputSyslogSyslog1.ID = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.ID)
			r.InputSyslog.InputSyslogSyslog1.InferFraming = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.InferFraming)
			r.InputSyslog.InputSyslogSyslog1.IPWhitelistRegex = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.IPWhitelistRegex)
			r.InputSyslog.InputSyslogSyslog1.KeepFieldsList = make([]types.String, 0, len(resp.InputSyslog.InputSyslogSyslog1.KeepFieldsList))
			for _, v := range resp.InputSyslog.InputSyslogSyslog1.KeepFieldsList {
				r.InputSyslog.InputSyslogSyslog1.KeepFieldsList = append(r.InputSyslog.InputSyslogSyslog1.KeepFieldsList, types.StringValue(v))
			}
			r.InputSyslog.InputSyslogSyslog1.MaxActiveCxn = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.MaxActiveCxn)
			r.InputSyslog.InputSyslogSyslog1.MaxBufferSize = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.MaxBufferSize)
			r.InputSyslog.InputSyslogSyslog1.Metadata = []tfTypes.InputSyslogMetadatum1{}
			if len(r.InputSyslog.InputSyslogSyslog1.Metadata) > len(resp.InputSyslog.InputSyslogSyslog1.Metadata) {
				r.InputSyslog.InputSyslogSyslog1.Metadata = r.InputSyslog.InputSyslogSyslog1.Metadata[:len(resp.InputSyslog.InputSyslogSyslog1.Metadata)]
			}
			for metadataCount52, metadataItem52 := range resp.InputSyslog.InputSyslogSyslog1.Metadata {
				var metadata52 tfTypes.InputSyslogMetadatum1
				metadata52.Name = types.StringValue(metadataItem52.Name)
				metadata52.Value = types.StringValue(metadataItem52.Value)
				if metadataCount52+1 > len(r.InputSyslog.InputSyslogSyslog1.Metadata) {
					r.InputSyslog.InputSyslogSyslog1.Metadata = append(r.InputSyslog.InputSyslogSyslog1.Metadata, metadata52)
				} else {
					r.InputSyslog.InputSyslogSyslog1.Metadata[metadataCount52].Name = metadata52.Name
					r.InputSyslog.InputSyslogSyslog1.Metadata[metadataCount52].Value = metadata52.Value
				}
			}
			r.InputSyslog.InputSyslogSyslog1.OctetCounting = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.OctetCounting)
			r.InputSyslog.InputSyslogSyslog1.Pipeline = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.Pipeline)
			if resp.InputSyslog.InputSyslogSyslog1.Pq == nil {
				r.InputSyslog.InputSyslogSyslog1.Pq = nil
			} else {
				r.InputSyslog.InputSyslogSyslog1.Pq = &tfTypes.InputSyslogPq1{}
				r.InputSyslog.InputSyslogSyslog1.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.Pq.CommitFrequency)
				if resp.InputSyslog.InputSyslogSyslog1.Pq.Compress != nil {
					r.InputSyslog.InputSyslogSyslog1.Pq.Compress = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog1.Pq.Compress))
				} else {
					r.InputSyslog.InputSyslogSyslog1.Pq.Compress = types.StringNull()
				}
				r.InputSyslog.InputSyslogSyslog1.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.Pq.MaxBufferSize)
				r.InputSyslog.InputSyslogSyslog1.Pq.MaxFileSize = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.Pq.MaxFileSize)
				r.InputSyslog.InputSyslogSyslog1.Pq.MaxSize = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.Pq.MaxSize)
				if resp.InputSyslog.InputSyslogSyslog1.Pq.Mode != nil {
					r.InputSyslog.InputSyslogSyslog1.Pq.Mode = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog1.Pq.Mode))
				} else {
					r.InputSyslog.InputSyslogSyslog1.Pq.Mode = types.StringNull()
				}
				r.InputSyslog.InputSyslogSyslog1.Pq.Path = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.Pq.Path)
			}
			r.InputSyslog.InputSyslogSyslog1.PqEnabled = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.PqEnabled)
			r.InputSyslog.InputSyslogSyslog1.SendToRoutes = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.SendToRoutes)
			r.InputSyslog.InputSyslogSyslog1.SingleMsgUDPPackets = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.SingleMsgUDPPackets)
			r.InputSyslog.InputSyslogSyslog1.SocketEndingMaxWait = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.SocketEndingMaxWait)
			r.InputSyslog.InputSyslogSyslog1.SocketIdleTimeout = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.SocketIdleTimeout)
			r.InputSyslog.InputSyslogSyslog1.SocketMaxLifespan = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.SocketMaxLifespan)
			r.InputSyslog.InputSyslogSyslog1.Streamtags = make([]types.String, 0, len(resp.InputSyslog.InputSyslogSyslog1.Streamtags))
			for _, v := range resp.InputSyslog.InputSyslogSyslog1.Streamtags {
				r.InputSyslog.InputSyslogSyslog1.Streamtags = append(r.InputSyslog.InputSyslogSyslog1.Streamtags, types.StringValue(v))
			}
			r.InputSyslog.InputSyslogSyslog1.StrictlyInferOctetCounting = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.StrictlyInferOctetCounting)
			r.InputSyslog.InputSyslogSyslog1.TCPPort = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.TCPPort)
			r.InputSyslog.InputSyslogSyslog1.TimestampTimezone = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.TimestampTimezone)
			if resp.InputSyslog.InputSyslogSyslog1.TLS == nil {
				r.InputSyslog.InputSyslogSyslog1.TLS = nil
			} else {
				r.InputSyslog.InputSyslogSyslog1.TLS = &tfTypes.InputSyslogTLSSettingsServerSide1{}
				r.InputSyslog.InputSyslogSyslog1.TLS.CaPath = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.TLS.CaPath)
				r.InputSyslog.InputSyslogSyslog1.TLS.CertificateName = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.TLS.CertificateName)
				r.InputSyslog.InputSyslogSyslog1.TLS.CertPath = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.TLS.CertPath)
				if resp.InputSyslog.InputSyslogSyslog1.TLS.CommonNameRegex == nil {
					r.InputSyslog.InputSyslogSyslog1.TLS.CommonNameRegex = types.StringNull()
				} else {
					commonNameRegexResult18, _ := json.Marshal(resp.InputSyslog.InputSyslogSyslog1.TLS.CommonNameRegex)
					r.InputSyslog.InputSyslogSyslog1.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult18))
				}
				r.InputSyslog.InputSyslogSyslog1.TLS.Disabled = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.TLS.Disabled)
				if resp.InputSyslog.InputSyslogSyslog1.TLS.MaxVersion != nil {
					r.InputSyslog.InputSyslogSyslog1.TLS.MaxVersion = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog1.TLS.MaxVersion))
				} else {
					r.InputSyslog.InputSyslogSyslog1.TLS.MaxVersion = types.StringNull()
				}
				if resp.InputSyslog.InputSyslogSyslog1.TLS.MinVersion != nil {
					r.InputSyslog.InputSyslogSyslog1.TLS.MinVersion = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog1.TLS.MinVersion))
				} else {
					r.InputSyslog.InputSyslogSyslog1.TLS.MinVersion = types.StringNull()
				}
				r.InputSyslog.InputSyslogSyslog1.TLS.Passphrase = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.TLS.Passphrase)
				r.InputSyslog.InputSyslogSyslog1.TLS.PrivKeyPath = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog1.TLS.PrivKeyPath)
				if resp.InputSyslog.InputSyslogSyslog1.TLS.RejectUnauthorized == nil {
					r.InputSyslog.InputSyslogSyslog1.TLS.RejectUnauthorized = types.StringNull()
				} else {
					rejectUnauthorizedResult18, _ := json.Marshal(resp.InputSyslog.InputSyslogSyslog1.TLS.RejectUnauthorized)
					r.InputSyslog.InputSyslogSyslog1.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult18))
				}
				r.InputSyslog.InputSyslogSyslog1.TLS.RequestCert = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog1.TLS.RequestCert)
			}
			r.InputSyslog.InputSyslogSyslog1.Type = types.StringValue(string(resp.InputSyslog.InputSyslogSyslog1.Type))
			r.InputSyslog.InputSyslogSyslog1.UDPPort = types.Float64Value(resp.InputSyslog.InputSyslogSyslog1.UDPPort)
			r.InputSyslog.InputSyslogSyslog1.UDPSocketRxBufSize = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog1.UDPSocketRxBufSize)
		}
		if resp.InputSyslog.InputSyslogSyslog2 != nil {
			r.InputSyslog.InputSyslogSyslog2 = &tfTypes.InputSyslogSyslog2{}
			r.InputSyslog.InputSyslogSyslog2.AllowNonStandardAppName = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.AllowNonStandardAppName)
			r.InputSyslog.InputSyslogSyslog2.Connections = []tfTypes.InputSyslogConnection2{}
			if len(r.InputSyslog.InputSyslogSyslog2.Connections) > len(resp.InputSyslog.InputSyslogSyslog2.Connections) {
				r.InputSyslog.InputSyslogSyslog2.Connections = r.InputSyslog.InputSyslogSyslog2.Connections[:len(resp.InputSyslog.InputSyslogSyslog2.Connections)]
			}
			for connectionsCount50, connectionsItem50 := range resp.InputSyslog.InputSyslogSyslog2.Connections {
				var connections50 tfTypes.InputSyslogConnection2
				connections50.Output = types.StringValue(connectionsItem50.Output)
				connections50.Pipeline = types.StringPointerValue(connectionsItem50.Pipeline)
				if connectionsCount50+1 > len(r.InputSyslog.InputSyslogSyslog2.Connections) {
					r.InputSyslog.InputSyslogSyslog2.Connections = append(r.InputSyslog.InputSyslogSyslog2.Connections, connections50)
				} else {
					r.InputSyslog.InputSyslogSyslog2.Connections[connectionsCount50].Output = connections50.Output
					r.InputSyslog.InputSyslogSyslog2.Connections[connectionsCount50].Pipeline = connections50.Pipeline
				}
			}
			r.InputSyslog.InputSyslogSyslog2.Description = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.Description)
			r.InputSyslog.InputSyslogSyslog2.Disabled = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.Disabled)
			r.InputSyslog.InputSyslogSyslog2.EnableEnhancedProxyHeaderParsing = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.EnableEnhancedProxyHeaderParsing)
			r.InputSyslog.InputSyslogSyslog2.EnableLoadBalancing = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.EnableLoadBalancing)
			r.InputSyslog.InputSyslogSyslog2.EnableProxyHeader = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.EnableProxyHeader)
			r.InputSyslog.InputSyslogSyslog2.Environment = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.Environment)
			r.InputSyslog.InputSyslogSyslog2.Host = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.Host)
			r.InputSyslog.InputSyslogSyslog2.ID = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.ID)
			r.InputSyslog.InputSyslogSyslog2.InferFraming = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.InferFraming)
			r.InputSyslog.InputSyslogSyslog2.IPWhitelistRegex = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.IPWhitelistRegex)
			r.InputSyslog.InputSyslogSyslog2.KeepFieldsList = make([]types.String, 0, len(resp.InputSyslog.InputSyslogSyslog2.KeepFieldsList))
			for _, v := range resp.InputSyslog.InputSyslogSyslog2.KeepFieldsList {
				r.InputSyslog.InputSyslogSyslog2.KeepFieldsList = append(r.InputSyslog.InputSyslogSyslog2.KeepFieldsList, types.StringValue(v))
			}
			r.InputSyslog.InputSyslogSyslog2.MaxActiveCxn = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.MaxActiveCxn)
			r.InputSyslog.InputSyslogSyslog2.MaxBufferSize = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.MaxBufferSize)
			r.InputSyslog.InputSyslogSyslog2.Metadata = []tfTypes.InputSyslogMetadatum2{}
			if len(r.InputSyslog.InputSyslogSyslog2.Metadata) > len(resp.InputSyslog.InputSyslogSyslog2.Metadata) {
				r.InputSyslog.InputSyslogSyslog2.Metadata = r.InputSyslog.InputSyslogSyslog2.Metadata[:len(resp.InputSyslog.InputSyslogSyslog2.Metadata)]
			}
			for metadataCount53, metadataItem53 := range resp.InputSyslog.InputSyslogSyslog2.Metadata {
				var metadata53 tfTypes.InputSyslogMetadatum2
				metadata53.Name = types.StringValue(metadataItem53.Name)
				metadata53.Value = types.StringValue(metadataItem53.Value)
				if metadataCount53+1 > len(r.InputSyslog.InputSyslogSyslog2.Metadata) {
					r.InputSyslog.InputSyslogSyslog2.Metadata = append(r.InputSyslog.InputSyslogSyslog2.Metadata, metadata53)
				} else {
					r.InputSyslog.InputSyslogSyslog2.Metadata[metadataCount53].Name = metadata53.Name
					r.InputSyslog.InputSyslogSyslog2.Metadata[metadataCount53].Value = metadata53.Value
				}
			}
			r.InputSyslog.InputSyslogSyslog2.OctetCounting = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.OctetCounting)
			r.InputSyslog.InputSyslogSyslog2.Pipeline = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.Pipeline)
			if resp.InputSyslog.InputSyslogSyslog2.Pq == nil {
				r.InputSyslog.InputSyslogSyslog2.Pq = nil
			} else {
				r.InputSyslog.InputSyslogSyslog2.Pq = &tfTypes.InputSyslogPq2{}
				r.InputSyslog.InputSyslogSyslog2.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.Pq.CommitFrequency)
				if resp.InputSyslog.InputSyslogSyslog2.Pq.Compress != nil {
					r.InputSyslog.InputSyslogSyslog2.Pq.Compress = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog2.Pq.Compress))
				} else {
					r.InputSyslog.InputSyslogSyslog2.Pq.Compress = types.StringNull()
				}
				r.InputSyslog.InputSyslogSyslog2.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.Pq.MaxBufferSize)
				r.InputSyslog.InputSyslogSyslog2.Pq.MaxFileSize = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.Pq.MaxFileSize)
				r.InputSyslog.InputSyslogSyslog2.Pq.MaxSize = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.Pq.MaxSize)
				if resp.InputSyslog.InputSyslogSyslog2.Pq.Mode != nil {
					r.InputSyslog.InputSyslogSyslog2.Pq.Mode = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog2.Pq.Mode))
				} else {
					r.InputSyslog.InputSyslogSyslog2.Pq.Mode = types.StringNull()
				}
				r.InputSyslog.InputSyslogSyslog2.Pq.Path = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.Pq.Path)
			}
			r.InputSyslog.InputSyslogSyslog2.PqEnabled = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.PqEnabled)
			r.InputSyslog.InputSyslogSyslog2.SendToRoutes = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.SendToRoutes)
			r.InputSyslog.InputSyslogSyslog2.SingleMsgUDPPackets = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.SingleMsgUDPPackets)
			r.InputSyslog.InputSyslogSyslog2.SocketEndingMaxWait = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.SocketEndingMaxWait)
			r.InputSyslog.InputSyslogSyslog2.SocketIdleTimeout = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.SocketIdleTimeout)
			r.InputSyslog.InputSyslogSyslog2.SocketMaxLifespan = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.SocketMaxLifespan)
			r.InputSyslog.InputSyslogSyslog2.Streamtags = make([]types.String, 0, len(resp.InputSyslog.InputSyslogSyslog2.Streamtags))
			for _, v := range resp.InputSyslog.InputSyslogSyslog2.Streamtags {
				r.InputSyslog.InputSyslogSyslog2.Streamtags = append(r.InputSyslog.InputSyslogSyslog2.Streamtags, types.StringValue(v))
			}
			r.InputSyslog.InputSyslogSyslog2.StrictlyInferOctetCounting = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.StrictlyInferOctetCounting)
			r.InputSyslog.InputSyslogSyslog2.TCPPort = types.Float64Value(resp.InputSyslog.InputSyslogSyslog2.TCPPort)
			r.InputSyslog.InputSyslogSyslog2.TimestampTimezone = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.TimestampTimezone)
			if resp.InputSyslog.InputSyslogSyslog2.TLS == nil {
				r.InputSyslog.InputSyslogSyslog2.TLS = nil
			} else {
				r.InputSyslog.InputSyslogSyslog2.TLS = &tfTypes.InputSyslogTLSSettingsServerSide2{}
				r.InputSyslog.InputSyslogSyslog2.TLS.CaPath = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.TLS.CaPath)
				r.InputSyslog.InputSyslogSyslog2.TLS.CertificateName = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.TLS.CertificateName)
				r.InputSyslog.InputSyslogSyslog2.TLS.CertPath = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.TLS.CertPath)
				if resp.InputSyslog.InputSyslogSyslog2.TLS.CommonNameRegex == nil {
					r.InputSyslog.InputSyslogSyslog2.TLS.CommonNameRegex = types.StringNull()
				} else {
					commonNameRegexResult19, _ := json.Marshal(resp.InputSyslog.InputSyslogSyslog2.TLS.CommonNameRegex)
					r.InputSyslog.InputSyslogSyslog2.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult19))
				}
				r.InputSyslog.InputSyslogSyslog2.TLS.Disabled = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.TLS.Disabled)
				if resp.InputSyslog.InputSyslogSyslog2.TLS.MaxVersion != nil {
					r.InputSyslog.InputSyslogSyslog2.TLS.MaxVersion = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog2.TLS.MaxVersion))
				} else {
					r.InputSyslog.InputSyslogSyslog2.TLS.MaxVersion = types.StringNull()
				}
				if resp.InputSyslog.InputSyslogSyslog2.TLS.MinVersion != nil {
					r.InputSyslog.InputSyslogSyslog2.TLS.MinVersion = types.StringValue(string(*resp.InputSyslog.InputSyslogSyslog2.TLS.MinVersion))
				} else {
					r.InputSyslog.InputSyslogSyslog2.TLS.MinVersion = types.StringNull()
				}
				r.InputSyslog.InputSyslogSyslog2.TLS.Passphrase = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.TLS.Passphrase)
				r.InputSyslog.InputSyslogSyslog2.TLS.PrivKeyPath = types.StringPointerValue(resp.InputSyslog.InputSyslogSyslog2.TLS.PrivKeyPath)
				if resp.InputSyslog.InputSyslogSyslog2.TLS.RejectUnauthorized == nil {
					r.InputSyslog.InputSyslogSyslog2.TLS.RejectUnauthorized = types.StringNull()
				} else {
					rejectUnauthorizedResult19, _ := json.Marshal(resp.InputSyslog.InputSyslogSyslog2.TLS.RejectUnauthorized)
					r.InputSyslog.InputSyslogSyslog2.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult19))
				}
				r.InputSyslog.InputSyslogSyslog2.TLS.RequestCert = types.BoolPointerValue(resp.InputSyslog.InputSyslogSyslog2.TLS.RequestCert)
			}
			r.InputSyslog.InputSyslogSyslog2.Type = types.StringValue(string(resp.InputSyslog.InputSyslogSyslog2.Type))
			r.InputSyslog.InputSyslogSyslog2.UDPPort = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.UDPPort)
			r.InputSyslog.InputSyslogSyslog2.UDPSocketRxBufSize = types.Float64PointerValue(resp.InputSyslog.InputSyslogSyslog2.UDPSocketRxBufSize)
		}
	}
	if resp.InputSystemMetrics != nil {
		r.InputSystemMetrics = &tfTypes.InputSystemMetrics{}
		r.InputSystemMetrics.Connections = []tfTypes.InputSystemMetricsConnection{}
		if len(r.InputSystemMetrics.Connections) > len(resp.InputSystemMetrics.Connections) {
			r.InputSystemMetrics.Connections = r.InputSystemMetrics.Connections[:len(resp.InputSystemMetrics.Connections)]
		}
		for connectionsCount51, connectionsItem51 := range resp.InputSystemMetrics.Connections {
			var connections51 tfTypes.InputSystemMetricsConnection
			connections51.Output = types.StringValue(connectionsItem51.Output)
			connections51.Pipeline = types.StringPointerValue(connectionsItem51.Pipeline)
			if connectionsCount51+1 > len(r.InputSystemMetrics.Connections) {
				r.InputSystemMetrics.Connections = append(r.InputSystemMetrics.Connections, connections51)
			} else {
				r.InputSystemMetrics.Connections[connectionsCount51].Output = connections51.Output
				r.InputSystemMetrics.Connections[connectionsCount51].Pipeline = connections51.Pipeline
			}
		}
		if resp.InputSystemMetrics.Container == nil {
			r.InputSystemMetrics.Container = nil
		} else {
			r.InputSystemMetrics.Container = &tfTypes.InputSystemMetricsContainer{}
			r.InputSystemMetrics.Container.AllContainers = types.BoolPointerValue(resp.InputSystemMetrics.Container.AllContainers)
			r.InputSystemMetrics.Container.Detail = types.BoolPointerValue(resp.InputSystemMetrics.Container.Detail)
			r.InputSystemMetrics.Container.DockerSocket = make([]types.String, 0, len(resp.InputSystemMetrics.Container.DockerSocket))
			for _, v := range resp.InputSystemMetrics.Container.DockerSocket {
				r.InputSystemMetrics.Container.DockerSocket = append(r.InputSystemMetrics.Container.DockerSocket, types.StringValue(v))
			}
			r.InputSystemMetrics.Container.DockerTimeout = types.Float64PointerValue(resp.InputSystemMetrics.Container.DockerTimeout)
			r.InputSystemMetrics.Container.Filters = []tfTypes.InputSystemMetricsFilter{}
			if len(r.InputSystemMetrics.Container.Filters) > len(resp.InputSystemMetrics.Container.Filters) {
				r.InputSystemMetrics.Container.Filters = r.InputSystemMetrics.Container.Filters[:len(resp.InputSystemMetrics.Container.Filters)]
			}
			for filtersCount, filtersItem := range resp.InputSystemMetrics.Container.Filters {
				var filters tfTypes.InputSystemMetricsFilter
				filters.Expr = types.StringValue(filtersItem.Expr)
				if filtersCount+1 > len(r.InputSystemMetrics.Container.Filters) {
					r.InputSystemMetrics.Container.Filters = append(r.InputSystemMetrics.Container.Filters, filters)
				} else {
					r.InputSystemMetrics.Container.Filters[filtersCount].Expr = filters.Expr
				}
			}
			if resp.InputSystemMetrics.Container.Mode != nil {
				r.InputSystemMetrics.Container.Mode = types.StringValue(string(*resp.InputSystemMetrics.Container.Mode))
			} else {
				r.InputSystemMetrics.Container.Mode = types.StringNull()
			}
			r.InputSystemMetrics.Container.PerDevice = types.BoolPointerValue(resp.InputSystemMetrics.Container.PerDevice)
		}
		r.InputSystemMetrics.Description = types.StringPointerValue(resp.InputSystemMetrics.Description)
		r.InputSystemMetrics.Disabled = types.BoolPointerValue(resp.InputSystemMetrics.Disabled)
		r.InputSystemMetrics.Environment = types.StringPointerValue(resp.InputSystemMetrics.Environment)
		if resp.InputSystemMetrics.Host == nil {
			r.InputSystemMetrics.Host = nil
		} else {
			r.InputSystemMetrics.Host = &tfTypes.InputSystemMetricsHost{}
			if resp.InputSystemMetrics.Host.Custom == nil {
				r.InputSystemMetrics.Host.Custom = nil
			} else {
				r.InputSystemMetrics.Host.Custom = &tfTypes.InputSystemMetricsCustom{}
				if resp.InputSystemMetrics.Host.Custom.CPU == nil {
					r.InputSystemMetrics.Host.Custom.CPU = nil
				} else {
					r.InputSystemMetrics.Host.Custom.CPU = &tfTypes.InputSystemMetricsCPU{}
					r.InputSystemMetrics.Host.Custom.CPU.Detail = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.CPU.Detail)
					if resp.InputSystemMetrics.Host.Custom.CPU.Mode != nil {
						r.InputSystemMetrics.Host.Custom.CPU.Mode = types.StringValue(string(*resp.InputSystemMetrics.Host.Custom.CPU.Mode))
					} else {
						r.InputSystemMetrics.Host.Custom.CPU.Mode = types.StringNull()
					}
					r.InputSystemMetrics.Host.Custom.CPU.PerCPU = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.CPU.PerCPU)
					r.InputSystemMetrics.Host.Custom.CPU.Time = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.CPU.Time)
				}
				if resp.InputSystemMetrics.Host.Custom.Disk == nil {
					r.InputSystemMetrics.Host.Custom.Disk = nil
				} else {
					r.InputSystemMetrics.Host.Custom.Disk = &tfTypes.InputSystemMetricsDisk{}
					r.InputSystemMetrics.Host.Custom.Disk.Detail = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.Disk.Detail)
					r.InputSystemMetrics.Host.Custom.Disk.Devices = make([]types.String, 0, len(resp.InputSystemMetrics.Host.Custom.Disk.Devices))
					for _, v := range resp.InputSystemMetrics.Host.Custom.Disk.Devices {
						r.InputSystemMetrics.Host.Custom.Disk.Devices = append(r.InputSystemMetrics.Host.Custom.Disk.Devices, types.StringValue(v))
					}
					r.InputSystemMetrics.Host.Custom.Disk.Fstypes = make([]types.String, 0, len(resp.InputSystemMetrics.Host.Custom.Disk.Fstypes))
					for _, v := range resp.InputSystemMetrics.Host.Custom.Disk.Fstypes {
						r.InputSystemMetrics.Host.Custom.Disk.Fstypes = append(r.InputSystemMetrics.Host.Custom.Disk.Fstypes, types.StringValue(v))
					}
					if resp.InputSystemMetrics.Host.Custom.Disk.Mode != nil {
						r.InputSystemMetrics.Host.Custom.Disk.Mode = types.StringValue(string(*resp.InputSystemMetrics.Host.Custom.Disk.Mode))
					} else {
						r.InputSystemMetrics.Host.Custom.Disk.Mode = types.StringNull()
					}
					r.InputSystemMetrics.Host.Custom.Disk.Mountpoints = make([]types.String, 0, len(resp.InputSystemMetrics.Host.Custom.Disk.Mountpoints))
					for _, v := range resp.InputSystemMetrics.Host.Custom.Disk.Mountpoints {
						r.InputSystemMetrics.Host.Custom.Disk.Mountpoints = append(r.InputSystemMetrics.Host.Custom.Disk.Mountpoints, types.StringValue(v))
					}
					r.InputSystemMetrics.Host.Custom.Disk.PerDevice = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.Disk.PerDevice)
				}
				if resp.InputSystemMetrics.Host.Custom.Memory == nil {
					r.InputSystemMetrics.Host.Custom.Memory = nil
				} else {
					r.InputSystemMetrics.Host.Custom.Memory = &tfTypes.InputSystemMetricsMemory{}
					r.InputSystemMetrics.Host.Custom.Memory.Detail = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.Memory.Detail)
					if resp.InputSystemMetrics.Host.Custom.Memory.Mode != nil {
						r.InputSystemMetrics.Host.Custom.Memory.Mode = types.StringValue(string(*resp.InputSystemMetrics.Host.Custom.Memory.Mode))
					} else {
						r.InputSystemMetrics.Host.Custom.Memory.Mode = types.StringNull()
					}
				}
				if resp.InputSystemMetrics.Host.Custom.Network == nil {
					r.InputSystemMetrics.Host.Custom.Network = nil
				} else {
					r.InputSystemMetrics.Host.Custom.Network = &tfTypes.InputSystemMetricsNetwork{}
					r.InputSystemMetrics.Host.Custom.Network.Detail = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.Network.Detail)
					r.InputSystemMetrics.Host.Custom.Network.Devices = make([]types.String, 0, len(resp.InputSystemMetrics.Host.Custom.Network.Devices))
					for _, v := range resp.InputSystemMetrics.Host.Custom.Network.Devices {
						r.InputSystemMetrics.Host.Custom.Network.Devices = append(r.InputSystemMetrics.Host.Custom.Network.Devices, types.StringValue(v))
					}
					if resp.InputSystemMetrics.Host.Custom.Network.Mode != nil {
						r.InputSystemMetrics.Host.Custom.Network.Mode = types.StringValue(string(*resp.InputSystemMetrics.Host.Custom.Network.Mode))
					} else {
						r.InputSystemMetrics.Host.Custom.Network.Mode = types.StringNull()
					}
					r.InputSystemMetrics.Host.Custom.Network.PerInterface = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.Network.PerInterface)
				}
				if resp.InputSystemMetrics.Host.Custom.System == nil {
					r.InputSystemMetrics.Host.Custom.System = nil
				} else {
					r.InputSystemMetrics.Host.Custom.System = &tfTypes.InputSystemMetricsSystem{}
					if resp.InputSystemMetrics.Host.Custom.System.Mode != nil {
						r.InputSystemMetrics.Host.Custom.System.Mode = types.StringValue(string(*resp.InputSystemMetrics.Host.Custom.System.Mode))
					} else {
						r.InputSystemMetrics.Host.Custom.System.Mode = types.StringNull()
					}
					r.InputSystemMetrics.Host.Custom.System.Processes = types.BoolPointerValue(resp.InputSystemMetrics.Host.Custom.System.Processes)
				}
			}
			if resp.InputSystemMetrics.Host.Mode != nil {
				r.InputSystemMetrics.Host.Mode = types.StringValue(string(*resp.InputSystemMetrics.Host.Mode))
			} else {
				r.InputSystemMetrics.Host.Mode = types.StringNull()
			}
		}
		r.InputSystemMetrics.ID = types.StringValue(resp.InputSystemMetrics.ID)
		r.InputSystemMetrics.Interval = types.Float64PointerValue(resp.InputSystemMetrics.Interval)
		r.InputSystemMetrics.Metadata = []tfTypes.InputSystemMetricsMetadatum{}
		if len(r.InputSystemMetrics.Metadata) > len(resp.InputSystemMetrics.Metadata) {
			r.InputSystemMetrics.Metadata = r.InputSystemMetrics.Metadata[:len(resp.InputSystemMetrics.Metadata)]
		}
		for metadataCount54, metadataItem54 := range resp.InputSystemMetrics.Metadata {
			var metadata54 tfTypes.InputSystemMetricsMetadatum
			metadata54.Name = types.StringValue(metadataItem54.Name)
			metadata54.Value = types.StringValue(metadataItem54.Value)
			if metadataCount54+1 > len(r.InputSystemMetrics.Metadata) {
				r.InputSystemMetrics.Metadata = append(r.InputSystemMetrics.Metadata, metadata54)
			} else {
				r.InputSystemMetrics.Metadata[metadataCount54].Name = metadata54.Name
				r.InputSystemMetrics.Metadata[metadataCount54].Value = metadata54.Value
			}
		}
		if resp.InputSystemMetrics.Persistence == nil {
			r.InputSystemMetrics.Persistence = nil
		} else {
			r.InputSystemMetrics.Persistence = &tfTypes.InputSystemMetricsPersistence{}
			if resp.InputSystemMetrics.Persistence.Compress != nil {
				r.InputSystemMetrics.Persistence.Compress = types.StringValue(string(*resp.InputSystemMetrics.Persistence.Compress))
			} else {
				r.InputSystemMetrics.Persistence.Compress = types.StringNull()
			}
			r.InputSystemMetrics.Persistence.DestPath = types.StringPointerValue(resp.InputSystemMetrics.Persistence.DestPath)
			r.InputSystemMetrics.Persistence.Enable = types.BoolPointerValue(resp.InputSystemMetrics.Persistence.Enable)
			r.InputSystemMetrics.Persistence.MaxDataSize = types.StringPointerValue(resp.InputSystemMetrics.Persistence.MaxDataSize)
			r.InputSystemMetrics.Persistence.MaxDataTime = types.StringPointerValue(resp.InputSystemMetrics.Persistence.MaxDataTime)
			r.InputSystemMetrics.Persistence.TimeWindow = types.StringPointerValue(resp.InputSystemMetrics.Persistence.TimeWindow)
		}
		r.InputSystemMetrics.Pipeline = types.StringPointerValue(resp.InputSystemMetrics.Pipeline)
		if resp.InputSystemMetrics.Pq == nil {
			r.InputSystemMetrics.Pq = nil
		} else {
			r.InputSystemMetrics.Pq = &tfTypes.InputSystemMetricsPq{}
			r.InputSystemMetrics.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSystemMetrics.Pq.CommitFrequency)
			if resp.InputSystemMetrics.Pq.Compress != nil {
				r.InputSystemMetrics.Pq.Compress = types.StringValue(string(*resp.InputSystemMetrics.Pq.Compress))
			} else {
				r.InputSystemMetrics.Pq.Compress = types.StringNull()
			}
			r.InputSystemMetrics.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSystemMetrics.Pq.MaxBufferSize)
			r.InputSystemMetrics.Pq.MaxFileSize = types.StringPointerValue(resp.InputSystemMetrics.Pq.MaxFileSize)
			r.InputSystemMetrics.Pq.MaxSize = types.StringPointerValue(resp.InputSystemMetrics.Pq.MaxSize)
			if resp.InputSystemMetrics.Pq.Mode != nil {
				r.InputSystemMetrics.Pq.Mode = types.StringValue(string(*resp.InputSystemMetrics.Pq.Mode))
			} else {
				r.InputSystemMetrics.Pq.Mode = types.StringNull()
			}
			r.InputSystemMetrics.Pq.Path = types.StringPointerValue(resp.InputSystemMetrics.Pq.Path)
		}
		r.InputSystemMetrics.PqEnabled = types.BoolPointerValue(resp.InputSystemMetrics.PqEnabled)
		if resp.InputSystemMetrics.Process == nil {
			r.InputSystemMetrics.Process = nil
		} else {
			r.InputSystemMetrics.Process = &tfTypes.InputSystemMetricsProcess{}
			r.InputSystemMetrics.Process.Sets = []tfTypes.InputSystemMetricsSet{}
			if len(r.InputSystemMetrics.Process.Sets) > len(resp.InputSystemMetrics.Process.Sets) {
				r.InputSystemMetrics.Process.Sets = r.InputSystemMetrics.Process.Sets[:len(resp.InputSystemMetrics.Process.Sets)]
			}
			for setsCount, setsItem := range resp.InputSystemMetrics.Process.Sets {
				var sets tfTypes.InputSystemMetricsSet
				sets.Filter = types.StringValue(setsItem.Filter)
				sets.IncludeChildren = types.BoolPointerValue(setsItem.IncludeChildren)
				sets.Name = types.StringValue(setsItem.Name)
				if setsCount+1 > len(r.InputSystemMetrics.Process.Sets) {
					r.InputSystemMetrics.Process.Sets = append(r.InputSystemMetrics.Process.Sets, sets)
				} else {
					r.InputSystemMetrics.Process.Sets[setsCount].Filter = sets.Filter
					r.InputSystemMetrics.Process.Sets[setsCount].IncludeChildren = sets.IncludeChildren
					r.InputSystemMetrics.Process.Sets[setsCount].Name = sets.Name
				}
			}
		}
		r.InputSystemMetrics.SendToRoutes = types.BoolPointerValue(resp.InputSystemMetrics.SendToRoutes)
		r.InputSystemMetrics.Streamtags = make([]types.String, 0, len(resp.InputSystemMetrics.Streamtags))
		for _, v := range resp.InputSystemMetrics.Streamtags {
			r.InputSystemMetrics.Streamtags = append(r.InputSystemMetrics.Streamtags, types.StringValue(v))
		}
		r.InputSystemMetrics.Type = types.StringValue(string(resp.InputSystemMetrics.Type))
	}
	if resp.InputSystemState != nil {
		r.InputSystemState = &tfTypes.InputSystemState{}
		if resp.InputSystemState.Collectors == nil {
			r.InputSystemState.Collectors = nil
		} else {
			r.InputSystemState.Collectors = &tfTypes.Collectors{}
			if resp.InputSystemState.Collectors.Disk == nil {
				r.InputSystemState.Collectors.Disk = nil
			} else {
				r.InputSystemState.Collectors.Disk = &tfTypes.DisksAndFileSystems{}
				r.InputSystemState.Collectors.Disk.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Disk.Enable)
			}
			if resp.InputSystemState.Collectors.DNS == nil {
				r.InputSystemState.Collectors.DNS = nil
			} else {
				r.InputSystemState.Collectors.DNS = &tfTypes.DNS{}
				r.InputSystemState.Collectors.DNS.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.DNS.Enable)
			}
			if resp.InputSystemState.Collectors.Firewall == nil {
				r.InputSystemState.Collectors.Firewall = nil
			} else {
				r.InputSystemState.Collectors.Firewall = &tfTypes.Firewall{}
				r.InputSystemState.Collectors.Firewall.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Firewall.Enable)
			}
			if resp.InputSystemState.Collectors.Hostsfile == nil {
				r.InputSystemState.Collectors.Hostsfile = nil
			} else {
				r.InputSystemState.Collectors.Hostsfile = &tfTypes.HostsFile{}
				r.InputSystemState.Collectors.Hostsfile.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Hostsfile.Enable)
			}
			if resp.InputSystemState.Collectors.Interfaces == nil {
				r.InputSystemState.Collectors.Interfaces = nil
			} else {
				r.InputSystemState.Collectors.Interfaces = &tfTypes.Interfaces{}
				r.InputSystemState.Collectors.Interfaces.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Interfaces.Enable)
			}
			if resp.InputSystemState.Collectors.LoginUsers == nil {
				r.InputSystemState.Collectors.LoginUsers = nil
			} else {
				r.InputSystemState.Collectors.LoginUsers = &tfTypes.LoggedInUsers{}
				r.InputSystemState.Collectors.LoginUsers.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.LoginUsers.Enable)
			}
			if resp.InputSystemState.Collectors.Metadata == nil {
				r.InputSystemState.Collectors.Metadata = nil
			} else {
				r.InputSystemState.Collectors.Metadata = &tfTypes.HostInfo{}
				r.InputSystemState.Collectors.Metadata.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Metadata.Enable)
			}
			if resp.InputSystemState.Collectors.Ports == nil {
				r.InputSystemState.Collectors.Ports = nil
			} else {
				r.InputSystemState.Collectors.Ports = &tfTypes.ListeningPorts{}
				r.InputSystemState.Collectors.Ports.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Ports.Enable)
			}
			if resp.InputSystemState.Collectors.Routes == nil {
				r.InputSystemState.Collectors.Routes = nil
			} else {
				r.InputSystemState.Collectors.Routes = &tfTypes.InputSystemStateRoutes{}
				r.InputSystemState.Collectors.Routes.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Routes.Enable)
			}
			if resp.InputSystemState.Collectors.Services == nil {
				r.InputSystemState.Collectors.Services = nil
			} else {
				r.InputSystemState.Collectors.Services = &tfTypes.Services{}
				r.InputSystemState.Collectors.Services.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.Services.Enable)
			}
			if resp.InputSystemState.Collectors.User == nil {
				r.InputSystemState.Collectors.User = nil
			} else {
				r.InputSystemState.Collectors.User = &tfTypes.UsersAndGroups{}
				r.InputSystemState.Collectors.User.Enable = types.BoolPointerValue(resp.InputSystemState.Collectors.User.Enable)
			}
		}
		r.InputSystemState.Connections = []tfTypes.InputSystemStateConnection{}
		if len(r.InputSystemState.Connections) > len(resp.InputSystemState.Connections) {
			r.InputSystemState.Connections = r.InputSystemState.Connections[:len(resp.InputSystemState.Connections)]
		}
		for connectionsCount52, connectionsItem52 := range resp.InputSystemState.Connections {
			var connections52 tfTypes.InputSystemStateConnection
			connections52.Output = types.StringValue(connectionsItem52.Output)
			connections52.Pipeline = types.StringPointerValue(connectionsItem52.Pipeline)
			if connectionsCount52+1 > len(r.InputSystemState.Connections) {
				r.InputSystemState.Connections = append(r.InputSystemState.Connections, connections52)
			} else {
				r.InputSystemState.Connections[connectionsCount52].Output = connections52.Output
				r.InputSystemState.Connections[connectionsCount52].Pipeline = connections52.Pipeline
			}
		}
		r.InputSystemState.Description = types.StringPointerValue(resp.InputSystemState.Description)
		r.InputSystemState.Disabled = types.BoolPointerValue(resp.InputSystemState.Disabled)
		r.InputSystemState.DisableNativeModule = types.BoolPointerValue(resp.InputSystemState.DisableNativeModule)
		r.InputSystemState.Environment = types.StringPointerValue(resp.InputSystemState.Environment)
		r.InputSystemState.ID = types.StringValue(resp.InputSystemState.ID)
		r.InputSystemState.Interval = types.Float64PointerValue(resp.InputSystemState.Interval)
		r.InputSystemState.Metadata = []tfTypes.InputSystemStateMetadatum{}
		if len(r.InputSystemState.Metadata) > len(resp.InputSystemState.Metadata) {
			r.InputSystemState.Metadata = r.InputSystemState.Metadata[:len(resp.InputSystemState.Metadata)]
		}
		for metadataCount55, metadataItem55 := range resp.InputSystemState.Metadata {
			var metadata55 tfTypes.InputSystemStateMetadatum
			metadata55.Name = types.StringValue(metadataItem55.Name)
			metadata55.Value = types.StringValue(metadataItem55.Value)
			if metadataCount55+1 > len(r.InputSystemState.Metadata) {
				r.InputSystemState.Metadata = append(r.InputSystemState.Metadata, metadata55)
			} else {
				r.InputSystemState.Metadata[metadataCount55].Name = metadata55.Name
				r.InputSystemState.Metadata[metadataCount55].Value = metadata55.Value
			}
		}
		if resp.InputSystemState.Persistence == nil {
			r.InputSystemState.Persistence = nil
		} else {
			r.InputSystemState.Persistence = &tfTypes.InputSystemStatePersistence{}
			if resp.InputSystemState.Persistence.Compress != nil {
				r.InputSystemState.Persistence.Compress = types.StringValue(string(*resp.InputSystemState.Persistence.Compress))
			} else {
				r.InputSystemState.Persistence.Compress = types.StringNull()
			}
			r.InputSystemState.Persistence.DestPath = types.StringPointerValue(resp.InputSystemState.Persistence.DestPath)
			r.InputSystemState.Persistence.Enable = types.BoolPointerValue(resp.InputSystemState.Persistence.Enable)
			r.InputSystemState.Persistence.MaxDataSize = types.StringPointerValue(resp.InputSystemState.Persistence.MaxDataSize)
			r.InputSystemState.Persistence.MaxDataTime = types.StringPointerValue(resp.InputSystemState.Persistence.MaxDataTime)
			r.InputSystemState.Persistence.TimeWindow = types.StringPointerValue(resp.InputSystemState.Persistence.TimeWindow)
		}
		r.InputSystemState.Pipeline = types.StringPointerValue(resp.InputSystemState.Pipeline)
		if resp.InputSystemState.Pq == nil {
			r.InputSystemState.Pq = nil
		} else {
			r.InputSystemState.Pq = &tfTypes.InputSystemStatePq{}
			r.InputSystemState.Pq.CommitFrequency = types.Float64PointerValue(resp.InputSystemState.Pq.CommitFrequency)
			if resp.InputSystemState.Pq.Compress != nil {
				r.InputSystemState.Pq.Compress = types.StringValue(string(*resp.InputSystemState.Pq.Compress))
			} else {
				r.InputSystemState.Pq.Compress = types.StringNull()
			}
			r.InputSystemState.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputSystemState.Pq.MaxBufferSize)
			r.InputSystemState.Pq.MaxFileSize = types.StringPointerValue(resp.InputSystemState.Pq.MaxFileSize)
			r.InputSystemState.Pq.MaxSize = types.StringPointerValue(resp.InputSystemState.Pq.MaxSize)
			if resp.InputSystemState.Pq.Mode != nil {
				r.InputSystemState.Pq.Mode = types.StringValue(string(*resp.InputSystemState.Pq.Mode))
			} else {
				r.InputSystemState.Pq.Mode = types.StringNull()
			}
			r.InputSystemState.Pq.Path = types.StringPointerValue(resp.InputSystemState.Pq.Path)
		}
		r.InputSystemState.PqEnabled = types.BoolPointerValue(resp.InputSystemState.PqEnabled)
		r.InputSystemState.SendToRoutes = types.BoolPointerValue(resp.InputSystemState.SendToRoutes)
		r.InputSystemState.Streamtags = make([]types.String, 0, len(resp.InputSystemState.Streamtags))
		for _, v := range resp.InputSystemState.Streamtags {
			r.InputSystemState.Streamtags = append(r.InputSystemState.Streamtags, types.StringValue(v))
		}
		r.InputSystemState.Type = types.StringValue(string(resp.InputSystemState.Type))
	}
	if resp.InputTCP != nil {
		r.InputTCP = &tfTypes.InputTCP{}
		if resp.InputTCP.AuthType != nil {
			r.InputTCP.AuthType = types.StringValue(string(*resp.InputTCP.AuthType))
		} else {
			r.InputTCP.AuthType = types.StringNull()
		}
		r.InputTCP.BreakerRulesets = make([]types.String, 0, len(resp.InputTCP.BreakerRulesets))
		for _, v := range resp.InputTCP.BreakerRulesets {
			r.InputTCP.BreakerRulesets = append(r.InputTCP.BreakerRulesets, types.StringValue(v))
		}
		r.InputTCP.Connections = []tfTypes.InputTCPConnection{}
		if len(r.InputTCP.Connections) > len(resp.InputTCP.Connections) {
			r.InputTCP.Connections = r.InputTCP.Connections[:len(resp.InputTCP.Connections)]
		}
		for connectionsCount53, connectionsItem53 := range resp.InputTCP.Connections {
			var connections53 tfTypes.InputTCPConnection
			connections53.Output = types.StringValue(connectionsItem53.Output)
			connections53.Pipeline = types.StringPointerValue(connectionsItem53.Pipeline)
			if connectionsCount53+1 > len(r.InputTCP.Connections) {
				r.InputTCP.Connections = append(r.InputTCP.Connections, connections53)
			} else {
				r.InputTCP.Connections[connectionsCount53].Output = connections53.Output
				r.InputTCP.Connections[connectionsCount53].Pipeline = connections53.Pipeline
			}
		}
		r.InputTCP.Description = types.StringPointerValue(resp.InputTCP.Description)
		r.InputTCP.Disabled = types.BoolPointerValue(resp.InputTCP.Disabled)
		r.InputTCP.EnableHeader = types.BoolPointerValue(resp.InputTCP.EnableHeader)
		r.InputTCP.EnableProxyHeader = types.BoolPointerValue(resp.InputTCP.EnableProxyHeader)
		r.InputTCP.Environment = types.StringPointerValue(resp.InputTCP.Environment)
		r.InputTCP.Host = types.StringPointerValue(resp.InputTCP.Host)
		r.InputTCP.ID = types.StringPointerValue(resp.InputTCP.ID)
		r.InputTCP.IPWhitelistRegex = types.StringPointerValue(resp.InputTCP.IPWhitelistRegex)
		r.InputTCP.MaxActiveCxn = types.Float64PointerValue(resp.InputTCP.MaxActiveCxn)
		r.InputTCP.Metadata = []tfTypes.InputTCPMetadatum{}
		if len(r.InputTCP.Metadata) > len(resp.InputTCP.Metadata) {
			r.InputTCP.Metadata = r.InputTCP.Metadata[:len(resp.InputTCP.Metadata)]
		}
		for metadataCount56, metadataItem56 := range resp.InputTCP.Metadata {
			var metadata56 tfTypes.InputTCPMetadatum
			metadata56.Name = types.StringValue(metadataItem56.Name)
			metadata56.Value = types.StringValue(metadataItem56.Value)
			if metadataCount56+1 > len(r.InputTCP.Metadata) {
				r.InputTCP.Metadata = append(r.InputTCP.Metadata, metadata56)
			} else {
				r.InputTCP.Metadata[metadataCount56].Name = metadata56.Name
				r.InputTCP.Metadata[metadataCount56].Value = metadata56.Value
			}
		}
		r.InputTCP.Pipeline = types.StringPointerValue(resp.InputTCP.Pipeline)
		r.InputTCP.Port = types.Float64Value(resp.InputTCP.Port)
		if resp.InputTCP.Pq == nil {
			r.InputTCP.Pq = nil
		} else {
			r.InputTCP.Pq = &tfTypes.InputTCPPq{}
			r.InputTCP.Pq.CommitFrequency = types.Float64PointerValue(resp.InputTCP.Pq.CommitFrequency)
			if resp.InputTCP.Pq.Compress != nil {
				r.InputTCP.Pq.Compress = types.StringValue(string(*resp.InputTCP.Pq.Compress))
			} else {
				r.InputTCP.Pq.Compress = types.StringNull()
			}
			r.InputTCP.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputTCP.Pq.MaxBufferSize)
			r.InputTCP.Pq.MaxFileSize = types.StringPointerValue(resp.InputTCP.Pq.MaxFileSize)
			r.InputTCP.Pq.MaxSize = types.StringPointerValue(resp.InputTCP.Pq.MaxSize)
			if resp.InputTCP.Pq.Mode != nil {
				r.InputTCP.Pq.Mode = types.StringValue(string(*resp.InputTCP.Pq.Mode))
			} else {
				r.InputTCP.Pq.Mode = types.StringNull()
			}
			r.InputTCP.Pq.Path = types.StringPointerValue(resp.InputTCP.Pq.Path)
		}
		r.InputTCP.PqEnabled = types.BoolPointerValue(resp.InputTCP.PqEnabled)
		if resp.InputTCP.Preprocess == nil {
			r.InputTCP.Preprocess = nil
		} else {
			r.InputTCP.Preprocess = &tfTypes.InputTCPPreprocess{}
			r.InputTCP.Preprocess.Args = make([]types.String, 0, len(resp.InputTCP.Preprocess.Args))
			for _, v := range resp.InputTCP.Preprocess.Args {
				r.InputTCP.Preprocess.Args = append(r.InputTCP.Preprocess.Args, types.StringValue(v))
			}
			r.InputTCP.Preprocess.Command = types.StringPointerValue(resp.InputTCP.Preprocess.Command)
			r.InputTCP.Preprocess.Disabled = types.BoolPointerValue(resp.InputTCP.Preprocess.Disabled)
		}
		r.InputTCP.SendToRoutes = types.BoolPointerValue(resp.InputTCP.SendToRoutes)
		r.InputTCP.SocketEndingMaxWait = types.Float64PointerValue(resp.InputTCP.SocketEndingMaxWait)
		r.InputTCP.SocketIdleTimeout = types.Float64PointerValue(resp.InputTCP.SocketIdleTimeout)
		r.InputTCP.SocketMaxLifespan = types.Float64PointerValue(resp.InputTCP.SocketMaxLifespan)
		r.InputTCP.StaleChannelFlushMs = types.Float64PointerValue(resp.InputTCP.StaleChannelFlushMs)
		r.InputTCP.Streamtags = make([]types.String, 0, len(resp.InputTCP.Streamtags))
		for _, v := range resp.InputTCP.Streamtags {
			r.InputTCP.Streamtags = append(r.InputTCP.Streamtags, types.StringValue(v))
		}
		if resp.InputTCP.TLS == nil {
			r.InputTCP.TLS = nil
		} else {
			r.InputTCP.TLS = &tfTypes.InputTCPTLSSettingsServerSide{}
			r.InputTCP.TLS.CaPath = types.StringPointerValue(resp.InputTCP.TLS.CaPath)
			r.InputTCP.TLS.CertificateName = types.StringPointerValue(resp.InputTCP.TLS.CertificateName)
			r.InputTCP.TLS.CertPath = types.StringPointerValue(resp.InputTCP.TLS.CertPath)
			if resp.InputTCP.TLS.CommonNameRegex == nil {
				r.InputTCP.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult20, _ := json.Marshal(resp.InputTCP.TLS.CommonNameRegex)
				r.InputTCP.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult20))
			}
			r.InputTCP.TLS.Disabled = types.BoolPointerValue(resp.InputTCP.TLS.Disabled)
			if resp.InputTCP.TLS.MaxVersion != nil {
				r.InputTCP.TLS.MaxVersion = types.StringValue(string(*resp.InputTCP.TLS.MaxVersion))
			} else {
				r.InputTCP.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputTCP.TLS.MinVersion != nil {
				r.InputTCP.TLS.MinVersion = types.StringValue(string(*resp.InputTCP.TLS.MinVersion))
			} else {
				r.InputTCP.TLS.MinVersion = types.StringNull()
			}
			r.InputTCP.TLS.Passphrase = types.StringPointerValue(resp.InputTCP.TLS.Passphrase)
			r.InputTCP.TLS.PrivKeyPath = types.StringPointerValue(resp.InputTCP.TLS.PrivKeyPath)
			if resp.InputTCP.TLS.RejectUnauthorized == nil {
				r.InputTCP.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult20, _ := json.Marshal(resp.InputTCP.TLS.RejectUnauthorized)
				r.InputTCP.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult20))
			}
			r.InputTCP.TLS.RequestCert = types.BoolPointerValue(resp.InputTCP.TLS.RequestCert)
		}
		if resp.InputTCP.Type != nil {
			r.InputTCP.Type = types.StringValue(string(*resp.InputTCP.Type))
		} else {
			r.InputTCP.Type = types.StringNull()
		}
	}
	if resp.InputTcpjson != nil {
		r.InputTcpjson = &tfTypes.InputTcpjson{}
		r.InputTcpjson.AuthToken = types.StringPointerValue(resp.InputTcpjson.AuthToken)
		if resp.InputTcpjson.AuthType != nil {
			r.InputTcpjson.AuthType = types.StringValue(string(*resp.InputTcpjson.AuthType))
		} else {
			r.InputTcpjson.AuthType = types.StringNull()
		}
		r.InputTcpjson.Connections = []tfTypes.InputTcpjsonConnection{}
		if len(r.InputTcpjson.Connections) > len(resp.InputTcpjson.Connections) {
			r.InputTcpjson.Connections = r.InputTcpjson.Connections[:len(resp.InputTcpjson.Connections)]
		}
		for connectionsCount54, connectionsItem54 := range resp.InputTcpjson.Connections {
			var connections54 tfTypes.InputTcpjsonConnection
			connections54.Output = types.StringValue(connectionsItem54.Output)
			connections54.Pipeline = types.StringPointerValue(connectionsItem54.Pipeline)
			if connectionsCount54+1 > len(r.InputTcpjson.Connections) {
				r.InputTcpjson.Connections = append(r.InputTcpjson.Connections, connections54)
			} else {
				r.InputTcpjson.Connections[connectionsCount54].Output = connections54.Output
				r.InputTcpjson.Connections[connectionsCount54].Pipeline = connections54.Pipeline
			}
		}
		r.InputTcpjson.Description = types.StringPointerValue(resp.InputTcpjson.Description)
		r.InputTcpjson.Disabled = types.BoolPointerValue(resp.InputTcpjson.Disabled)
		r.InputTcpjson.EnableLoadBalancing = types.BoolPointerValue(resp.InputTcpjson.EnableLoadBalancing)
		r.InputTcpjson.EnableProxyHeader = types.BoolPointerValue(resp.InputTcpjson.EnableProxyHeader)
		r.InputTcpjson.Environment = types.StringPointerValue(resp.InputTcpjson.Environment)
		r.InputTcpjson.Host = types.StringPointerValue(resp.InputTcpjson.Host)
		r.InputTcpjson.ID = types.StringPointerValue(resp.InputTcpjson.ID)
		r.InputTcpjson.IPWhitelistRegex = types.StringPointerValue(resp.InputTcpjson.IPWhitelistRegex)
		r.InputTcpjson.MaxActiveCxn = types.Float64PointerValue(resp.InputTcpjson.MaxActiveCxn)
		r.InputTcpjson.Metadata = []tfTypes.InputTcpjsonMetadatum{}
		if len(r.InputTcpjson.Metadata) > len(resp.InputTcpjson.Metadata) {
			r.InputTcpjson.Metadata = r.InputTcpjson.Metadata[:len(resp.InputTcpjson.Metadata)]
		}
		for metadataCount57, metadataItem57 := range resp.InputTcpjson.Metadata {
			var metadata57 tfTypes.InputTcpjsonMetadatum
			metadata57.Name = types.StringValue(metadataItem57.Name)
			metadata57.Value = types.StringValue(metadataItem57.Value)
			if metadataCount57+1 > len(r.InputTcpjson.Metadata) {
				r.InputTcpjson.Metadata = append(r.InputTcpjson.Metadata, metadata57)
			} else {
				r.InputTcpjson.Metadata[metadataCount57].Name = metadata57.Name
				r.InputTcpjson.Metadata[metadataCount57].Value = metadata57.Value
			}
		}
		r.InputTcpjson.Pipeline = types.StringPointerValue(resp.InputTcpjson.Pipeline)
		r.InputTcpjson.Port = types.Float64Value(resp.InputTcpjson.Port)
		if resp.InputTcpjson.Pq == nil {
			r.InputTcpjson.Pq = nil
		} else {
			r.InputTcpjson.Pq = &tfTypes.InputTcpjsonPq{}
			r.InputTcpjson.Pq.CommitFrequency = types.Float64PointerValue(resp.InputTcpjson.Pq.CommitFrequency)
			if resp.InputTcpjson.Pq.Compress != nil {
				r.InputTcpjson.Pq.Compress = types.StringValue(string(*resp.InputTcpjson.Pq.Compress))
			} else {
				r.InputTcpjson.Pq.Compress = types.StringNull()
			}
			r.InputTcpjson.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputTcpjson.Pq.MaxBufferSize)
			r.InputTcpjson.Pq.MaxFileSize = types.StringPointerValue(resp.InputTcpjson.Pq.MaxFileSize)
			r.InputTcpjson.Pq.MaxSize = types.StringPointerValue(resp.InputTcpjson.Pq.MaxSize)
			if resp.InputTcpjson.Pq.Mode != nil {
				r.InputTcpjson.Pq.Mode = types.StringValue(string(*resp.InputTcpjson.Pq.Mode))
			} else {
				r.InputTcpjson.Pq.Mode = types.StringNull()
			}
			r.InputTcpjson.Pq.Path = types.StringPointerValue(resp.InputTcpjson.Pq.Path)
		}
		r.InputTcpjson.PqEnabled = types.BoolPointerValue(resp.InputTcpjson.PqEnabled)
		r.InputTcpjson.SendToRoutes = types.BoolPointerValue(resp.InputTcpjson.SendToRoutes)
		r.InputTcpjson.SocketEndingMaxWait = types.Float64PointerValue(resp.InputTcpjson.SocketEndingMaxWait)
		r.InputTcpjson.SocketIdleTimeout = types.Float64PointerValue(resp.InputTcpjson.SocketIdleTimeout)
		r.InputTcpjson.SocketMaxLifespan = types.Float64PointerValue(resp.InputTcpjson.SocketMaxLifespan)
		r.InputTcpjson.Streamtags = make([]types.String, 0, len(resp.InputTcpjson.Streamtags))
		for _, v := range resp.InputTcpjson.Streamtags {
			r.InputTcpjson.Streamtags = append(r.InputTcpjson.Streamtags, types.StringValue(v))
		}
		r.InputTcpjson.TextSecret = types.StringPointerValue(resp.InputTcpjson.TextSecret)
		if resp.InputTcpjson.TLS == nil {
			r.InputTcpjson.TLS = nil
		} else {
			r.InputTcpjson.TLS = &tfTypes.InputTcpjsonTLSSettingsServerSide{}
			r.InputTcpjson.TLS.CaPath = types.StringPointerValue(resp.InputTcpjson.TLS.CaPath)
			r.InputTcpjson.TLS.CertificateName = types.StringPointerValue(resp.InputTcpjson.TLS.CertificateName)
			r.InputTcpjson.TLS.CertPath = types.StringPointerValue(resp.InputTcpjson.TLS.CertPath)
			if resp.InputTcpjson.TLS.CommonNameRegex == nil {
				r.InputTcpjson.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult21, _ := json.Marshal(resp.InputTcpjson.TLS.CommonNameRegex)
				r.InputTcpjson.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult21))
			}
			r.InputTcpjson.TLS.Disabled = types.BoolPointerValue(resp.InputTcpjson.TLS.Disabled)
			if resp.InputTcpjson.TLS.MaxVersion != nil {
				r.InputTcpjson.TLS.MaxVersion = types.StringValue(string(*resp.InputTcpjson.TLS.MaxVersion))
			} else {
				r.InputTcpjson.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputTcpjson.TLS.MinVersion != nil {
				r.InputTcpjson.TLS.MinVersion = types.StringValue(string(*resp.InputTcpjson.TLS.MinVersion))
			} else {
				r.InputTcpjson.TLS.MinVersion = types.StringNull()
			}
			r.InputTcpjson.TLS.Passphrase = types.StringPointerValue(resp.InputTcpjson.TLS.Passphrase)
			r.InputTcpjson.TLS.PrivKeyPath = types.StringPointerValue(resp.InputTcpjson.TLS.PrivKeyPath)
			if resp.InputTcpjson.TLS.RejectUnauthorized == nil {
				r.InputTcpjson.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult21, _ := json.Marshal(resp.InputTcpjson.TLS.RejectUnauthorized)
				r.InputTcpjson.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult21))
			}
			r.InputTcpjson.TLS.RequestCert = types.BoolPointerValue(resp.InputTcpjson.TLS.RequestCert)
		}
		if resp.InputTcpjson.Type != nil {
			r.InputTcpjson.Type = types.StringValue(string(*resp.InputTcpjson.Type))
		} else {
			r.InputTcpjson.Type = types.StringNull()
		}
	}
	if resp.InputWef != nil {
		r.InputWef = &tfTypes.InputWef{}
		r.InputWef.AllowMachineIDMismatch = types.BoolPointerValue(resp.InputWef.AllowMachineIDMismatch)
		if resp.InputWef.AuthMethod != nil {
			r.InputWef.AuthMethod = types.StringValue(string(*resp.InputWef.AuthMethod))
		} else {
			r.InputWef.AuthMethod = types.StringNull()
		}
		r.InputWef.CaFingerprint = types.StringPointerValue(resp.InputWef.CaFingerprint)
		r.InputWef.CaptureHeaders = types.BoolPointerValue(resp.InputWef.CaptureHeaders)
		r.InputWef.Connections = []tfTypes.InputWefConnection{}
		if len(r.InputWef.Connections) > len(resp.InputWef.Connections) {
			r.InputWef.Connections = r.InputWef.Connections[:len(resp.InputWef.Connections)]
		}
		for connectionsCount55, connectionsItem55 := range resp.InputWef.Connections {
			var connections55 tfTypes.InputWefConnection
			connections55.Output = types.StringValue(connectionsItem55.Output)
			connections55.Pipeline = types.StringPointerValue(connectionsItem55.Pipeline)
			if connectionsCount55+1 > len(r.InputWef.Connections) {
				r.InputWef.Connections = append(r.InputWef.Connections, connections55)
			} else {
				r.InputWef.Connections[connectionsCount55].Output = connections55.Output
				r.InputWef.Connections[connectionsCount55].Pipeline = connections55.Pipeline
			}
		}
		r.InputWef.Description = types.StringPointerValue(resp.InputWef.Description)
		r.InputWef.Disabled = types.BoolPointerValue(resp.InputWef.Disabled)
		r.InputWef.EnableHealthCheck = types.BoolPointerValue(resp.InputWef.EnableHealthCheck)
		r.InputWef.EnableProxyHeader = types.BoolPointerValue(resp.InputWef.EnableProxyHeader)
		r.InputWef.Environment = types.StringPointerValue(resp.InputWef.Environment)
		r.InputWef.Host = types.StringPointerValue(resp.InputWef.Host)
		r.InputWef.ID = types.StringPointerValue(resp.InputWef.ID)
		r.InputWef.IPAllowlistRegex = types.StringPointerValue(resp.InputWef.IPAllowlistRegex)
		r.InputWef.IPDenylistRegex = types.StringPointerValue(resp.InputWef.IPDenylistRegex)
		r.InputWef.KeepAliveTimeout = types.Float64PointerValue(resp.InputWef.KeepAliveTimeout)
		r.InputWef.Keytab = types.StringPointerValue(resp.InputWef.Keytab)
		r.InputWef.LogFingerprintMismatch = types.BoolPointerValue(resp.InputWef.LogFingerprintMismatch)
		r.InputWef.MaxActiveReq = types.Float64PointerValue(resp.InputWef.MaxActiveReq)
		r.InputWef.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputWef.MaxRequestsPerSocket)
		r.InputWef.Metadata = []tfTypes.InputWefMetadatum{}
		if len(r.InputWef.Metadata) > len(resp.InputWef.Metadata) {
			r.InputWef.Metadata = r.InputWef.Metadata[:len(resp.InputWef.Metadata)]
		}
		for metadataCount58, metadataItem58 := range resp.InputWef.Metadata {
			var metadata58 tfTypes.InputWefMetadatum
			metadata58.Name = types.StringValue(metadataItem58.Name)
			metadata58.Value = types.StringValue(metadataItem58.Value)
			if metadataCount58+1 > len(r.InputWef.Metadata) {
				r.InputWef.Metadata = append(r.InputWef.Metadata, metadata58)
			} else {
				r.InputWef.Metadata[metadataCount58].Name = metadata58.Name
				r.InputWef.Metadata[metadataCount58].Value = metadata58.Value
			}
		}
		r.InputWef.Pipeline = types.StringPointerValue(resp.InputWef.Pipeline)
		r.InputWef.Port = types.Float64PointerValue(resp.InputWef.Port)
		if resp.InputWef.Pq == nil {
			r.InputWef.Pq = nil
		} else {
			r.InputWef.Pq = &tfTypes.InputWefPq{}
			r.InputWef.Pq.CommitFrequency = types.Float64PointerValue(resp.InputWef.Pq.CommitFrequency)
			if resp.InputWef.Pq.Compress != nil {
				r.InputWef.Pq.Compress = types.StringValue(string(*resp.InputWef.Pq.Compress))
			} else {
				r.InputWef.Pq.Compress = types.StringNull()
			}
			r.InputWef.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputWef.Pq.MaxBufferSize)
			r.InputWef.Pq.MaxFileSize = types.StringPointerValue(resp.InputWef.Pq.MaxFileSize)
			r.InputWef.Pq.MaxSize = types.StringPointerValue(resp.InputWef.Pq.MaxSize)
			if resp.InputWef.Pq.Mode != nil {
				r.InputWef.Pq.Mode = types.StringValue(string(*resp.InputWef.Pq.Mode))
			} else {
				r.InputWef.Pq.Mode = types.StringNull()
			}
			r.InputWef.Pq.Path = types.StringPointerValue(resp.InputWef.Pq.Path)
		}
		r.InputWef.PqEnabled = types.BoolPointerValue(resp.InputWef.PqEnabled)
		r.InputWef.Principal = types.StringPointerValue(resp.InputWef.Principal)
		r.InputWef.SendToRoutes = types.BoolPointerValue(resp.InputWef.SendToRoutes)
		r.InputWef.SocketTimeout = types.Float64PointerValue(resp.InputWef.SocketTimeout)
		r.InputWef.Streamtags = make([]types.String, 0, len(resp.InputWef.Streamtags))
		for _, v := range resp.InputWef.Streamtags {
			r.InputWef.Streamtags = append(r.InputWef.Streamtags, types.StringValue(v))
		}
		r.InputWef.Subscriptions = []tfTypes.InputWefSubscription{}
		if len(r.InputWef.Subscriptions) > len(resp.InputWef.Subscriptions) {
			r.InputWef.Subscriptions = r.InputWef.Subscriptions[:len(resp.InputWef.Subscriptions)]
		}
		for subscriptionsCount, subscriptionsItem := range resp.InputWef.Subscriptions {
			var subscriptions tfTypes.InputWefSubscription
			subscriptions.BatchTimeout = types.Float64PointerValue(subscriptionsItem.BatchTimeout)
			subscriptions.Compress = types.BoolPointerValue(subscriptionsItem.Compress)
			if subscriptionsItem.ContentFormat != nil {
				subscriptions.ContentFormat = types.StringValue(string(*subscriptionsItem.ContentFormat))
			} else {
				subscriptions.ContentFormat = types.StringNull()
			}
			subscriptions.HeartbeatInterval = types.Float64PointerValue(subscriptionsItem.HeartbeatInterval)
			subscriptions.ID = types.StringValue(subscriptionsItem.ID)
			subscriptions.Locale = types.StringPointerValue(subscriptionsItem.Locale)
			subscriptions.Metadata = []tfTypes.SubscriptionMetadatum{}
			for metadataCount59, metadataItem59 := range subscriptionsItem.Metadata {
				var metadata59 tfTypes.SubscriptionMetadatum
				metadata59.Name = types.StringValue(metadataItem59.Name)
				metadata59.Value = types.StringValue(metadataItem59.Value)
				if metadataCount59+1 > len(subscriptions.Metadata) {
					subscriptions.Metadata = append(subscriptions.Metadata, metadata59)
				} else {
					subscriptions.Metadata[metadataCount59].Name = metadata59.Name
					subscriptions.Metadata[metadataCount59].Value = metadata59.Value
				}
			}
			if subscriptionsItem.QuerySelector != nil {
				subscriptions.QuerySelector = types.StringValue(string(*subscriptionsItem.QuerySelector))
			} else {
				subscriptions.QuerySelector = types.StringNull()
			}
			subscriptions.ReadExistingEvents = types.BoolPointerValue(subscriptionsItem.ReadExistingEvents)
			subscriptions.SendBookmarks = types.BoolPointerValue(subscriptionsItem.SendBookmarks)
			subscriptions.SubscriptionName = types.StringValue(subscriptionsItem.SubscriptionName)
			subscriptions.Targets = make([]types.String, 0, len(subscriptionsItem.Targets))
			for _, v := range subscriptionsItem.Targets {
				subscriptions.Targets = append(subscriptions.Targets, types.StringValue(v))
			}
			subscriptions.Version = types.StringPointerValue(subscriptionsItem.Version)
			if subscriptionsCount+1 > len(r.InputWef.Subscriptions) {
				r.InputWef.Subscriptions = append(r.InputWef.Subscriptions, subscriptions)
			} else {
				r.InputWef.Subscriptions[subscriptionsCount].BatchTimeout = subscriptions.BatchTimeout
				r.InputWef.Subscriptions[subscriptionsCount].Compress = subscriptions.Compress
				r.InputWef.Subscriptions[subscriptionsCount].ContentFormat = subscriptions.ContentFormat
				r.InputWef.Subscriptions[subscriptionsCount].HeartbeatInterval = subscriptions.HeartbeatInterval
				r.InputWef.Subscriptions[subscriptionsCount].ID = subscriptions.ID
				r.InputWef.Subscriptions[subscriptionsCount].Locale = subscriptions.Locale
				r.InputWef.Subscriptions[subscriptionsCount].Metadata = subscriptions.Metadata
				r.InputWef.Subscriptions[subscriptionsCount].QuerySelector = subscriptions.QuerySelector
				r.InputWef.Subscriptions[subscriptionsCount].ReadExistingEvents = subscriptions.ReadExistingEvents
				r.InputWef.Subscriptions[subscriptionsCount].SendBookmarks = subscriptions.SendBookmarks
				r.InputWef.Subscriptions[subscriptionsCount].SubscriptionName = subscriptions.SubscriptionName
				r.InputWef.Subscriptions[subscriptionsCount].Targets = subscriptions.Targets
				r.InputWef.Subscriptions[subscriptionsCount].Version = subscriptions.Version
			}
		}
		if resp.InputWef.TLS == nil {
			r.InputWef.TLS = nil
		} else {
			r.InputWef.TLS = &tfTypes.MTLSSettings{}
			r.InputWef.TLS.CaPath = types.StringValue(resp.InputWef.TLS.CaPath)
			r.InputWef.TLS.CertificateName = types.StringPointerValue(resp.InputWef.TLS.CertificateName)
			r.InputWef.TLS.CertPath = types.StringValue(resp.InputWef.TLS.CertPath)
			r.InputWef.TLS.CommonNameRegex = types.StringPointerValue(resp.InputWef.TLS.CommonNameRegex)
			r.InputWef.TLS.Disabled = types.BoolPointerValue(resp.InputWef.TLS.Disabled)
			if resp.InputWef.TLS.Keytab == nil {
				r.InputWef.TLS.Keytab = types.StringNull()
			} else {
				keytabResult, _ := json.Marshal(resp.InputWef.TLS.Keytab)
				r.InputWef.TLS.Keytab = types.StringValue(string(keytabResult))
			}
			if resp.InputWef.TLS.MaxVersion != nil {
				r.InputWef.TLS.MaxVersion = types.StringValue(string(*resp.InputWef.TLS.MaxVersion))
			} else {
				r.InputWef.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputWef.TLS.MinVersion != nil {
				r.InputWef.TLS.MinVersion = types.StringValue(string(*resp.InputWef.TLS.MinVersion))
			} else {
				r.InputWef.TLS.MinVersion = types.StringNull()
			}
			r.InputWef.TLS.OcspCheck = types.BoolPointerValue(resp.InputWef.TLS.OcspCheck)
			r.InputWef.TLS.OcspCheckFailClose = types.BoolPointerValue(resp.InputWef.TLS.OcspCheckFailClose)
			r.InputWef.TLS.Passphrase = types.StringPointerValue(resp.InputWef.TLS.Passphrase)
			if resp.InputWef.TLS.Principal == nil {
				r.InputWef.TLS.Principal = types.StringNull()
			} else {
				principalResult, _ := json.Marshal(resp.InputWef.TLS.Principal)
				r.InputWef.TLS.Principal = types.StringValue(string(principalResult))
			}
			r.InputWef.TLS.PrivKeyPath = types.StringValue(resp.InputWef.TLS.PrivKeyPath)
			r.InputWef.TLS.RejectUnauthorized = types.BoolPointerValue(resp.InputWef.TLS.RejectUnauthorized)
			r.InputWef.TLS.RequestCert = types.BoolPointerValue(resp.InputWef.TLS.RequestCert)
		}
		if resp.InputWef.Type != nil {
			r.InputWef.Type = types.StringValue(string(*resp.InputWef.Type))
		} else {
			r.InputWef.Type = types.StringNull()
		}
	}
	if resp.InputWindowsMetrics != nil {
		r.InputWindowsMetrics = &tfTypes.InputWindowsMetrics{}
		r.InputWindowsMetrics.Connections = []tfTypes.InputWindowsMetricsConnection{}
		if len(r.InputWindowsMetrics.Connections) > len(resp.InputWindowsMetrics.Connections) {
			r.InputWindowsMetrics.Connections = r.InputWindowsMetrics.Connections[:len(resp.InputWindowsMetrics.Connections)]
		}
		for connectionsCount56, connectionsItem56 := range resp.InputWindowsMetrics.Connections {
			var connections56 tfTypes.InputWindowsMetricsConnection
			connections56.Output = types.StringValue(connectionsItem56.Output)
			connections56.Pipeline = types.StringPointerValue(connectionsItem56.Pipeline)
			if connectionsCount56+1 > len(r.InputWindowsMetrics.Connections) {
				r.InputWindowsMetrics.Connections = append(r.InputWindowsMetrics.Connections, connections56)
			} else {
				r.InputWindowsMetrics.Connections[connectionsCount56].Output = connections56.Output
				r.InputWindowsMetrics.Connections[connectionsCount56].Pipeline = connections56.Pipeline
			}
		}
		r.InputWindowsMetrics.Description = types.StringPointerValue(resp.InputWindowsMetrics.Description)
		r.InputWindowsMetrics.Disabled = types.BoolPointerValue(resp.InputWindowsMetrics.Disabled)
		r.InputWindowsMetrics.DisableNativeModule = types.BoolPointerValue(resp.InputWindowsMetrics.DisableNativeModule)
		r.InputWindowsMetrics.Environment = types.StringPointerValue(resp.InputWindowsMetrics.Environment)
		if resp.InputWindowsMetrics.Host == nil {
			r.InputWindowsMetrics.Host = nil
		} else {
			r.InputWindowsMetrics.Host = &tfTypes.InputWindowsMetricsHost{}
			if resp.InputWindowsMetrics.Host.Custom == nil {
				r.InputWindowsMetrics.Host.Custom = nil
			} else {
				r.InputWindowsMetrics.Host.Custom = &tfTypes.InputWindowsMetricsCustom{}
				if resp.InputWindowsMetrics.Host.Custom.CPU == nil {
					r.InputWindowsMetrics.Host.Custom.CPU = nil
				} else {
					r.InputWindowsMetrics.Host.Custom.CPU = &tfTypes.InputWindowsMetricsCPU{}
					r.InputWindowsMetrics.Host.Custom.CPU.Detail = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.CPU.Detail)
					if resp.InputWindowsMetrics.Host.Custom.CPU.Mode != nil {
						r.InputWindowsMetrics.Host.Custom.CPU.Mode = types.StringValue(string(*resp.InputWindowsMetrics.Host.Custom.CPU.Mode))
					} else {
						r.InputWindowsMetrics.Host.Custom.CPU.Mode = types.StringNull()
					}
					r.InputWindowsMetrics.Host.Custom.CPU.PerCPU = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.CPU.PerCPU)
					r.InputWindowsMetrics.Host.Custom.CPU.Time = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.CPU.Time)
				}
				if resp.InputWindowsMetrics.Host.Custom.Disk == nil {
					r.InputWindowsMetrics.Host.Custom.Disk = nil
				} else {
					r.InputWindowsMetrics.Host.Custom.Disk = &tfTypes.InputWindowsMetricsDisk{}
					if resp.InputWindowsMetrics.Host.Custom.Disk.Mode != nil {
						r.InputWindowsMetrics.Host.Custom.Disk.Mode = types.StringValue(string(*resp.InputWindowsMetrics.Host.Custom.Disk.Mode))
					} else {
						r.InputWindowsMetrics.Host.Custom.Disk.Mode = types.StringNull()
					}
					r.InputWindowsMetrics.Host.Custom.Disk.PerVolume = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.Disk.PerVolume)
					r.InputWindowsMetrics.Host.Custom.Disk.Volumes = make([]types.String, 0, len(resp.InputWindowsMetrics.Host.Custom.Disk.Volumes))
					for _, v := range resp.InputWindowsMetrics.Host.Custom.Disk.Volumes {
						r.InputWindowsMetrics.Host.Custom.Disk.Volumes = append(r.InputWindowsMetrics.Host.Custom.Disk.Volumes, types.StringValue(v))
					}
				}
				if resp.InputWindowsMetrics.Host.Custom.Memory == nil {
					r.InputWindowsMetrics.Host.Custom.Memory = nil
				} else {
					r.InputWindowsMetrics.Host.Custom.Memory = &tfTypes.InputWindowsMetricsMemory{}
					r.InputWindowsMetrics.Host.Custom.Memory.Detail = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.Memory.Detail)
					if resp.InputWindowsMetrics.Host.Custom.Memory.Mode != nil {
						r.InputWindowsMetrics.Host.Custom.Memory.Mode = types.StringValue(string(*resp.InputWindowsMetrics.Host.Custom.Memory.Mode))
					} else {
						r.InputWindowsMetrics.Host.Custom.Memory.Mode = types.StringNull()
					}
				}
				if resp.InputWindowsMetrics.Host.Custom.Network == nil {
					r.InputWindowsMetrics.Host.Custom.Network = nil
				} else {
					r.InputWindowsMetrics.Host.Custom.Network = &tfTypes.InputWindowsMetricsNetwork{}
					r.InputWindowsMetrics.Host.Custom.Network.Detail = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.Network.Detail)
					r.InputWindowsMetrics.Host.Custom.Network.Devices = make([]types.String, 0, len(resp.InputWindowsMetrics.Host.Custom.Network.Devices))
					for _, v := range resp.InputWindowsMetrics.Host.Custom.Network.Devices {
						r.InputWindowsMetrics.Host.Custom.Network.Devices = append(r.InputWindowsMetrics.Host.Custom.Network.Devices, types.StringValue(v))
					}
					if resp.InputWindowsMetrics.Host.Custom.Network.Mode != nil {
						r.InputWindowsMetrics.Host.Custom.Network.Mode = types.StringValue(string(*resp.InputWindowsMetrics.Host.Custom.Network.Mode))
					} else {
						r.InputWindowsMetrics.Host.Custom.Network.Mode = types.StringNull()
					}
					r.InputWindowsMetrics.Host.Custom.Network.PerInterface = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.Network.PerInterface)
				}
				if resp.InputWindowsMetrics.Host.Custom.System == nil {
					r.InputWindowsMetrics.Host.Custom.System = nil
				} else {
					r.InputWindowsMetrics.Host.Custom.System = &tfTypes.InputWindowsMetricsSystem{}
					r.InputWindowsMetrics.Host.Custom.System.Detail = types.BoolPointerValue(resp.InputWindowsMetrics.Host.Custom.System.Detail)
					if resp.InputWindowsMetrics.Host.Custom.System.Mode != nil {
						r.InputWindowsMetrics.Host.Custom.System.Mode = types.StringValue(string(*resp.InputWindowsMetrics.Host.Custom.System.Mode))
					} else {
						r.InputWindowsMetrics.Host.Custom.System.Mode = types.StringNull()
					}
				}
			}
			if resp.InputWindowsMetrics.Host.Mode != nil {
				r.InputWindowsMetrics.Host.Mode = types.StringValue(string(*resp.InputWindowsMetrics.Host.Mode))
			} else {
				r.InputWindowsMetrics.Host.Mode = types.StringNull()
			}
		}
		r.InputWindowsMetrics.ID = types.StringValue(resp.InputWindowsMetrics.ID)
		r.InputWindowsMetrics.Interval = types.Float64PointerValue(resp.InputWindowsMetrics.Interval)
		r.InputWindowsMetrics.Metadata = []tfTypes.InputWindowsMetricsMetadatum{}
		if len(r.InputWindowsMetrics.Metadata) > len(resp.InputWindowsMetrics.Metadata) {
			r.InputWindowsMetrics.Metadata = r.InputWindowsMetrics.Metadata[:len(resp.InputWindowsMetrics.Metadata)]
		}
		for metadataCount60, metadataItem60 := range resp.InputWindowsMetrics.Metadata {
			var metadata60 tfTypes.InputWindowsMetricsMetadatum
			metadata60.Name = types.StringValue(metadataItem60.Name)
			metadata60.Value = types.StringValue(metadataItem60.Value)
			if metadataCount60+1 > len(r.InputWindowsMetrics.Metadata) {
				r.InputWindowsMetrics.Metadata = append(r.InputWindowsMetrics.Metadata, metadata60)
			} else {
				r.InputWindowsMetrics.Metadata[metadataCount60].Name = metadata60.Name
				r.InputWindowsMetrics.Metadata[metadataCount60].Value = metadata60.Value
			}
		}
		if resp.InputWindowsMetrics.Persistence == nil {
			r.InputWindowsMetrics.Persistence = nil
		} else {
			r.InputWindowsMetrics.Persistence = &tfTypes.InputWindowsMetricsPersistence{}
			if resp.InputWindowsMetrics.Persistence.Compress != nil {
				r.InputWindowsMetrics.Persistence.Compress = types.StringValue(string(*resp.InputWindowsMetrics.Persistence.Compress))
			} else {
				r.InputWindowsMetrics.Persistence.Compress = types.StringNull()
			}
			r.InputWindowsMetrics.Persistence.DestPath = types.StringPointerValue(resp.InputWindowsMetrics.Persistence.DestPath)
			r.InputWindowsMetrics.Persistence.Enable = types.BoolPointerValue(resp.InputWindowsMetrics.Persistence.Enable)
			r.InputWindowsMetrics.Persistence.MaxDataSize = types.StringPointerValue(resp.InputWindowsMetrics.Persistence.MaxDataSize)
			r.InputWindowsMetrics.Persistence.MaxDataTime = types.StringPointerValue(resp.InputWindowsMetrics.Persistence.MaxDataTime)
			r.InputWindowsMetrics.Persistence.TimeWindow = types.StringPointerValue(resp.InputWindowsMetrics.Persistence.TimeWindow)
		}
		r.InputWindowsMetrics.Pipeline = types.StringPointerValue(resp.InputWindowsMetrics.Pipeline)
		if resp.InputWindowsMetrics.Pq == nil {
			r.InputWindowsMetrics.Pq = nil
		} else {
			r.InputWindowsMetrics.Pq = &tfTypes.InputWindowsMetricsPq{}
			r.InputWindowsMetrics.Pq.CommitFrequency = types.Float64PointerValue(resp.InputWindowsMetrics.Pq.CommitFrequency)
			if resp.InputWindowsMetrics.Pq.Compress != nil {
				r.InputWindowsMetrics.Pq.Compress = types.StringValue(string(*resp.InputWindowsMetrics.Pq.Compress))
			} else {
				r.InputWindowsMetrics.Pq.Compress = types.StringNull()
			}
			r.InputWindowsMetrics.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputWindowsMetrics.Pq.MaxBufferSize)
			r.InputWindowsMetrics.Pq.MaxFileSize = types.StringPointerValue(resp.InputWindowsMetrics.Pq.MaxFileSize)
			r.InputWindowsMetrics.Pq.MaxSize = types.StringPointerValue(resp.InputWindowsMetrics.Pq.MaxSize)
			if resp.InputWindowsMetrics.Pq.Mode != nil {
				r.InputWindowsMetrics.Pq.Mode = types.StringValue(string(*resp.InputWindowsMetrics.Pq.Mode))
			} else {
				r.InputWindowsMetrics.Pq.Mode = types.StringNull()
			}
			r.InputWindowsMetrics.Pq.Path = types.StringPointerValue(resp.InputWindowsMetrics.Pq.Path)
		}
		r.InputWindowsMetrics.PqEnabled = types.BoolPointerValue(resp.InputWindowsMetrics.PqEnabled)
		if resp.InputWindowsMetrics.Process == nil {
			r.InputWindowsMetrics.Process = nil
		} else {
			r.InputWindowsMetrics.Process = &tfTypes.InputWindowsMetricsProcess{}
			r.InputWindowsMetrics.Process.Sets = []tfTypes.InputWindowsMetricsSet{}
			if len(r.InputWindowsMetrics.Process.Sets) > len(resp.InputWindowsMetrics.Process.Sets) {
				r.InputWindowsMetrics.Process.Sets = r.InputWindowsMetrics.Process.Sets[:len(resp.InputWindowsMetrics.Process.Sets)]
			}
			for setsCount1, setsItem1 := range resp.InputWindowsMetrics.Process.Sets {
				var sets1 tfTypes.InputWindowsMetricsSet
				sets1.Filter = types.StringValue(setsItem1.Filter)
				sets1.IncludeChildren = types.BoolPointerValue(setsItem1.IncludeChildren)
				sets1.Name = types.StringValue(setsItem1.Name)
				if setsCount1+1 > len(r.InputWindowsMetrics.Process.Sets) {
					r.InputWindowsMetrics.Process.Sets = append(r.InputWindowsMetrics.Process.Sets, sets1)
				} else {
					r.InputWindowsMetrics.Process.Sets[setsCount1].Filter = sets1.Filter
					r.InputWindowsMetrics.Process.Sets[setsCount1].IncludeChildren = sets1.IncludeChildren
					r.InputWindowsMetrics.Process.Sets[setsCount1].Name = sets1.Name
				}
			}
		}
		r.InputWindowsMetrics.SendToRoutes = types.BoolPointerValue(resp.InputWindowsMetrics.SendToRoutes)
		r.InputWindowsMetrics.Streamtags = make([]types.String, 0, len(resp.InputWindowsMetrics.Streamtags))
		for _, v := range resp.InputWindowsMetrics.Streamtags {
			r.InputWindowsMetrics.Streamtags = append(r.InputWindowsMetrics.Streamtags, types.StringValue(v))
		}
		r.InputWindowsMetrics.Type = types.StringValue(string(resp.InputWindowsMetrics.Type))
	}
	if resp.InputWinEventLogs != nil {
		r.InputWinEventLogs = &tfTypes.InputWinEventLogs{}
		r.InputWinEventLogs.BatchSize = types.Float64PointerValue(resp.InputWinEventLogs.BatchSize)
		r.InputWinEventLogs.Connections = []tfTypes.InputWinEventLogsConnection{}
		if len(r.InputWinEventLogs.Connections) > len(resp.InputWinEventLogs.Connections) {
			r.InputWinEventLogs.Connections = r.InputWinEventLogs.Connections[:len(resp.InputWinEventLogs.Connections)]
		}
		for connectionsCount57, connectionsItem57 := range resp.InputWinEventLogs.Connections {
			var connections57 tfTypes.InputWinEventLogsConnection
			connections57.Output = types.StringValue(connectionsItem57.Output)
			connections57.Pipeline = types.StringPointerValue(connectionsItem57.Pipeline)
			if connectionsCount57+1 > len(r.InputWinEventLogs.Connections) {
				r.InputWinEventLogs.Connections = append(r.InputWinEventLogs.Connections, connections57)
			} else {
				r.InputWinEventLogs.Connections[connectionsCount57].Output = connections57.Output
				r.InputWinEventLogs.Connections[connectionsCount57].Pipeline = connections57.Pipeline
			}
		}
		r.InputWinEventLogs.Description = types.StringPointerValue(resp.InputWinEventLogs.Description)
		r.InputWinEventLogs.Disabled = types.BoolPointerValue(resp.InputWinEventLogs.Disabled)
		r.InputWinEventLogs.DisableNativeModule = types.BoolPointerValue(resp.InputWinEventLogs.DisableNativeModule)
		r.InputWinEventLogs.Environment = types.StringPointerValue(resp.InputWinEventLogs.Environment)
		if resp.InputWinEventLogs.EventFormat != nil {
			r.InputWinEventLogs.EventFormat = types.StringValue(string(*resp.InputWinEventLogs.EventFormat))
		} else {
			r.InputWinEventLogs.EventFormat = types.StringNull()
		}
		r.InputWinEventLogs.ID = types.StringPointerValue(resp.InputWinEventLogs.ID)
		r.InputWinEventLogs.Interval = types.Float64PointerValue(resp.InputWinEventLogs.Interval)
		r.InputWinEventLogs.LogNames = make([]types.String, 0, len(resp.InputWinEventLogs.LogNames))
		for _, v := range resp.InputWinEventLogs.LogNames {
			r.InputWinEventLogs.LogNames = append(r.InputWinEventLogs.LogNames, types.StringValue(v))
		}
		r.InputWinEventLogs.MaxEventBytes = types.Float64PointerValue(resp.InputWinEventLogs.MaxEventBytes)
		r.InputWinEventLogs.Metadata = []tfTypes.InputWinEventLogsMetadatum{}
		if len(r.InputWinEventLogs.Metadata) > len(resp.InputWinEventLogs.Metadata) {
			r.InputWinEventLogs.Metadata = r.InputWinEventLogs.Metadata[:len(resp.InputWinEventLogs.Metadata)]
		}
		for metadataCount61, metadataItem61 := range resp.InputWinEventLogs.Metadata {
			var metadata61 tfTypes.InputWinEventLogsMetadatum
			metadata61.Name = types.StringValue(metadataItem61.Name)
			metadata61.Value = types.StringValue(metadataItem61.Value)
			if metadataCount61+1 > len(r.InputWinEventLogs.Metadata) {
				r.InputWinEventLogs.Metadata = append(r.InputWinEventLogs.Metadata, metadata61)
			} else {
				r.InputWinEventLogs.Metadata[metadataCount61].Name = metadata61.Name
				r.InputWinEventLogs.Metadata[metadataCount61].Value = metadata61.Value
			}
		}
		r.InputWinEventLogs.Pipeline = types.StringPointerValue(resp.InputWinEventLogs.Pipeline)
		if resp.InputWinEventLogs.Pq == nil {
			r.InputWinEventLogs.Pq = nil
		} else {
			r.InputWinEventLogs.Pq = &tfTypes.InputWinEventLogsPq{}
			r.InputWinEventLogs.Pq.CommitFrequency = types.Float64PointerValue(resp.InputWinEventLogs.Pq.CommitFrequency)
			if resp.InputWinEventLogs.Pq.Compress != nil {
				r.InputWinEventLogs.Pq.Compress = types.StringValue(string(*resp.InputWinEventLogs.Pq.Compress))
			} else {
				r.InputWinEventLogs.Pq.Compress = types.StringNull()
			}
			r.InputWinEventLogs.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputWinEventLogs.Pq.MaxBufferSize)
			r.InputWinEventLogs.Pq.MaxFileSize = types.StringPointerValue(resp.InputWinEventLogs.Pq.MaxFileSize)
			r.InputWinEventLogs.Pq.MaxSize = types.StringPointerValue(resp.InputWinEventLogs.Pq.MaxSize)
			if resp.InputWinEventLogs.Pq.Mode != nil {
				r.InputWinEventLogs.Pq.Mode = types.StringValue(string(*resp.InputWinEventLogs.Pq.Mode))
			} else {
				r.InputWinEventLogs.Pq.Mode = types.StringNull()
			}
			r.InputWinEventLogs.Pq.Path = types.StringPointerValue(resp.InputWinEventLogs.Pq.Path)
		}
		r.InputWinEventLogs.PqEnabled = types.BoolPointerValue(resp.InputWinEventLogs.PqEnabled)
		if resp.InputWinEventLogs.ReadMode != nil {
			r.InputWinEventLogs.ReadMode = types.StringValue(string(*resp.InputWinEventLogs.ReadMode))
		} else {
			r.InputWinEventLogs.ReadMode = types.StringNull()
		}
		r.InputWinEventLogs.SendToRoutes = types.BoolPointerValue(resp.InputWinEventLogs.SendToRoutes)
		r.InputWinEventLogs.Streamtags = make([]types.String, 0, len(resp.InputWinEventLogs.Streamtags))
		for _, v := range resp.InputWinEventLogs.Streamtags {
			r.InputWinEventLogs.Streamtags = append(r.InputWinEventLogs.Streamtags, types.StringValue(v))
		}
		r.InputWinEventLogs.Type = types.StringValue(string(resp.InputWinEventLogs.Type))
	}
	if resp.InputWiz != nil {
		r.InputWiz = &tfTypes.InputWiz{}
		r.InputWiz.AuthAudienceOverride = types.StringPointerValue(resp.InputWiz.AuthAudienceOverride)
		if resp.InputWiz.AuthType != nil {
			r.InputWiz.AuthType = types.StringValue(string(*resp.InputWiz.AuthType))
		} else {
			r.InputWiz.AuthType = types.StringNull()
		}
		r.InputWiz.AuthURL = types.StringValue(resp.InputWiz.AuthURL)
		r.InputWiz.ClientID = types.StringValue(resp.InputWiz.ClientID)
		r.InputWiz.ClientSecret = types.StringPointerValue(resp.InputWiz.ClientSecret)
		r.InputWiz.Connections = []tfTypes.InputWizConnection{}
		if len(r.InputWiz.Connections) > len(resp.InputWiz.Connections) {
			r.InputWiz.Connections = r.InputWiz.Connections[:len(resp.InputWiz.Connections)]
		}
		for connectionsCount58, connectionsItem58 := range resp.InputWiz.Connections {
			var connections58 tfTypes.InputWizConnection
			connections58.Output = types.StringValue(connectionsItem58.Output)
			connections58.Pipeline = types.StringPointerValue(connectionsItem58.Pipeline)
			if connectionsCount58+1 > len(r.InputWiz.Connections) {
				r.InputWiz.Connections = append(r.InputWiz.Connections, connections58)
			} else {
				r.InputWiz.Connections[connectionsCount58].Output = connections58.Output
				r.InputWiz.Connections[connectionsCount58].Pipeline = connections58.Pipeline
			}
		}
		r.InputWiz.ContentConfig = []tfTypes.InputWizContentConfig{}
		if len(r.InputWiz.ContentConfig) > len(resp.InputWiz.ContentConfig) {
			r.InputWiz.ContentConfig = r.InputWiz.ContentConfig[:len(resp.InputWiz.ContentConfig)]
		}
		for contentConfigCount2, contentConfigItem2 := range resp.InputWiz.ContentConfig {
			var contentConfig2 tfTypes.InputWizContentConfig
			contentConfig2.ContentDescription = types.StringPointerValue(contentConfigItem2.ContentDescription)
			contentConfig2.ContentType = types.StringValue(contentConfigItem2.ContentType)
			contentConfig2.Enabled = types.BoolPointerValue(contentConfigItem2.Enabled)
			if contentConfigCount2+1 > len(r.InputWiz.ContentConfig) {
				r.InputWiz.ContentConfig = append(r.InputWiz.ContentConfig, contentConfig2)
			} else {
				r.InputWiz.ContentConfig[contentConfigCount2].ContentDescription = contentConfig2.ContentDescription
				r.InputWiz.ContentConfig[contentConfigCount2].ContentType = contentConfig2.ContentType
				r.InputWiz.ContentConfig[contentConfigCount2].Enabled = contentConfig2.Enabled
			}
		}
		r.InputWiz.Description = types.StringPointerValue(resp.InputWiz.Description)
		r.InputWiz.Disabled = types.BoolPointerValue(resp.InputWiz.Disabled)
		r.InputWiz.Endpoint = types.StringPointerValue(resp.InputWiz.Endpoint)
		r.InputWiz.Environment = types.StringPointerValue(resp.InputWiz.Environment)
		r.InputWiz.ID = types.StringPointerValue(resp.InputWiz.ID)
		r.InputWiz.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.InputWiz.IgnoreGroupJobsLimit)
		r.InputWiz.KeepAliveTime = types.Float64PointerValue(resp.InputWiz.KeepAliveTime)
		r.InputWiz.MaxMissedKeepAlives = types.Float64PointerValue(resp.InputWiz.MaxMissedKeepAlives)
		r.InputWiz.Metadata = []tfTypes.InputWizMetadatum{}
		if len(r.InputWiz.Metadata) > len(resp.InputWiz.Metadata) {
			r.InputWiz.Metadata = r.InputWiz.Metadata[:len(resp.InputWiz.Metadata)]
		}
		for metadataCount62, metadataItem62 := range resp.InputWiz.Metadata {
			var metadata62 tfTypes.InputWizMetadatum
			metadata62.Name = types.StringValue(metadataItem62.Name)
			metadata62.Value = types.StringValue(metadataItem62.Value)
			if metadataCount62+1 > len(r.InputWiz.Metadata) {
				r.InputWiz.Metadata = append(r.InputWiz.Metadata, metadata62)
			} else {
				r.InputWiz.Metadata[metadataCount62].Name = metadata62.Name
				r.InputWiz.Metadata[metadataCount62].Value = metadata62.Value
			}
		}
		r.InputWiz.Pipeline = types.StringPointerValue(resp.InputWiz.Pipeline)
		if resp.InputWiz.Pq == nil {
			r.InputWiz.Pq = nil
		} else {
			r.InputWiz.Pq = &tfTypes.InputWizPq{}
			r.InputWiz.Pq.CommitFrequency = types.Float64PointerValue(resp.InputWiz.Pq.CommitFrequency)
			if resp.InputWiz.Pq.Compress != nil {
				r.InputWiz.Pq.Compress = types.StringValue(string(*resp.InputWiz.Pq.Compress))
			} else {
				r.InputWiz.Pq.Compress = types.StringNull()
			}
			r.InputWiz.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputWiz.Pq.MaxBufferSize)
			r.InputWiz.Pq.MaxFileSize = types.StringPointerValue(resp.InputWiz.Pq.MaxFileSize)
			r.InputWiz.Pq.MaxSize = types.StringPointerValue(resp.InputWiz.Pq.MaxSize)
			if resp.InputWiz.Pq.Mode != nil {
				r.InputWiz.Pq.Mode = types.StringValue(string(*resp.InputWiz.Pq.Mode))
			} else {
				r.InputWiz.Pq.Mode = types.StringNull()
			}
			r.InputWiz.Pq.Path = types.StringPointerValue(resp.InputWiz.Pq.Path)
		}
		r.InputWiz.PqEnabled = types.BoolPointerValue(resp.InputWiz.PqEnabled)
		r.InputWiz.RequestTimeout = types.Float64PointerValue(resp.InputWiz.RequestTimeout)
		if resp.InputWiz.RetryRules == nil {
			r.InputWiz.RetryRules = nil
		} else {
			r.InputWiz.RetryRules = &tfTypes.InputWizRetryRules{}
			r.InputWiz.RetryRules.Codes = make([]types.Float64, 0, len(resp.InputWiz.RetryRules.Codes))
			for _, v := range resp.InputWiz.RetryRules.Codes {
				r.InputWiz.RetryRules.Codes = append(r.InputWiz.RetryRules.Codes, types.Float64Value(v))
			}
			r.InputWiz.RetryRules.EnableHeader = types.BoolPointerValue(resp.InputWiz.RetryRules.EnableHeader)
			r.InputWiz.RetryRules.Interval = types.Float64PointerValue(resp.InputWiz.RetryRules.Interval)
			r.InputWiz.RetryRules.Limit = types.Float64PointerValue(resp.InputWiz.RetryRules.Limit)
			r.InputWiz.RetryRules.Multiplier = types.Float64PointerValue(resp.InputWiz.RetryRules.Multiplier)
			r.InputWiz.RetryRules.RetryConnectReset = types.BoolPointerValue(resp.InputWiz.RetryRules.RetryConnectReset)
			r.InputWiz.RetryRules.RetryConnectTimeout = types.BoolPointerValue(resp.InputWiz.RetryRules.RetryConnectTimeout)
			if resp.InputWiz.RetryRules.Type != nil {
				r.InputWiz.RetryRules.Type = types.StringValue(string(*resp.InputWiz.RetryRules.Type))
			} else {
				r.InputWiz.RetryRules.Type = types.StringNull()
			}
		}
		r.InputWiz.SendToRoutes = types.BoolPointerValue(resp.InputWiz.SendToRoutes)
		r.InputWiz.Streamtags = make([]types.String, 0, len(resp.InputWiz.Streamtags))
		for _, v := range resp.InputWiz.Streamtags {
			r.InputWiz.Streamtags = append(r.InputWiz.Streamtags, types.StringValue(v))
		}
		r.InputWiz.TextSecret = types.StringPointerValue(resp.InputWiz.TextSecret)
		r.InputWiz.TTL = types.StringPointerValue(resp.InputWiz.TTL)
		if resp.InputWiz.Type != nil {
			r.InputWiz.Type = types.StringValue(string(*resp.InputWiz.Type))
		} else {
			r.InputWiz.Type = types.StringNull()
		}
	}
	if resp.InputZscalerHec != nil {
		r.InputZscalerHec = &tfTypes.InputZscalerHec{}
		r.InputZscalerHec.AccessControlAllowHeaders = make([]types.String, 0, len(resp.InputZscalerHec.AccessControlAllowHeaders))
		for _, v := range resp.InputZscalerHec.AccessControlAllowHeaders {
			r.InputZscalerHec.AccessControlAllowHeaders = append(r.InputZscalerHec.AccessControlAllowHeaders, types.StringValue(v))
		}
		r.InputZscalerHec.AccessControlAllowOrigin = make([]types.String, 0, len(resp.InputZscalerHec.AccessControlAllowOrigin))
		for _, v := range resp.InputZscalerHec.AccessControlAllowOrigin {
			r.InputZscalerHec.AccessControlAllowOrigin = append(r.InputZscalerHec.AccessControlAllowOrigin, types.StringValue(v))
		}
		r.InputZscalerHec.ActivityLogSampleRate = types.Float64PointerValue(resp.InputZscalerHec.ActivityLogSampleRate)
		r.InputZscalerHec.AllowedIndexes = make([]types.String, 0, len(resp.InputZscalerHec.AllowedIndexes))
		for _, v := range resp.InputZscalerHec.AllowedIndexes {
			r.InputZscalerHec.AllowedIndexes = append(r.InputZscalerHec.AllowedIndexes, types.StringValue(v))
		}
		r.InputZscalerHec.AuthTokens = []tfTypes.InputZscalerHecAuthToken{}
		if len(r.InputZscalerHec.AuthTokens) > len(resp.InputZscalerHec.AuthTokens) {
			r.InputZscalerHec.AuthTokens = r.InputZscalerHec.AuthTokens[:len(resp.InputZscalerHec.AuthTokens)]
		}
		for authTokensCount2, authTokensItem2 := range resp.InputZscalerHec.AuthTokens {
			var authTokens2 tfTypes.InputZscalerHecAuthToken
			authTokens2.AllowedIndexesAtToken = make([]types.String, 0, len(authTokensItem2.AllowedIndexesAtToken))
			for _, v := range authTokensItem2.AllowedIndexesAtToken {
				authTokens2.AllowedIndexesAtToken = append(authTokens2.AllowedIndexesAtToken, types.StringValue(v))
			}
			if authTokensItem2.AuthType != nil {
				authTokens2.AuthType = types.StringValue(string(*authTokensItem2.AuthType))
			} else {
				authTokens2.AuthType = types.StringNull()
			}
			authTokens2.Description = types.StringPointerValue(authTokensItem2.Description)
			authTokens2.Enabled = types.BoolPointerValue(authTokensItem2.Enabled)
			authTokens2.Metadata = []tfTypes.InputZscalerHecAuthTokenMetadatum{}
			for metadataCount63, metadataItem63 := range authTokensItem2.Metadata {
				var metadata63 tfTypes.InputZscalerHecAuthTokenMetadatum
				metadata63.Name = types.StringValue(metadataItem63.Name)
				metadata63.Value = types.StringValue(metadataItem63.Value)
				if metadataCount63+1 > len(authTokens2.Metadata) {
					authTokens2.Metadata = append(authTokens2.Metadata, metadata63)
				} else {
					authTokens2.Metadata[metadataCount63].Name = metadata63.Name
					authTokens2.Metadata[metadataCount63].Value = metadata63.Value
				}
			}
			tokenResult1, _ := json.Marshal(authTokensItem2.Token)
			authTokens2.Token = types.StringValue(string(tokenResult1))
			if authTokensItem2.TokenSecret == nil {
				authTokens2.TokenSecret = types.StringNull()
			} else {
				tokenSecretResult1, _ := json.Marshal(authTokensItem2.TokenSecret)
				authTokens2.TokenSecret = types.StringValue(string(tokenSecretResult1))
			}
			if authTokensCount2+1 > len(r.InputZscalerHec.AuthTokens) {
				r.InputZscalerHec.AuthTokens = append(r.InputZscalerHec.AuthTokens, authTokens2)
			} else {
				r.InputZscalerHec.AuthTokens[authTokensCount2].AllowedIndexesAtToken = authTokens2.AllowedIndexesAtToken
				r.InputZscalerHec.AuthTokens[authTokensCount2].AuthType = authTokens2.AuthType
				r.InputZscalerHec.AuthTokens[authTokensCount2].Description = authTokens2.Description
				r.InputZscalerHec.AuthTokens[authTokensCount2].Enabled = authTokens2.Enabled
				r.InputZscalerHec.AuthTokens[authTokensCount2].Metadata = authTokens2.Metadata
				r.InputZscalerHec.AuthTokens[authTokensCount2].Token = authTokens2.Token
				r.InputZscalerHec.AuthTokens[authTokensCount2].TokenSecret = authTokens2.TokenSecret
			}
		}
		r.InputZscalerHec.CaptureHeaders = types.BoolPointerValue(resp.InputZscalerHec.CaptureHeaders)
		r.InputZscalerHec.Connections = []tfTypes.InputZscalerHecConnection{}
		if len(r.InputZscalerHec.Connections) > len(resp.InputZscalerHec.Connections) {
			r.InputZscalerHec.Connections = r.InputZscalerHec.Connections[:len(resp.InputZscalerHec.Connections)]
		}
		for connectionsCount59, connectionsItem59 := range resp.InputZscalerHec.Connections {
			var connections59 tfTypes.InputZscalerHecConnection
			connections59.Output = types.StringValue(connectionsItem59.Output)
			connections59.Pipeline = types.StringPointerValue(connectionsItem59.Pipeline)
			if connectionsCount59+1 > len(r.InputZscalerHec.Connections) {
				r.InputZscalerHec.Connections = append(r.InputZscalerHec.Connections, connections59)
			} else {
				r.InputZscalerHec.Connections[connectionsCount59].Output = connections59.Output
				r.InputZscalerHec.Connections[connectionsCount59].Pipeline = connections59.Pipeline
			}
		}
		r.InputZscalerHec.Description = types.StringPointerValue(resp.InputZscalerHec.Description)
		r.InputZscalerHec.Disabled = types.BoolPointerValue(resp.InputZscalerHec.Disabled)
		r.InputZscalerHec.EmitTokenMetrics = types.BoolPointerValue(resp.InputZscalerHec.EmitTokenMetrics)
		if resp.InputZscalerHec.EnableHealthCheck == nil {
			r.InputZscalerHec.EnableHealthCheck = types.StringNull()
		} else {
			enableHealthCheckResult1, _ := json.Marshal(resp.InputZscalerHec.EnableHealthCheck)
			r.InputZscalerHec.EnableHealthCheck = types.StringValue(string(enableHealthCheckResult1))
		}
		r.InputZscalerHec.EnableProxyHeader = types.BoolPointerValue(resp.InputZscalerHec.EnableProxyHeader)
		r.InputZscalerHec.Environment = types.StringPointerValue(resp.InputZscalerHec.Environment)
		r.InputZscalerHec.HecAcks = types.BoolPointerValue(resp.InputZscalerHec.HecAcks)
		r.InputZscalerHec.HecAPI = types.StringPointerValue(resp.InputZscalerHec.HecAPI)
		r.InputZscalerHec.Host = types.StringPointerValue(resp.InputZscalerHec.Host)
		r.InputZscalerHec.ID = types.StringPointerValue(resp.InputZscalerHec.ID)
		r.InputZscalerHec.IPAllowlistRegex = types.StringPointerValue(resp.InputZscalerHec.IPAllowlistRegex)
		r.InputZscalerHec.IPDenylistRegex = types.StringPointerValue(resp.InputZscalerHec.IPDenylistRegex)
		r.InputZscalerHec.KeepAliveTimeout = types.Float64PointerValue(resp.InputZscalerHec.KeepAliveTimeout)
		r.InputZscalerHec.MaxActiveReq = types.Float64PointerValue(resp.InputZscalerHec.MaxActiveReq)
		r.InputZscalerHec.MaxRequestsPerSocket = types.Int64PointerValue(resp.InputZscalerHec.MaxRequestsPerSocket)
		r.InputZscalerHec.Metadata = []tfTypes.InputZscalerHecMetadatum{}
		if len(r.InputZscalerHec.Metadata) > len(resp.InputZscalerHec.Metadata) {
			r.InputZscalerHec.Metadata = r.InputZscalerHec.Metadata[:len(resp.InputZscalerHec.Metadata)]
		}
		for metadataCount64, metadataItem64 := range resp.InputZscalerHec.Metadata {
			var metadata64 tfTypes.InputZscalerHecMetadatum
			metadata64.Name = types.StringValue(metadataItem64.Name)
			metadata64.Value = types.StringValue(metadataItem64.Value)
			if metadataCount64+1 > len(r.InputZscalerHec.Metadata) {
				r.InputZscalerHec.Metadata = append(r.InputZscalerHec.Metadata, metadata64)
			} else {
				r.InputZscalerHec.Metadata[metadataCount64].Name = metadata64.Name
				r.InputZscalerHec.Metadata[metadataCount64].Value = metadata64.Value
			}
		}
		r.InputZscalerHec.Pipeline = types.StringPointerValue(resp.InputZscalerHec.Pipeline)
		r.InputZscalerHec.Port = types.Float64Value(resp.InputZscalerHec.Port)
		if resp.InputZscalerHec.Pq == nil {
			r.InputZscalerHec.Pq = nil
		} else {
			r.InputZscalerHec.Pq = &tfTypes.InputZscalerHecPq{}
			r.InputZscalerHec.Pq.CommitFrequency = types.Float64PointerValue(resp.InputZscalerHec.Pq.CommitFrequency)
			if resp.InputZscalerHec.Pq.Compress != nil {
				r.InputZscalerHec.Pq.Compress = types.StringValue(string(*resp.InputZscalerHec.Pq.Compress))
			} else {
				r.InputZscalerHec.Pq.Compress = types.StringNull()
			}
			r.InputZscalerHec.Pq.MaxBufferSize = types.Float64PointerValue(resp.InputZscalerHec.Pq.MaxBufferSize)
			r.InputZscalerHec.Pq.MaxFileSize = types.StringPointerValue(resp.InputZscalerHec.Pq.MaxFileSize)
			r.InputZscalerHec.Pq.MaxSize = types.StringPointerValue(resp.InputZscalerHec.Pq.MaxSize)
			if resp.InputZscalerHec.Pq.Mode != nil {
				r.InputZscalerHec.Pq.Mode = types.StringValue(string(*resp.InputZscalerHec.Pq.Mode))
			} else {
				r.InputZscalerHec.Pq.Mode = types.StringNull()
			}
			r.InputZscalerHec.Pq.Path = types.StringPointerValue(resp.InputZscalerHec.Pq.Path)
		}
		r.InputZscalerHec.PqEnabled = types.BoolPointerValue(resp.InputZscalerHec.PqEnabled)
		r.InputZscalerHec.RequestTimeout = types.Float64PointerValue(resp.InputZscalerHec.RequestTimeout)
		r.InputZscalerHec.SendToRoutes = types.BoolPointerValue(resp.InputZscalerHec.SendToRoutes)
		r.InputZscalerHec.SocketTimeout = types.Float64PointerValue(resp.InputZscalerHec.SocketTimeout)
		r.InputZscalerHec.Streamtags = make([]types.String, 0, len(resp.InputZscalerHec.Streamtags))
		for _, v := range resp.InputZscalerHec.Streamtags {
			r.InputZscalerHec.Streamtags = append(r.InputZscalerHec.Streamtags, types.StringValue(v))
		}
		if resp.InputZscalerHec.TLS == nil {
			r.InputZscalerHec.TLS = nil
		} else {
			r.InputZscalerHec.TLS = &tfTypes.InputZscalerHecTLSSettingsServerSide{}
			r.InputZscalerHec.TLS.CaPath = types.StringPointerValue(resp.InputZscalerHec.TLS.CaPath)
			r.InputZscalerHec.TLS.CertificateName = types.StringPointerValue(resp.InputZscalerHec.TLS.CertificateName)
			r.InputZscalerHec.TLS.CertPath = types.StringPointerValue(resp.InputZscalerHec.TLS.CertPath)
			if resp.InputZscalerHec.TLS.CommonNameRegex == nil {
				r.InputZscalerHec.TLS.CommonNameRegex = types.StringNull()
			} else {
				commonNameRegexResult22, _ := json.Marshal(resp.InputZscalerHec.TLS.CommonNameRegex)
				r.InputZscalerHec.TLS.CommonNameRegex = types.StringValue(string(commonNameRegexResult22))
			}
			r.InputZscalerHec.TLS.Disabled = types.BoolPointerValue(resp.InputZscalerHec.TLS.Disabled)
			if resp.InputZscalerHec.TLS.MaxVersion != nil {
				r.InputZscalerHec.TLS.MaxVersion = types.StringValue(string(*resp.InputZscalerHec.TLS.MaxVersion))
			} else {
				r.InputZscalerHec.TLS.MaxVersion = types.StringNull()
			}
			if resp.InputZscalerHec.TLS.MinVersion != nil {
				r.InputZscalerHec.TLS.MinVersion = types.StringValue(string(*resp.InputZscalerHec.TLS.MinVersion))
			} else {
				r.InputZscalerHec.TLS.MinVersion = types.StringNull()
			}
			r.InputZscalerHec.TLS.Passphrase = types.StringPointerValue(resp.InputZscalerHec.TLS.Passphrase)
			r.InputZscalerHec.TLS.PrivKeyPath = types.StringPointerValue(resp.InputZscalerHec.TLS.PrivKeyPath)
			if resp.InputZscalerHec.TLS.RejectUnauthorized == nil {
				r.InputZscalerHec.TLS.RejectUnauthorized = types.StringNull()
			} else {
				rejectUnauthorizedResult22, _ := json.Marshal(resp.InputZscalerHec.TLS.RejectUnauthorized)
				r.InputZscalerHec.TLS.RejectUnauthorized = types.StringValue(string(rejectUnauthorizedResult22))
			}
			r.InputZscalerHec.TLS.RequestCert = types.BoolPointerValue(resp.InputZscalerHec.TLS.RequestCert)
		}
		if resp.InputZscalerHec.Type != nil {
			r.InputZscalerHec.Type = types.StringValue(string(*resp.InputZscalerHec.Type))
		} else {
			r.InputZscalerHec.Type = types.StringNull()
		}
	}

	return diags
}
